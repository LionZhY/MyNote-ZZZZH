# C++ 八股文

# 基础

------



## const

> 被const修饰的值不能改变，只读，必须在定义的时候就给它赋初值

* **修饰变量**，说明变量不能被改变

* **修饰指针**
  
  > 这两个名称网上说的会不一致，记内容就好，不要纠结名称
  
  * **指针常量：**指向常量，指向的值不能变（底层）
    
    > const 在*之前
    
    ~~~c++
    int a = 10;
    const int * p1 = &a; // 指向的值不能改，即a=10不能变         // 强调对象不能变
    int const *p1 = &a;// 也可以这么写
    ~~~
    
  * **常量指针：**指针本身是常量，指向不能改（顶层）
    
    > const 在*之后
    
    ~~~c++
    int a = 10;
    int * const p2 = &a; // 指向不能改变，只能指向a，但是a的值可以改  // 强调指针不能改
    ~~~
  
* **修饰引用**
  
  * 引用的值是常量，用于形参类型，避免拷贝，避免函数对值的修改
  * `const int& ref = constantValue`
  
* **修饰成员函数（常函数）**
  * 常函数，不可修改对象的成员属性
  * 成员属性声明时加mutable后，常函数中依然可以修改
  
* **修饰对象（常对象）**
  * 常对象，对象前加const
  * 对象的成员变量不会被修改
  * 属性值加mutable，在常对象中可修改
  * 常对象只能调用常函数
  
* **函数参数为常量引用**
  * 表示函数不会修改传入的参数
  
* **函数参数为指向常量的指针**
  * 表示函数不会通过指针修改传入的数据

------



## **static**

> 控制变量和函数的声明周期、作用域、访问权限  ——> **静态**
>
> 不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在**该文件所在的编译模块中使用**
>
> 默认初始化为0

* **修饰普通变量**：**静态变量**
  * 在函数内部修饰的变量 `static int count = 0`
  * 在程序整个生命周期内存在，不会因为离开作用域而被销毁
  * 默认初始化为0

* **修饰普通函数**
  * **仅在定义该函数的文件内才能使用**
  * 在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static

* **修饰成员变量**：**静态成员变量**
  * 类中，使用static修饰的成员变量
  * 所有类的对象，**共享**同一个静态成员变量的副本，该变量为所有对象所有
  * **类内声明，必须在类外部单独定义**，以便为其分配存储空间，static修饰的变量先于对象存在
  * 可以被非static成员函数任意访问
  * 函数体内static变量的作用范围为该函数体，该变量内存只被分配一次，因此其值在下次调用时仍维持上次的值
  * 模块内static全局变量，可以被模块内所有函数访问，不能被模块外其他函数访问

* **修饰成员函数**：**静态函数**
  * 类内部使用static修饰的成员函数
  * **属于类**，而不属于类的对象，**可以通过类名直接调用**，无需创建对象
  * 所以静态成员函数**没有this指针**（this指针是指向本对象的指针），只能访问static类成员
  * 不能被virtual修饰（不能作为虚函数，因为没有this指针）
  * 不能被声明为const、虚函数、volatil
  * 不能直接访问非静态成员变量和非静态成员函数
  * 可以被非静态成员函数任意访问
  * 模块内static函数，只能被这一模块的其他函数调用，使用范围只在声明它的模块内

------



## inline内联函数

~~~c++
// 声明1（加 inline，建议使用）
inline int funName(int first, int second,...);

// 声明2（不加 inline）
int funName(int first, int second,...);
// 定义
inline int funName(int first, int second,...) {/****/};

// 类内定义，隐式内联
class A {
    int doA() { return 0; }         // 隐式内联
}

// 类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联


~~~

**特征**

- inline建议编译器调用函数编译时，把内联函数的代码副本直接**放在每个调用该函数的地方。**
- 不用执行进入函数的步骤**，**直接执行函数体。
- 通常与类一起使用，**类内定义的成员函数都是内联函数**（不需要显式使用inline关键字，类外定义需要）
- 内联函数声明必须在调用语句之前

**inline适用于什么函数**

- 频繁调用的、短小简单的函数，不能包含递归、循环、Switch等复杂条件

**编译器对inline函数的处理步骤**

1. 将inline函数体，复制到inline函数的调用点处
2. 为所用inline函数中的局部变量分配内存空间
3. 将inline函数的输入参数和返回值，映射到调用方法的局部变量空间中
4. 如果inline函数有多个返回点，将其转变为inline函数代码块末尾的分支（使用GOTO）

**优点**

- 减少函数调用的开销（在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等）

**缺点**

- 需要更多内存，10个地方调用同一个内联函数，就需要10个副本，过渡使用会导致代码膨胀，增加可执行文件的大小，降低缓存效率
- 编译时间增加，在头文件中定义inline函数，每次包含头文件时，都会重新编译函数体
- 调试困难，函数体被插入到调用处，不方便调试时查看函数的具体执行
- 链接，如果一个inline函数在多个编译单元中都被使用，会引发多重定义的问题，

------



## #define宏

> 预处理器是一些指令，指示编译器在**实际编译之前**所需完成的预处理。
>
> 所有的预处理器指令都是以井号（#）开头，预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。
>
> 预处理指令包括比如 #include、#define、#if、#else、#line 等。

#define 用于创建**符号常量**，该符号常量称为**宏**。

是预处理指令，在**预编译时**处理宏

只是简单的**字符串替换**，无类型检查，不安全

~~~c++
#define macro-name replacement-text 
// 在该文件中后续出现的所有宏（macro-name），都会在编译之前被替换为replacement-text
~~~

**参数宏**

~~~c++
#include <iostream>
using namespace std;

// 带有参数的宏 MIN()
#define MIN(a,b) (a<b ? a : b)
 
int main ()
{
   int i, j;
   i = 100;
   j = 30;
   cout <<"较小的值为：" << MIN(i, j) << endl; // 输出30
   // MIN(i,j)被预处理器展开为：(i < j ? i : j)

   return 0;
}
~~~

在 C/C++ 预处理器中，**宏定义默认只能写在一行内**。**如果有多行，每行结尾要加 “ \\"**

~~~c++
#define LOG_INFO(logmsgFormat, ...) \
    do { \
        Logger &logger = Logger::instance(); \
        logger.setLogLevel(INFO); \
        char buf[1024] = {0}; \
        snprintf(buf, 1024, logmsgFormat, ##__VA_ARGS__); \
        logger.log(buf); \
    } while(0)

~~~

如果不加 `\`，编译器会**把换行当作宏定义的结束**，导致编译错误。

~~~c++
#define LOG_INFO(logmsgFormat, ...)  // 这里的宏在换行后就结束了
do { 
    Logger &logger = Logger::instance();  // 这里的代码不会被认为是宏的一部分
    logger.setLogLevel(INFO);
    char buf[1024] = {0};
    snprintf(buf, 1024, logmsgFormat, ##__VA_ARGS__);
    logger.log(buf);
} while(0)
~~~











## define和typedef的区别

**define：**

- 只是简单的字符串替换，没有类型检查
- 在编译的预处理阶段起作用
- 可以用来防止头文件重复引用
- 不分配内存，给出的是立即数，有多少次使用就进行多少次替换

**typedef：**

~~~c++
typedef 现有类型 新类型名;

typedef unsigned int uint;
uint a = 10;  // 等价于 unsigned int a = 10;
~~~

- 有对应的数据类型，要进行判断
- 在编译、运行的时候起作用
- 在静态存储区分配空间，在程序运行过程中，内存中只有一个拷贝

宏定义主要用于定义常量及书写复杂的内容，typedef主要用于定义类型别名。

宏不是语句，不用加分号；typedef是语句，需要加分号





## const和define的区别

const用于定义常量，define用于定义宏，而宏也可以用于定义常量

都用于定义常量时，区别：

- const生效于编译的阶段；define生效与预处理阶段
- const定义的常量，存储在内存中，需要额外的内存空间；define定义的常量，运行时是直接的操作数，不会放在内存中
- const定义的常量是带类型的，有类型检查；define定义的常量不带类型，没有类型检查

------



## define宏函数和普通函数

**编译过程上不同**

- 宏定义函数，**预编译时**会将这些宏定义函数**按展开的规则直接展开成语句**，并且宏定义函数在代码中书写多少次，便**展开多少次**，拷贝相应的代码插入，生成相应的指令
- 而对于普通函数而言其**只会生成一份相应的指令**，调用处会生成传参指令和调用指令实现对函数的调用。

**执行过程上不同**

- 宏定义式函数所有的语句都是**普通语句执行**
- 普通函数由于需要调用的缘故，需要进行**开辟栈空间、压栈、出栈等操作**。

------



## define宏函数和inline内联函数

**相同点**

- 都会在代码书写处，**直接拷贝一份指令**，不会像普通函数一样单独生产指令然后调用

**define：**

- 定义预编译时处理的宏，**预编译时展开**
- 只是简单的字符串替换（编译前），无类型检查，不安全
- 不能调试

**inline：**

- 先将内联函数编译完成，是在**编译阶段展开到生成指令中的**，而不是预编译阶段展开到代码中
- 什么时候调用内联函数，就会将展开后的指令插入进去
- 内联函数是一种特殊的函数，会进行类型检查（编译时）
- 可以使用调试器调试

**宏不可调试**，内联机制既具备宏代码的效率，又增加了安全性，而且可以自由操作的类的数据成员，所以**应该尽量使用内联函数来取代宏代码。**

------



## assert 

断言，是宏，而非函数

assert 宏的原型定义在 `<assert.h>`（C）、`<cassert>`（C++）中，其作用是**如果它的条件返回错误，则终止程序执行**。

可以通过定义 `NDEBUG` 来关闭 assert，但是需要在源代码的开头，`include <assert.h>` 之前。

~~~c++
#define NDEBUG          // 加上这行，则 assert 不可用
#include <assert.h>

assert( p != NULL );    // assert 不可用

~~~

~~~c++
#include <stdio.h>
#include <assert.h>

int main()
{
  int x = 7;

  /*  中间的一些大代码假设x意外地变成了9 */
  x = 9;

  // 程序员假设x在其余代码中为7
  assert(x == 7); // assert_use: assert_use.cpp:13: int main(): Assertion `x == 7' failed. Aborted

  /* 其余代码 */
  return 0;
}


~~~

------



## volatile

~~~c++
for(volatile int i=0; i<100000; i++); // 空循环，会执行，不会被优化掉
~~~

提醒编译器使用volatile声明的变量**随时有可能改变**，因此**编译器对访问该变量的代码不再进行优化。**

可以提供对特殊地址的稳定访问，编译生成的程序在每次存储或读取该变量时，都会**直接从内存中读取**，而不是直接从寄存器拷贝内容。

**用在哪？**

- 中断服务程序中，修改的供其他程序检测的变量，需要加volatile
- 多任务环境下，各任务之间共享的标志，应该加volatile
- 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义



## 枚举 enum

**枚举类型**(enumeration)是 C++ 中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。

~~~c++
enum <类型名> {<枚举常量表>};
~~~

**"枚举常量"**或称"枚举成员"，是以标识符形式表示的整型量，表示该**枚举类型变量可能的取值**。

各枚举常量之间以"，"间隔，且必须各不相同。取值类型与条件表达式相同。

~~~c++
enum color_set1 {RED, BLUE, WHITE, BLACK}; // 定义枚举类型color_set1
enum week {Sun, Mon, Tue, Wed, Thu, Fri, Sat}; // 定义枚举类型week
~~~

编译系统**为每个枚举常量指定一个整数值**，默认状态下，这个数就是**所列举元素的编号**，**序号从0开始**。

可以在定义枚举类型时为部分或全部枚举常量**指定整数值**，在指定值之前的枚举常量仍按默认方式取值，指定值之后的枚举常量按依次加1的原则取值。

各枚举常量的值可以重复。

~~~c++
enum fruit_set {apple, orange, banana = 1, peach, grape};
// apple = 0, orange = 1, banana = 1, peach = 2, grape = 3
~~~

枚举常量智能以**标识符形式**表示，不能是整型、字符型等文字常量。

~~~c++
enum letter_set {'a','d','F','s','T'}; // 错误，枚举常量不能是字符常量
enum year_set{2000,2001,2002,2003,2004,2005}; // 错误，枚举常量不能是整型常量

// 可改为
enum letter_set {a, d, F, s, T};
enum year_set{y2000, y2001, y2002, y2003, y2004, y2005};
~~~



**枚举类型的使用**

定义枚举类型的目的是为了增加程序的可读性。

定义格式：定义枚举类型之后，就可以定义**该枚举类型的变量**

~~~c++
color_set1 color1, color2;
~~~

也可类型与变量同时定义（甚至类型名可省）

~~~c++
enum {Sun, Mon, Tue, Wed, Thu, Fri, Sat} weekday1, weekday2;
~~~

枚举变量的值，只能取枚举常量表中所列的值，就是整型数的一个子集。

枚举变量占用内存的大小与整型数相同。

枚举变量只能参与**赋值、关系运算、输出操作**，参与运算时**用其本身的整数值**。

~~~c++
enum color_set1 {RED, BLUE, WHITE, BLACK} color1, color2;
enum color_set2 { GREEN, RED, YELLOW, WHITE} color3, color4;

// 允许的赋值操作
color3 = RED;	// 将枚举常量赋给枚举变量
color4 = color3;// 相同类型的枚举变量赋值，color4的值为RED
int i = color3; // 将枚举变量赋给整型变量，i的值为1
int j = GREEN;  // 将枚举常量赋给整型变量，j的值为0

// 允许的关系运算 == < > <= >= != 等
if (color3 == color4) cout << "相等"; // 比较同类型枚举变量
cout << color3 < WHITE;// 比较变量color3和WHITE，结果为1
~~~

**枚举变量可以直接输出，输出的是变量的整数值。**

~~~c++
cout << color3; // 输出的是color3的整数值，即RED的整数值 1
~~~

**注意：**

- 枚举变量可以直接输出，但不能直接输入
- 不能直接将常量赋给枚举变量，例如 `color1 = 1`，非法
- 不同类型的枚举变量之间不能相互赋值
- 枚举变量的输入输出一般都采用Switch语句，将其转换为字符或字符串；枚举类型数据的其他处理也往往应用Switch语句，以保证程序的合法性和可读性





## 数据类型

**整型数据长度**

- short 至少16位
- int 至少与short一样长
- long 至少32位，且至少与int一样长
- long long 至少64位，且至少与long一样长

在使用8位字节系统中，1byte = 8bit。

可以通过`sizeof()`判断数据类型长度

**很多系统都使用最小长度**

- short 16位（2字节）
- long 32位  （4字节）
- long long  64位（8字节）
- int  32位（4字节）

**头文件` <climits>`定义了符号常量，如：**

- INT_MAX  表示int最大值
- INT_MIN   表示int最小值

**无符号类型**

即不存储负数值的整型，可以增大变量能够存储的最大值，数据长度不变

int被设置为自然长度，即计算机处理起来效率最高的长度，所以选择类型时一般选用int

------



## 指针和引用

> 指针和应用都是一种**内存地址**的概念，**指针是一个实体，引用是一个别名**

### **指针**（地址）

~~~c++
int a = 10;
int *p; // 声明指针变量p
p = &a; // p指向a，p存放的就是a的地址, &a表示a的地址
		// *p = 10，*是解引用，*p就是通过p里存的地址找到a
~~~

- 存放某个对象的地址，**指针就是内存地址**，指针变量就是用来存放地址的变量

- 指针大小是固定的：32位平台上是4个字节，64位平台上是8个字节（和编译环境有关，和机器的位数无关）
- 指针本身就是变量，所以可以有指向指针的指针（二级指针）
- 可变化，所指向的地址，和地址中存放的数据都可变



### 指针常量和常量指针

> 这两个名称网上说的会不一致，记内容就好

* **指针常量：**指向常量，指向的值不能变（底层）

  > const 在*之前

  ~~~c++
  int a = 10;
  const int * p1 = &a; // 指向的值不能改，即a=10不能变         // 强调对象不能变
  int const *p1 = &a;// 也可以这么写
  ~~~

* **常量指针：**指针本身是常量，指向不能改（顶层）

  > const 在*之后

  ~~~c++
  int a = 10;
  int* const p2 = &a; // 指向不能改变，只能指向a，但是a的值可以改  // 强调指针不能改
  ~~~





### 引用（别名）

~~~c++
int a = 10;
int &ref = a;// ref是一个初始化为a的整型引用，且只能一直是a的别名，ref=10
~~~

- 引用是某个已存在变量的别名，可以用这个别名来指向原来的变量
- 一旦初始化就不可以发生改变，本质上是一个指针常量（指向不能改变）
- 常量引用：函数形参列表中，加const修饰形参，防止形参改变实参
- 引用必须初始化，之后不能改变
- 别名可以和原名一样



### 指针和引用的区别

- 指针是变量，存放地址；引用只是别名，是同一块内存的别名
- 指针内容可变；引用不可变
- 指针可以指向空；引用必须初始化，没有空引用
- 指针通常用于动态内存分配，数组操作，函数传参；引用通常用于函数传参，操作符重载，创建别名
- sizeof指针，得到指针本身大小；sizeof引用，得到所引用对象的大小
- 指针自增，指向下一个内存单元；引用自增，改变引用对象的值



### 为什么指针指向能改，引用不能改？

程序在编译时，分别将指针和引用添加到符号表上，符号表中记录的是变量名和变量所对应的地址。

指针变量在符号表上对应的地址值为指针变量的地址值；

引用在符号表上对应的地址值为引用对象的地址值（即实参的地址）

符号表生成后不会再改，所以指针可以改变指向的对象，而引用不能改。



### 传值、传指针、传引用、传常量引用

![image-20250328221412456](C:\Users\h\AppData\Roaming\Typora\typora-user-images\image-20250328221412456.png)

- **传值** `(int x)`

  - 只是把实参（a）的数值传进去进行计算
  - **值传递：**形参作为被调函数的局部变量，在栈中开辟内存，**存放传进来的实参值**，形成一个**实参的副本**
  - 函数内部修改形参，是在修改实参的副本，**不会影响原始实参**

  ~~~c++
  #include <iostream>
  
  void func(int x) {  // 形参 x 是实参 a 的拷贝
      x = 100;  // 修改 x，不影响 a
  }
  
  int main() {
      int a = 10;
      func(a);  // 传递 a 的值
      std::cout << a << std::endl;  // 仍然输出 10
  }
  ~~~

- **传指针** `(int* x)`

  - 传指针，就是**传变量a的地址**，形参p存储a的地址
  - 修改 *p就是在修改a的值

  ~~~c++
  #include <iostream>
  
  void func(int *p) {  // p 是指向 a 的指针，存储a的地址
      *p = 100;  // 通过指针修改 a，*p访问p指向的地址（即a的地址），改变a的值
  }
  
  int main() {
      int a = 10;
      func(&a);  // 将a 的地址 &a，传给指针形参p
      std::cout << a << std::endl;  // 输出 100
  }
  ~~~

- **传引用 **`(int& x)`

  - 传指针的升级版，底层看传进来的也是**a的地址&a**，x是a的**别名**，不是拷贝，**x和a指向同一块内存**
  - 直接用x操作就可以，**操作x就是操作a**
  - 传引用不会额外占用指针存储地址的空间，而传指针需要存储地址值。
  - **为什么不直接用指针找地址再操作呢？**因为有可能在函数里指针可能不小心被改变指向，这样就找不到原来的地址了，但是引用是直接用别名指向的同一块内存，引用是固定的

  ~~~c++
  #include <iostream>
  
  void func(int &x) {  // x 是 a 的引用，直接操作 a
      x = 100;  // 修改 x，相当于修改 a
  }
  
  int main() {
      int a = 10;
      func(a);  // 传递 a，但实际上传递的是 &a
      std::cout << a << std::endl;  // 输出 100
  }
  ~~~

- **传常量引用** `(const int& x)`

  - 避免了传值带来的性能开销，同时保证**实参不会被修改**

  ~~~c++
  #include <iostream>
  
  void func(const int &x) {  // x 是 a 的常量引用
      x = 20;  // 直接编译错误，不能修改常量引用
  }
  
  int main() {
      int a = 10;
      func(a);  // 传递 a，但实际上传递的是 &a
      std::cout << a << std::endl;  // a = 10 不会被改变
  }
  ~~~

  

**传指针和传引用对比**

![image-20250328222332190](C:\Users\h\AppData\Roaming\Typora\typora-user-images\image-20250328222332190.png)



## new、delete和malloc、free

> 都用于内存的动态申请和释放

### new

- 实际执行两个过程：
  - ① 分配未初始化的内存空间**（malloc）**
  - ② 使用对象的构造函数，对空间进行初始化，返回空间的首地址
- 异常
  - 第一步内存分配失败，会抛出std::bad_alloc异常
  - 第二步构造对象异常，会自动调用delete释放内存

### delete

- 两个过程：
  - ① 使用析构函数对对象进行析构
  - ② 回收内存空间**（free）**



### new和malloc的区别：

> new得到的是一个初始化后的空间，malloc得到的是未初始化的空间。
>
> new是new一个类型，malloc是malloc一个字节长度的空间；delete一个类型，free一个字节长度的空间

- **类型**
  - new、delete是C++的运算符，分配和释放内存，可以调用对象的构造函数和析构
  - malloc、free是C/C++的标准库函数，只能分配和回收内存，不会调用构造和析构
- **返回类型**
  - new返回的是具体类型的指针，不需要进行类型转换
  - malloc返回的是void*，需要进行类型转换（因为它不知道所分配内存的用途）
- **分配内存大小**
  - new自动计算要分配空间的大小，动态分配，并知道大小
  - malloc只能分配指定大小的内存块，不了解分配内存块的具体用途
- **内存分配失败时**
  - new抛出`std::bad_alloc`异常
  - malloc返回`NULL`
- **释放内存**
  - delete会调用对象的析构函数，释放内存
  - free只是简单的释放内存块
- **释放后**
  - delete释放的内存块的指针，会被设置为`nullptr`，以避免野指针
  - free不会修改指针的值，可能导致野指针



## 函数在头文件中声明需要注意什么？

内部使用的函数（相当于类的私有方法），声明不应该放在头文件中

内部使用的宏、枚举、结构定义不应放在头文件中



## 变量和作用域

### **三种变量：**

- **局部变量：**在函数或一个代码块内部声明的变量（大括号内{ }）
- **形式参数：**函数参数的定义中声明的变量
- **全局变量：**在所有函数外部声明的变量

在程序中，**局部变量和全局变量的名称可以相同**，但是在**函数内，局部变量的值会覆盖全局变量的值。**

~~~c++
#include <iostream>
using namespace std;
 
// 全局变量声明
int g = 20;
 
int main ()
{
  // 局部变量声明
  int g = 10;
 
  cout << g; // 输出g=10
 
  return 0;
}
~~~



***初始化局部变量和全局变量***

- 局部变量被定义时，系统不会对其初始化，必须自行对其初始化

- 全局变量被定义时，**系统会自动初始化**

  <img src="C:\Users\h\AppData\Roaming\Typora\typora-user-images\image-20250330145939488.png" alt="image-20250330145939488" style="zoom: 50%;" />



### **作用域：**

- **局部作用域：**

  - 函数内部声明的变量，具有局部作用域，它们只能在函数内部访问
  - 局部变量在函数每次被调用时被创建，在函数执行完后被销毁

- **全局作用域：**

  - 在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的**任何函数**访问。
  - 全局变量在程序开始时被创建，在程序结束时被销毁。

- **块作用域：**

  - 在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。

  - 块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。

    ~~~c++
    #include <iostream>
    
    int main() {
        int a = 10;// 外部
        {
            int a = 20;  // 块作用域变量
            std::cout << "块变量: " << a << std::endl;// 20
        }
        std::cout << "外部变量: " << a << std::endl;// 10
        return 0;
    }
    ~~~

- **类作用域：**

  - 在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。
  - 类作用域变量的生命周期，与类的生命周期相同。







## C和C++的区别

- **C是一种结构化语言，**重点在于算法和数据结构，首先考虑是如何通过一个代码一个过程对输入进行运算处理输出

- **C++面向对象，**首先考虑如何构造一个对象模型，让这个模型能够契合对应的问题，通过获取对象的状态信息得到输出

- **C++允许自己定义自己的空间**，C不可以

- **函数方面：**C++中有重载和虚函数的概念

- **new和delete：**C++中的new和delete是对内存分配的运算符，取代了C中的malloc和free

- **C中没有字符串类型：**标准C++中的字符串类，取代了标准C函数库头文件中的字符数组处理函数

- **变量定义：**

  - C++中允许变量语句在程序中任何地方（使用之前就可以）；

  - C语言中必须在函数开头部分

- **C++中增加了引用**

- **struct方面：**

  - C++的struct可以有成员变量和成员函数，增加了权限访问，struct的默认成员访问权限和默认集成权限都是public

  - C的struct更适合看做一个数据结构的实现体，C++的class更适合看成一个对象的实现体

  - C的struct没有继承关系，C++的class有继承关系

  - C++中class的默认成员访问权限和集成权限都是private

- **C++中增加了模板，重用代码，提供了stl标准库**

- **C++相对与C增加了一些关键字**，如：bool、using、dynamic_cast、namespace等等

  







# 内存

------

## C++如何管理内存

<img src="C:\Users\h\AppData\Roaming\Typora\typora-user-images\image-20250330143032403.png" alt="image-20250330143032403" style="zoom:80%;" />

**栈：**

- 函数参数、局部变量
- 编译器自动分配释放
- 注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

**堆：**

- new开辟堆内存，delete释放
- **程序员**分配释放
- 如果程序员没有释放掉，在程序结束后，操作系统会自动回收

**自由存储区：**

- 如果说堆是操作系统维护的一块内存，那么自由存储区是C++中通过new和delete动态分配和释放对象的抽象概念。
- 需要注意的是，自由存储区，和堆比较像，但不等价

**全局（静态）存储区：**

- 全局变量、静态变量（static）
- 操作系统释放

**常量区：**

- 全局常量（const修饰的全局常量），字符串常量
- 操作系统释放

**代码区：**

- 函数体的二进制代码
- 操作系统管理
- 共享、只读



## 堆和栈的区别

内存管理：

- 堆内存是动态分配的，即可以在运行时决定分配多少内存
- 栈内存是在编译时就已经确定的

生命周期：

- 堆的生命周期取决于程序员的管理，当使用new分配了一块堆内存后，它会一直存在，直到使用delete释放
- 栈的生命周期取决于其作用域，当变量的作用域结束后，它占用的栈内存就会被自动释放

性能：

- 堆需要在运行时查找足够大的内存块来分配，速度相对较慢
- 栈是以连续、固定大小的块来管理的，所以分配和释放速度都比堆内存要快

空间大小：

- 堆空间大，受限于计算机系统中可用的总内存
- 栈空间相对较小，当尝试在栈上分配大量内存，可能会导致栈溢出

碎片化：

- 频繁的在堆上分配和释放小块内存可能会导致内存碎片化，降低程序性能
- 栈上不会有这个问题



## 内存泄漏？检测和避免？

### 内存泄漏

一般指**堆内存泄漏**，内存申请后，**用完没释放**，造成可用内存越来越少。

- 堆内存使用完后必须显式释放，应用程序般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，必须调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了

和内存溢出的区别：

- **内存溢出**指的是内存越界，常见为调用递归函数没有结束条件，导致栈内存不足而溢出

检测工具：

- Linux下：Valgrind工具
- Windows下：CRT库

### **造成内存泄漏的常见情况**

- 指针重新赋值
- 错误的内存释放（new申请，但是用free释放）
- 返回值的不正确处理（返回值为指针或引用）

### 如何避免内存泄漏

- 尽量避免在堆上分配内存
- 有new就有delete，有malloc就有free，保证它们一定成对出现
- 对象数组的释放一定要用`delete[]`
- 计数：使用new或者malloc时，计数+1，使用delete或free后，计数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄漏
- 一定要将基类的析构函数声明为虚函数
- 使用`RALL`，它充分利用里C++语言局部对象自动销毁的特性来控制资源的生命周期
- 使用协程，协程具有独立的栈空间，并且能长时间的暂存栈上的数据





# 面向对象

------

## 三大特性

### 封装

将客观实物抽象成类，类可以把自己的数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏。

一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。

### 继承

子类继承父类，某个类型的对象获得另一个类型对象的属性的方法。

三种方式：

- 实现继承：使用基类的属性和方法而无需额外编码的能力
- 接口继承：仅使用属性和方法的名称、但是子类必须提供实现的能力
- 可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力（不常用）

### 多态

同一事物表现出不同事物的能力，向不同对象发送同一消息，不同的对象在接收时会产生不同的行为

允许将父对象设置成和一个或多个它的子对象相等，赋值之后，父对象可以根据当前赋值给它的子对象的特性以不同的方式运作。**允许将子类类型的指针赋值给父类类型的指针**

实现方式：

- 重载 —>  静态多态：允许存在多个同名函数，参数表不同

- 覆盖 —>  动态多态：子类重新定义父类的虚函数  

多态与非多态的实质区别就是函数地址是早绑定还是晚绑定的。

- 如果函数的调用，在编译期间就可以确定函数的调用地址，并产生代码，就是静态的，即地址早绑定
- 如果函数调用的地址不能在编译期间确定，在运行时才能确定，就是动态的，地址晚绑定



## 类

### 什么是类？类如何调用自己的方法？（this指针）

类是封装数据和函数的组合，具有相同性质的对象，可以抽象为类。

类通过this指针调用自己的方法：

- this指针指向被调用成员函数所属的对象
- this指针隐含在每一个**非静态**成员函数内
- this指针不需要定义，直接使用
- 当形参和成员变量同名时，可以用this指针来区分
- 在类的非静态成员函数中，返回对象本身，可以用`return *this`



### class和struct的区别





### 如何让一个类只在栈上创建？只在堆上创建？

**创建类对象**

- 静态创建 — 直接创建 — 栈上
  - 编译器为对象在栈空间分配内存
  - 移动栈顶指针获得合适空间
  - 调用构造函数生成对象
- 动态创建 — new — 堆上
  - new为对象在堆中分配内存，执行operator new()函数，在堆中搜索一块内存进行分配
  - 调用构造函数创建对象

**只在栈上（静态创建）**

- 限制new的使用
- new和delete重载

**只在堆上（动态创建）**

- 构造、析构设为私有



## 多态

### 静态多态

- 函数重载，运算符重载、复用函数名
- 函数地址早绑定 --- **编译阶段**确定函数地址

### 动态多态

- 派生类、虚函数实现运行时多态

- 函数地址晚绑定 --- **运行阶段**确定函数地址

- 类之间通过**继承**关联时，用到多态

- 调用成员函数时，会根据调用函数的**对象类型**来执行不同的函数

- 可以有多个不同的类，都带有**同一个名称但具有不同实现的函数**，函数的参数甚至可以是相同的。

- 满足条件

  - 有继承关系

  - 子类重写父类的虚函数

    - 重写：函数返回值类型，函数名，参数列表，完全相同

    - 子类中的virtual可加可不加

- 使用

  - 父类的指针或引用，指向子类对象



## 虚函数

### 什么是虚函数？

类中使用`virtual`声明的函数。

**实现动态多态**（静态多态主要是重载）。

- **动态多态** **满足条件**
  - 有**继承**关系
  - 子类要**重写**父类的虚函数 （函数返回值类型，函数名，参数列表 完全相同）（子类中的virtual可加可不加）
- **动态多态** **使用**
  - 父类的指针或引用，指向子类对象

在子类中，重新定义基类中定义的虚函数时，会告诉编译器，不要静态链接到该函数。

一个父类类型的指针，指向一个子类对象时，使用父类的指针去调用子类中重写了父类中的虚函数时，会调用子类重写过的函数。

**不要在构造或者析构中调用虚函数！！！**

**析构函数一定是虚函数！**

**虚函数实现：**

- 在有虚函数的类中，类的最开始部分是一个**虚函数表指针**，指向一个**虚函数表**，表中存放**虚函数的地址**
- 当子类继承了父类的时候，也会继承父类的虚函数表
- 当子类重写父类中的虚函数，会将其继承到的虚函数表中的地址，**替换为子类重新写的虚函数地址**
- 使用虚函数，会增加访问内存开销，降低效率

![image-20250531181702370](C:\Users\h\AppData\Roaming\Typora\typora-user-images\image-20250531181702370.png)

![image-20250531182214157](C:\Users\h\AppData\Roaming\Typora\typora-user-images\image-20250531182214157.png)



### 为什么static成员函数不能被virtual修饰（为什么不能作为虚函数 - vptr）

虚函数的实现，是为每个对象分配一个vptr虚指针，vptr是通过**this指针**调用的

而**static成员函数属于类，不属于类的对象，所以它没有this指针**（this指针指向对象本身）

虚函数调用关系：this–>vptr–>ctable–>virtual function









# STL





# 编译





# C++11







# 
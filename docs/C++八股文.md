

# 基础

## const

> 被const修饰的值不能改变，只读，必须在定义的时候就给它赋初值

* **修饰变量**，说明变量不能被改变

* **修饰指针**
  
  > 这两个名称网上说的会不一致，记内容就好，不要纠结名称
  
  * **指针常量：**指向常量，指向的值不能变（底层）
    
    > const 在*之前
    
    ~~~c++
    int a = 10;
    const int * p1 = &a; // 指向的值不能改，即a=10不能变         // 强调对象不能变
    int const *p1 = &a;// 也可以这么写
    ~~~
    
  * **常量指针：**指针本身是常量，指向不能改（顶层）
    
    > const 在*之后
    
    ~~~c++
    int a = 10;
    int * const p2 = &a; // 指向不能改变，只能指向a，但是a的值可以改  // 强调指针不能改
    ~~~
  
* **修饰引用**
  
  * 引用的值是常量，用于形参类型，避免拷贝，避免函数对值的修改
  * `const int& ref = constantValue`
  
* **修饰成员函数（常函数）**
  * 常函数，不可修改对象的成员属性
  * 成员属性声明时加mutable后，常函数中依然可以修改
  
* **修饰对象（常对象）**
  * 常对象，对象前加const
  * 对象的成员变量不会被修改
  * 属性值加mutable，在常对象中可修改
  * 常对象只能调用常函数
  
* **函数参数为常量引用**
  * 表示函数不会修改传入的参数
  
* **函数参数为指向常量的指针**
  * 表示函数不会通过指针修改传入的数据

------



## **static**

> 控制变量和函数的声明周期、作用域、访问权限  ——> **静态**
>
> 不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在**该文件所在的编译模块中使用**
>
> 默认初始化为0

### static修饰变量函数

* **修饰普通变量**：**静态变量**
  * 在函数内部修饰的变量 `static int count = 0`
  * 在程序整个生命周期内存在，不会因为离开作用域而被销毁
  * 默认初始化为0

* **修饰普通函数**
  * **仅在定义该函数的文件内才能使用**
  * 在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static

* **修饰成员变量**：**静态成员变量**
  * 类中，使用static修饰的成员变量
  * 所有类的对象，**共享**同一个静态成员变量的副本，该变量为所有对象所有
  * **类内声明，必须在类外部单独定义**，以便为其分配存储空间，static修饰的变量先于对象存在
  * 可以被非static成员函数任意访问
  * 函数体内static变量的作用范围为该函数体，该变量内存只被分配一次，因此其值在下次调用时仍维持上次的值
  * 模块内static全局变量，可以被模块内所有函数访问，不能被模块外其他函数访问

* **修饰成员函数**：**静态函数**
  * 类内部使用static修饰的成员函数
  * **属于类**，而不属于类的对象，**可以通过类名直接调用**，无需创建对象
  * 所以静态成员函数**没有this指针**（this指针是指向本对象的指针），只能访问static类成员
  * 不能被virtual修饰（不能作为虚函数，因为没有this指针）
  * 不能被声明为const、虚函数、volatil
  * 不能直接访问非静态成员变量和非静态成员函数
  * 可以被非静态成员函数任意访问
  * 模块内static函数，只能被这一模块的其他函数调用，使用范围只在声明它的模块内



### static分配内存空间的时机⭐

- 程序开始运行前，数据段中被分配内存

- 在程序的静态存储区域（数据段）中被分配内存

- 声明周期始于启动，直到程序结束



### A.c 和B.c两个c文件中使用了两个相同名字的static变量，编译的时候会不会有问题?⭐

- 不会有问题
- 在头文件中定义static，然后这个头文件被不同的文件引用。
- static的作用域是定义它的源文件中，这样的方式，会**在每个引用它的文件中都生成一个本地的static 变量**。
- static的全局变量说明这个变量只在本模块有意义，不会影响其他模块
- static 变量是静态变量，和全局变量一样，都存放在静态存储区，编译器在编译的时候，对他们的命名是不同的。因此，存放的位置也不同
- 这时，在头文件中定义的static变量，在不同的文件中引用，就是不同的静态变量。





## inline内联函数

~~~c++
// 声明1（加 inline，建议使用）
inline int funName(int first, int second,...);

// 声明2（不加 inline）
int funName(int first, int second,...);
// 定义
inline int funName(int first, int second,...) {/****/};

// 类内定义，隐式内联
class A {
    int doA() { return 0; }         // 隐式内联
}

// 类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联


~~~

**特征**

- inline建议编译器调用函数编译时，把内联函数的代码副本直接**放在每个调用该函数的地方。**
- 不用执行进入函数的步骤**，**直接执行函数体。
- 通常与类一起使用，**类内定义的成员函数都是内联函数**（不需要显式使用inline关键字，类外定义需要）
- 内联函数声明必须在调用语句之前

**inline适用于什么函数**

- 频繁调用的、短小简单的函数，不能包含递归、循环、Switch等复杂条件

**编译器对inline函数的处理步骤**

1. 将inline函数体，复制到inline函数的调用点处
2. 为所用inline函数中的局部变量分配内存空间
3. 将inline函数的输入参数和返回值，映射到调用方法的局部变量空间中
4. 如果inline函数有多个返回点，将其转变为inline函数代码块末尾的分支（使用GOTO）

**优点**

- 减少函数调用的开销（在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等）

**缺点**

- 需要更多内存，10个地方调用同一个内联函数，就需要10个副本，过渡使用会导致代码膨胀，增加可执行文件的大小，降低缓存效率
- 编译时间增加，在头文件中定义inline函数，每次包含头文件时，都会重新编译函数体
- 调试困难，函数体被插入到调用处，不方便调试时查看函数的具体执行
- 链接，如果一个inline函数在多个编译单元中都被使用，会引发多重定义的问题，

------



## #define宏

> 预处理器是一些指令，指示编译器在**实际编译之前**所需完成的预处理。
>
> 所有的预处理器指令都是以井号（#）开头，预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。
>
> 预处理指令包括比如 #include、#define、#if、#else、#line 等。

#define 用于创建**符号常量**，该符号常量称为**宏**。

是预处理指令，在**预编译时**处理宏

只是简单的**字符串替换**，无类型检查，不安全

~~~c++
#define macro-name replacement-text 
// 在该文件中后续出现的所有宏（macro-name），都会在编译之前被替换为replacement-text
~~~

**参数宏**

~~~c++
#include <iostream>
using namespace std;

// 带有参数的宏 MIN()
#define MIN(a,b) (a<b ? a : b)
 
int main ()
{
   int i, j;
   i = 100;
   j = 30;
   cout <<"较小的值为：" << MIN(i, j) << endl; // 输出30
   // MIN(i,j)被预处理器展开为：(i < j ? i : j)

   return 0;
}
~~~

在 C/C++ 预处理器中，**宏定义默认只能写在一行内**。**如果有多行，每行结尾要加 “ \\"**

~~~c++
#define LOG_INFO(logmsgFormat, ...) \
    do { \
        Logger &logger = Logger::instance(); \
        logger.setLogLevel(INFO); \
        char buf[1024] = {0}; \
        snprintf(buf, 1024, logmsgFormat, ##__VA_ARGS__); \
        logger.log(buf); \
    } while(0)

~~~

如果不加 `\`，编译器会**把换行当作宏定义的结束**，导致编译错误。

~~~c++
#define LOG_INFO(logmsgFormat, ...)  // 这里的宏在换行后就结束了
do { 
    Logger &logger = Logger::instance();  // 这里的代码不会被认为是宏的一部分
    logger.setLogLevel(INFO);
    char buf[1024] = {0};
    snprintf(buf, 1024, logmsgFormat, ##__VA_ARGS__);
    logger.log(buf);
} while(0)
~~~











## define和typedef的区别

**define：**

- 只是简单的字符串替换，没有类型检查
- 在编译的预处理阶段起作用
- 可以用来防止头文件重复引用
- 不分配内存，给出的是立即数，有多少次使用就进行多少次替换

**typedef：**

~~~c++
typedef 现有类型 新类型名;

typedef unsigned int uint;
uint a = 10;  // 等价于 unsigned int a = 10;
~~~

- 有对应的数据类型，要进行判断
- 在编译、运行的时候起作用
- 在静态存储区分配空间，在程序运行过程中，内存中只有一个拷贝

宏定义主要用于定义常量及书写复杂的内容，typedef主要用于定义类型别名。

宏不是语句，不用加分号；typedef是语句，需要加分号





## const和define的区别

const用于定义常量，define用于定义宏，而宏也可以用于定义常量

都用于定义常量时，区别：

- const生效于编译的阶段；define生效与预处理阶段
- const定义的常量，存储在内存中，需要额外的内存空间；define定义的常量，运行时是直接的操作数，不会放在内存中
- const定义的常量是带类型的，有类型检查；define定义的常量不带类型，没有类型检查

------



## define宏函数和普通函数

**编译过程上不同**

- 宏定义函数，**预编译时**会将这些宏定义函数**按展开的规则直接展开成语句**，并且宏定义函数在代码中书写多少次，便**展开多少次**，拷贝相应的代码插入，生成相应的指令
- 而对于普通函数而言其**只会生成一份相应的指令**，调用处会生成传参指令和调用指令实现对函数的调用。

**执行过程上不同**

- 宏定义式函数所有的语句都是**普通语句执行**
- 普通函数由于需要调用的缘故，需要进行**开辟栈空间、压栈、出栈等操作**。

------



## define宏函数和inline内联函数

**相同点**

- 都会在代码书写处，**直接拷贝一份指令**，不会像普通函数一样单独生产指令然后调用

**define：**

- 定义预编译时处理的宏，**预编译时展开**
- 只是简单的字符串替换（编译前），无类型检查，不安全
- 不能调试

**inline：**

- 先将内联函数编译完成，是在**编译阶段展开到生成指令中的**，而不是预编译阶段展开到代码中
- 什么时候调用内联函数，就会将展开后的指令插入进去
- 内联函数是一种特殊的函数，会进行类型检查（编译时）
- 可以使用调试器调试

**宏不可调试**，内联机制既具备宏代码的效率，又增加了安全性，而且可以自由操作的类的数据成员，所以**应该尽量使用内联函数来取代宏代码。**

------



## assert 

断言，是宏，而非函数

assert 宏的原型定义在 `<assert.h>`（C）、`<cassert>`（C++）中，其作用是**如果它的条件返回错误，则终止程序执行**。

可以通过定义 `NDEBUG` 来关闭 assert，但是需要在源代码的开头，`include <assert.h>` 之前。

~~~c++
#define NDEBUG          // 加上这行，则 assert 不可用
#include <assert.h>

assert( p != NULL );    // assert 不可用

~~~

~~~c++
#include <stdio.h>
#include <assert.h>

int main()
{
  int x = 7;

  /*  中间的一些大代码假设x意外地变成了9 */
  x = 9;

  // 程序员假设x在其余代码中为7
  assert(x == 7); // assert_use: assert_use.cpp:13: int main(): Assertion `x == 7' failed. Aborted

  /* 其余代码 */
  return 0;
}


~~~

------



## volatile

~~~c++
for(volatile int i=0; i<100000; i++); // 空循环，会执行，不会被优化掉
~~~

提醒编译器使用volatile声明的变量**随时有可能改变**，因此**编译器对访问该变量的代码不再进行优化。**

可以提供对特殊地址的稳定访问，编译生成的程序在每次存储或读取该变量时，都会**直接从内存中读取**，而不是直接从寄存器拷贝内容。

**用在哪？**

- 中断服务程序中，修改的供其他程序检测的变量，需要加volatile
- 多任务环境下，各任务之间共享的标志，应该加volatile
- 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义



## 枚举 enum

**枚举类型**(enumeration)是 C++ 中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。

~~~c++
enum <类型名> {<枚举常量表>};
~~~

**"枚举常量"**或称"枚举成员"，是以标识符形式表示的整型量，表示该**枚举类型变量可能的取值**。

各枚举常量之间以"，"间隔，且必须各不相同。取值类型与条件表达式相同。

~~~c++
enum color_set1 {RED, BLUE, WHITE, BLACK}; // 定义枚举类型color_set1
enum week {Sun, Mon, Tue, Wed, Thu, Fri, Sat}; // 定义枚举类型week
~~~

编译系统**为每个枚举常量指定一个整数值**，默认状态下，这个数就是**所列举元素的编号**，**序号从0开始**。

可以在定义枚举类型时为部分或全部枚举常量**指定整数值**，在指定值之前的枚举常量仍按默认方式取值，指定值之后的枚举常量按依次加1的原则取值。

各枚举常量的值可以重复。

~~~c++
enum fruit_set {apple, orange, banana = 1, peach, grape};
// apple = 0, orange = 1, banana = 1, peach = 2, grape = 3
~~~

枚举常量智能以**标识符形式**表示，不能是整型、字符型等文字常量。

~~~c++
enum letter_set {'a','d','F','s','T'}; // 错误，枚举常量不能是字符常量
enum year_set{2000,2001,2002,2003,2004,2005}; // 错误，枚举常量不能是整型常量

// 可改为
enum letter_set {a, d, F, s, T};
enum year_set{y2000, y2001, y2002, y2003, y2004, y2005};
~~~



**枚举类型的使用**

定义枚举类型的目的是为了增加程序的可读性。

定义格式：定义枚举类型之后，就可以定义**该枚举类型的变量**

~~~c++
color_set1 color1, color2;
~~~

也可类型与变量同时定义（甚至类型名可省）

~~~c++
enum {Sun, Mon, Tue, Wed, Thu, Fri, Sat} weekday1, weekday2;
~~~

枚举变量的值，只能取枚举常量表中所列的值，就是整型数的一个子集。

枚举变量占用内存的大小与整型数相同。

枚举变量只能参与**赋值、关系运算、输出操作**，参与运算时**用其本身的整数值**。

~~~c++
enum color_set1 {RED, BLUE, WHITE, BLACK} color1, color2;
enum color_set2 { GREEN, RED, YELLOW, WHITE} color3, color4;

// 允许的赋值操作
color3 = RED;	// 将枚举常量赋给枚举变量
color4 = color3;// 相同类型的枚举变量赋值，color4的值为RED
int i = color3; // 将枚举变量赋给整型变量，i的值为1
int j = GREEN;  // 将枚举常量赋给整型变量，j的值为0

// 允许的关系运算 == < > <= >= != 等
if (color3 == color4) cout << "相等"; // 比较同类型枚举变量
cout << color3 < WHITE;// 比较变量color3和WHITE，结果为1
~~~

**枚举变量可以直接输出，输出的是变量的整数值。**

~~~c++
cout << color3; // 输出的是color3的整数值，即RED的整数值 1
~~~

**注意：**

- 枚举变量可以直接输出，但不能直接输入
- 不能直接将常量赋给枚举变量，例如 `color1 = 1`，非法
- 不同类型的枚举变量之间不能相互赋值
- 枚举变量的输入输出一般都采用Switch语句，将其转换为字符或字符串；枚举类型数据的其他处理也往往应用Switch语句，以保证程序的合法性和可读性





## 数据类型

**整型数据长度**

- short 至少16位
- int 至少与short一样长
- long 至少32位，且至少与int一样长
- long long 至少64位，且至少与long一样长

在使用8位字节系统中，1byte = 8bit。

可以通过`sizeof()`判断数据类型长度

**很多系统都使用最小长度**

- short 16位（2字节）
- long 32位  （4字节）
- long long  64位（8字节）
- int  32位（4字节）

**头文件` <climits>`定义了符号常量，如：**

- INT_MAX  表示int最大值
- INT_MIN   表示int最小值

**无符号类型**

即不存储负数值的整型，可以增大变量能够存储的最大值，数据长度不变

int被设置为自然长度，即计算机处理起来效率最高的长度，所以选择类型时一般选用int

------



## 指针和引用

> 指针和应用都是一种**内存地址**的概念，**指针是一个实体，引用是一个别名**

### **指针**（地址）

~~~c++
int a = 10;
int *p; // 声明指针变量p
p = &a; // p指向a，p存放的就是a的地址, &a表示a的地址
		// *p = 10，*是解引用，*p就是通过p里存的地址找到a
~~~

- 存放某个对象的地址，**指针就是内存地址**，指针变量就是用来存放地址的变量

- 指针大小是固定的：32位平台上是4个字节，64位平台上是8个字节（和编译环境有关，和机器的位数无关）
- 指针本身就是变量，所以可以有指向指针的指针（二级指针）
- 可变化，所指向的地址，和地址中存放的数据都可变



### 指针常量和常量指针

> 这两个名称网上说的会不一致，记内容就好

* **指针常量：**指向常量，指向的值不能变（底层）

  > const 在*之前

  ~~~c++
  int a = 10;
  const int * p1 = &a; // 指向的值不能改，即a=10不能变         // 强调对象不能变
  int const *p1 = &a;// 也可以这么写
  ~~~

* **常量指针：**指针本身是常量，指向不能改（顶层）

  > const 在*之后

  ~~~c++
  int a = 10;
  int* const p2 = &a; // 指向不能改变，只能指向a，但是a的值可以改  // 强调指针不能改
  ~~~





### 引用（别名）

~~~c++
int a = 10;
int &ref = a;// ref是一个初始化为a的整型引用，且只能一直是a的别名，ref=10
~~~

- 引用是某个已存在变量的别名，可以用这个别名来指向原来的变量
- 一旦初始化就不可以发生改变，本质上是一个指针常量（指向不能改变）
- 常量引用：函数形参列表中，加const修饰形参，防止形参改变实参
- 引用必须初始化，之后不能改变
- 别名可以和原名一样



### 指针和引用的区别

- 指针是变量，存放地址；引用只是别名，是同一块内存的别名
- 指针内容可变；引用不可变
- 指针可以指向空；引用必须初始化，没有空引用
- 指针通常用于动态内存分配，数组操作，函数传参；引用通常用于函数传参，操作符重载，创建别名
- sizeof指针，得到指针本身大小；sizeof引用，得到所引用对象的大小
- 指针自增，指向下一个内存单元；引用自增，改变引用对象的值



### 为什么指针指向能改，引用不能改？

程序在编译时，分别将指针和引用添加到符号表上，符号表中记录的是变量名和变量所对应的地址。

指针变量在符号表上对应的地址值为指针变量的地址值；

引用在符号表上对应的地址值为引用对象的地址值（即实参的地址）

符号表生成后不会再改，所以指针可以改变指向的对象，而引用不能改。



### 传值、传指针、传引用、传常量引用

![image-20250328221412456](C:\Users\h\AppData\Roaming\Typora\typora-user-images\image-20250328221412456.png)

- **传值** `(int x)`

  - 只是把实参（a）的数值传进去进行计算
  - **值传递：**形参作为被调函数的局部变量，在栈中开辟内存，**存放传进来的实参值**，形成一个**实参的副本**
  - 函数内部修改形参，是在修改实参的副本，**不会影响原始实参**

  ~~~c++
  #include <iostream>
  
  void func(int x) {  // 形参 x 是实参 a 的拷贝
      x = 100;  // 修改 x，不影响 a
  }
  
  int main() {
      int a = 10;
      func(a);  // 传递 a 的值
      std::cout << a << std::endl;  // 仍然输出 10
  }
  ~~~

- **传指针** `(int* x)`

  - 传指针，就是**传变量a的地址**，形参p存储a的地址
  - 修改 *p就是在修改a的值

  ~~~c++
  #include <iostream>
  
  void func(int *p) {  // p 是指向 a 的指针，存储a的地址
      *p = 100;  // 通过指针修改 a，*p访问p指向的地址（即a的地址），改变a的值
  }
  
  int main() {
      int a = 10;
      func(&a);  // 将a 的地址 &a，传给指针形参p
      std::cout << a << std::endl;  // 输出 100
  }
  ~~~

- **传引用 **`(int& x)`

  - 传指针的升级版，底层看传进来的也是**a的地址&a**，x是a的**别名**，不是拷贝，**x和a指向同一块内存**
  - 直接用x操作就可以，**操作x就是操作a**
  - 传引用不会额外占用指针存储地址的空间，而传指针需要存储地址值。
  - **为什么不直接用指针找地址再操作呢？**因为有可能在函数里指针可能不小心被改变指向，这样就找不到原来的地址了，但是引用是直接用别名指向的同一块内存，引用是固定的

  ~~~c++
  #include <iostream>
  
  void func(int &x) {  // x 是 a 的引用，直接操作 a
      x = 100;  // 修改 x，相当于修改 a
  }
  
  int main() {
      int a = 10;
      func(a);  // 传递 a，但实际上传递的是 &a
      std::cout << a << std::endl;  // 输出 100
  }
  ~~~

- **传常量引用** `(const int& x)`

  - 避免了传值带来的性能开销，同时保证**实参不会被修改**

  ~~~c++
  #include <iostream>
  
  void func(const int &x) {  // x 是 a 的常量引用
      x = 20;  // 直接编译错误，不能修改常量引用
  }
  
  int main() {
      int a = 10;
      func(a);  // 传递 a，但实际上传递的是 &a
      std::cout << a << std::endl;  // a = 10 不会被改变
  }
  ~~~

  

**传指针和传引用对比**

![image-20250328222332190](C:\Users\h\AppData\Roaming\Typora\typora-user-images\image-20250328222332190.png)



## new、delete和malloc、free

> 都用于内存的动态申请和释放

### new

- 实际执行两个过程：
  - ① 分配未初始化的内存空间**（malloc）**
  - ② 使用对象的构造函数，对空间进行初始化，返回空间的首地址
- 异常
  - 第一步内存分配失败，会抛出std::bad_alloc异常
  - 第二步构造对象异常，会自动调用delete释放内存

### delete

- 两个过程：
  - ① 使用析构函数对对象进行析构
  - ② 回收内存空间**（free）**



### new和malloc的区别：

> new得到的是一个初始化后的空间，malloc得到的是未初始化的空间。
>
> new是new一个类型，malloc是malloc一个字节长度的空间；delete一个类型，free一个字节长度的空间

- **类型**
  - new、delete是C++的运算符，分配和释放内存，**可以调用对象的构造函数和析构**
  - malloc、free是C/C++的标准库函数，只能分配和回收内存，不会调用构造和析构
- **返回类型**
  - new返回的是具体类型的指针，不需要进行类型转换
  - malloc返回的是void*，需要进行类型转换（因为它不知道所分配内存的用途）
- **分配内存大小**
  - **new自动计算要分配空间的大小**，动态分配，并知道大小
  - malloc只能分配指定大小的内存块，不了解分配内存块的具体用途
- **内存分配失败时**
  - new抛出`std::bad_alloc`异常
  - malloc返回`NULL`
- **释放内存**
  - **delete会调用对象的析构函数**，释放内存
  - free只是简单的释放内存块
- **释放后**
  - delete释放的内存块的指针，会被设置为`nullptr`，以避免野指针
  - free不会修改指针的值，可能导致野指针



### 为什么有了malloc/free还需要new/delete?

对于非内部数据而言，只有malloc和free无法满足动态对象的需求。

对象在创建的同时还要自动执行构造函数，消亡以前要自动执行析构函数。

malloc和free是库函数不是运算符，不在编译器控制权限内，不能把执行构造和析构函数的任务强加于malloc和free。







## 函数在头文件中声明需要注意什么？

内部使用的函数（相当于类的私有方法），声明不应该放在头文件中

内部使用的宏、枚举、结构定义不应放在头文件中



## 变量和作用域

### **三种变量：**

- **局部变量：**在函数或一个代码块内部声明的变量（大括号内{ }）
- **形式参数：**函数参数的定义中声明的变量
- **全局变量：**在所有函数外部声明的变量

在程序中，**局部变量和全局变量的名称可以相同**，但是在**函数内，局部变量的值会覆盖全局变量的值。**

~~~c++
#include <iostream>
using namespace std;
 
// 全局变量声明
int g = 20;
 
int main ()
{
  // 局部变量声明
  int g = 10;
 
  cout << g; // 输出g=10
 
  return 0;
}
~~~



***初始化局部变量和全局变量***

- 局部变量被定义时，系统不会对其初始化，必须自行对其初始化

- 全局变量被定义时，**系统会自动初始化**

  <img src="C:\Users\h\AppData\Roaming\Typora\typora-user-images\image-20250330145939488.png" alt="image-20250330145939488" style="zoom: 50%;" />



### **作用域：**

- **局部作用域：**

  - 函数内部声明的变量，具有局部作用域，它们只能在函数内部访问
  - 局部变量在函数每次被调用时被创建，在函数执行完后被销毁

- **全局作用域：**

  - 在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的**任何函数**访问。
  - 全局变量在程序开始时被创建，在程序结束时被销毁。

- **块作用域：**

  - 在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。

  - 块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。

    ~~~c++
    #include <iostream>
    
    int main() {
        int a = 10;// 外部
        {
            int a = 20;  // 块作用域变量
            std::cout << "块变量: " << a << std::endl;// 20
        }
        std::cout << "外部变量: " << a << std::endl;// 10
        return 0;
    }
    ~~~

- **类作用域：**

  - 在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。
  - 类作用域变量的生命周期，与类的生命周期相同。







## C和C++的区别

- **C是一种结构化语言，**重点在于算法和数据结构，首先考虑是如何通过一个代码一个过程对输入进行运算处理输出

- **C++面向对象，**首先考虑如何构造一个对象模型，让这个模型能够契合对应的问题，通过获取对象的状态信息得到输出

- **C++允许自己定义自己的空间**，C不可以

- **函数方面：**C++中有重载和虚函数的概念

- **new和delete：**C++中的new和delete是对内存分配的运算符，取代了C中的malloc和free

- **C中没有字符串类型：**标准C++中的字符串类，取代了标准C函数库头文件中的字符数组处理函数

- **变量定义：**

  - C++中允许变量语句在程序中任何地方（使用之前就可以）；

  - C语言中必须在函数开头部分

- **C++中增加了引用**

- **struct方面：**

  - C++的struct可以有成员变量和成员函数，增加了权限访问，struct的默认成员访问权限和默认集成权限都是public

  - C的struct更适合看做一个数据结构的实现体，C++的class更适合看成一个对象的实现体

  - C的struct没有继承关系，C++的class有继承关系

  - C++中class的默认成员访问权限和集成权限都是private

- **C++中增加了模板，重用代码，提供了stl标准库**

- **C++相对与C增加了一些关键字**，如：bool、using、dynamic_cast、namespace等等

  



### 在C++中调用C函数怎么做？在C中调用C++又应该怎么做？⭐

C 中调用 C++

- 先在C++代码函数前，加上extern “C”

- 然后C代码中不要include C++的头文件, 而采用直接在C中增加函数声明的方式;

C++调用C 

- 在include的时候, 要采用extern “C” 代码块形式

- 对调用的C代码进行extern “C”







# 内存

------

## C++如何管理内存

<img src="C:\Users\h\AppData\Roaming\Typora\typora-user-images\image-20250330143032403.png" alt="image-20250330143032403" style="zoom:80%;" />

**栈：**

- 函数参数、局部变量
- 编译器自动分配释放
- 注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

**堆：**

- new开辟堆内存，delete释放
- **程序员**分配释放
- 如果程序员没有释放掉，在程序结束后，操作系统会自动回收

**自由存储区：**

- 如果说堆是操作系统维护的一块内存，那么自由存储区是C++中通过new和delete动态分配和释放对象的抽象概念。
- 需要注意的是，自由存储区，和堆比较像，但不等价

**全局（静态）存储区：**

- 全局变量、静态变量（static）
- 操作系统释放

**常量区：**

- 全局常量（const修饰的全局常量），字符串常量
- 操作系统释放

**代码区：**

- 函数体的二进制代码
- 操作系统管理
- 共享、只读



## 堆和栈的区别

内存管理：

- 堆内存是动态分配的，即可以在运行时决定分配多少内存
- 栈内存是在编译时就已经确定的

生命周期：

- 堆的生命周期取决于程序员的管理，当使用new分配了一块堆内存后，它会一直存在，直到使用delete释放
- 栈的生命周期取决于其作用域，当变量的作用域结束后，它占用的栈内存就会被自动释放

性能：

- 堆需要在运行时查找足够大的内存块来分配，速度相对较慢
- 栈是以连续、固定大小的块来管理的，所以分配和释放速度都比堆内存要快

空间大小：

- 堆空间大，受限于计算机系统中可用的总内存
- 栈空间相对较小，当尝试在栈上分配大量内存，可能会导致栈溢出

碎片化：

- 频繁的在堆上分配和释放小块内存可能会导致内存碎片化，降低程序性能
- 栈上不会有这个问题



## 内存泄漏？检测和避免？

### 内存泄漏

一般指**堆内存泄漏**，内存申请后，**用完没释放**，造成可用内存越来越少。

- 堆内存使用完后必须显式释放，应用程序般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，必须调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了

和内存溢出的区别：

- **内存溢出**指的是内存越界，常见为调用递归函数没有结束条件，导致栈内存不足而溢出

检测工具：

- Linux下：Valgrind工具
- Windows下：CRT库

### **造成内存泄漏的常见情况**

- 指针重新赋值
- 错误的内存释放（new申请，但是用free释放）
- 返回值的不正确处理（返回值为指针或引用）

### 如何避免内存泄漏

- 尽量避免在堆上分配内存
- 有new就有delete，有malloc就有free，保证它们一定成对出现
- 对象数组的释放一定要用`delete[]`
- 计数：使用new或者malloc时，计数+1，使用delete或free后，计数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄漏
- 一定要将基类的析构函数声明为虚函数
- 使用`RALL`，它充分利用里C++语言局部对象自动销毁的特性来控制资源的生命周期
- 使用协程，协程具有独立的栈空间，并且能长时间的暂存栈上的数据





# 面向对象

------

## 三大特性

### 封装

将客观实物抽象成类，类可以把自己的数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏。

一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。

### 继承

子类继承父类，某个类型的对象获得另一个类型对象的属性的方法。

三种方式：

- 实现继承：使用基类的属性和方法而无需额外编码的能力
- 接口继承：仅使用属性和方法的名称、但是子类必须提供实现的能力
- 可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力（不常用）

### 多态

同一事物表现出不同事物的能力，向不同对象发送同一消息，不同的对象在接收时会产生不同的行为

允许将父对象设置成和一个或多个它的子对象相等，赋值之后，父对象可以根据当前赋值给它的子对象的特性以不同的方式运作。**允许将子类类型的指针赋值给父类类型的指针**

实现方式：

- 重载 —>  静态多态：允许存在多个同名函数，参数表不同

- 覆盖 —>  动态多态：子类重新定义父类的虚函数  

多态与非多态的实质区别就是函数地址是早绑定还是晚绑定的。

- 如果函数的调用，在编译期间就可以确定函数的调用地址，并产生代码，就是静态的，即地址早绑定
- 如果函数调用的地址不能在编译期间确定，在运行时才能确定，就是动态的，地址晚绑定



## 类

### 什么是类？类如何调用自己的方法？（this指针）

类是封装数据和函数的组合，具有相同性质的对象，可以抽象为类。

类通过this指针调用自己的方法：

- this指针指向被调用成员函数所属的对象
- this指针隐含在每一个**非静态**成员函数内
- this指针不需要定义，直接使用
- 当形参和成员变量同名时，可以用this指针来区分
- 在类的非静态成员函数中，返回对象本身，可以用`return *this`



### class和struct的区别





### 如何让一个类只在栈上创建？只在堆上创建？

**创建类对象**

- 静态创建 — 直接创建 — 栈上
  - 编译器为对象在栈空间分配内存
  - 移动栈顶指针获得合适空间
  - 调用构造函数生成对象
- 动态创建 — new — 堆上
  - new为对象在堆中分配内存，执行operator new()函数，在堆中搜索一块内存进行分配
  - 调用构造函数创建对象

**只在栈上（静态创建）**

- 限制new的使用
- new和delete重载

**只在堆上（动态创建）**

- 构造、析构设为私有



### 什么时候用到静态成员函数？

需要在没有生成对象的时候，就能调用类的成员函数。

如果需要调一个在类里，但跟类的实例无关的函数。



### class和stuct的区别 ⭐







## 多态

### 静态多态

- 函数重载，运算符重载、复用函数名
- 函数地址早绑定 --- **编译阶段**确定函数地址

### 动态多态

- 派生类、虚函数实现运行时多态

- 函数地址晚绑定 --- **运行阶段**确定函数地址

- 类之间通过**继承**关联时，用到多态

- 调用成员函数时，会根据调用函数的**对象类型**来执行不同的函数

- 可以有多个不同的类，都带有**同一个名称但具有不同实现的函数**，函数的参数甚至可以是相同的。

- 满足条件

  - 有继承关系

  - 子类重写父类的虚函数

    - 重写：函数返回值类型，函数名，参数列表，完全相同

    - 子类中的virtual可加可不加

- 使用

  - 父类的指针或引用，指向子类对象



## 虚函数

### 什么是虚函数？

类中使用`virtual`声明的函数。

**实现动态多态**（静态多态主要是重载）

- 满足条件
  - 有**继承**关系
  - 子类要**重写**父类的虚函数 （函数返回值类型，函数名，参数列表 完全相同）（子类中的virtual可加可不加）
- 使用（什么情况会触发虚函数）：
  - 子类继承父类，父类中有虚函数
  - 子类重写父类虚函数
  - 父类的指针或引用指向子类对象


在子类中，重新定义基类中定义的虚函数时，会告诉编译器，不要静态链接到该函数。

一个父类类型的指针，指向一个子类对象时，使用父类的指针去调用【子类中重写了父类中的虚函数】时，会调用子类重写过的函数。

**不要在构造或者析构中调用虚函数！！！** **析构函数一定是虚函数！**

**虚函数实现：**

- 在有虚函数的类中，类的最开始部分是一个**虚函数表指针**，指向一个**虚函数表**，表中存放**虚函数的地址**
- 当子类继承了父类的时候，也会继承父类的虚函数表
- 当子类**重写父类中的虚函数**，会将其继承到的虚函数表中的地址，**替换为子类重新写的虚函数地址**
- 使用虚函数，会增加访问内存开销，降低效率

![image-20250531181702370](C:\Users\h\AppData\Roaming\Typora\typora-user-images\image-20250531181702370.png)

![image-20250531182214157](C:\Users\h\AppData\Roaming\Typora\typora-user-images\image-20250531182214157.png)



### 哪些函数不能是虚函数？

- **构造函数**
- **内联函数 inline**
  - 内联函数表示在编译阶段进行函数体的替换操作
  - 虚函数在运行期间进行类型确定
- **静态函数 static**
  - 静态函数不属于对象，属于类
  - 静态函数没有this指针
- **友元函数**
  - 友元函数不属于类的成员函数，不能被继承
- **普通函数**
  - 不属于类的成员函数，不具有继承特性



### 为什么static成员函数不能被virtual修饰（为什么不能作为虚函数 - vptr）

虚函数的实现，是为每个对象分配一个vptr虚指针，vptr是通过**this指针**调用的

而**static成员函数属于类，不属于类的对象，所以它没有this指针**（this指针指向对象本身）

虚函数调用关系：this–>vptr–>ctable–>virtual function



### 构造函数里调用虚函数会怎样？⭐

- 语法上允许，但通常不会起作用
- 当构造函数正在执行时，对象的类型被视为**当前构造函数所属的类类型**，而不是子类型
- **父类构造无法调用子类虚函数**
- 继承关系中，先构造父类，再构造子类，析构相反
- 构造函数和析构函数，调用其他虚函数时，由于虚函数表指针指向的是当前类的虚函数表，调用的是当前类的函数
- 父类构造函数调用虚函数，调用的就是父类的版本，而不是子类版本
- 在执行构造函数前对象未完成创建，虚函数表还不存在



### 析构函数应该设置为虚函数吗？⭐

只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。**基类的析构函数一般建议声明为虚函数**。

解决问题：父类指针，释放子类对象

- 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构

析构可以为虚函数，构造不行

- 构造函数不能被声明为虚函数，因为在执行构造函数前对象未完成创建，虚函数表还不存在

纯虚析构

- 如果是纯虚析构，该类属于抽象类，无法实例化对象

  

### 一个类有几个虚表指针？类对象有虚表指针吗？

**虚指针**：

- 每个含有虚函数的类都有一张虚函数表，存储这个类所有虚函数的入口地址。
- 虚指针指向虚函数表

**存在虚函数的类至少有一个虚表指针**

- 多重继承：一个类可以从多个类中继承虚函数，可能会有多个虚表指针，每个父类一个
- 虚继承：解决菱形继承，可能会有多个虚指针

**虚函数表是针对类的，而不是对象**

- 同一个类的所有对象，**共享类的虚函数表**，不同对象的虚函数表一样。
- 每个对象内部都保存一个指向该类的虚函数表的指针 vptr
- 每个对象的vptr存放地址不同，但**指向同一虚函数表**



# STL





# 编译

## C++编译过程

预处理  =>  编译  =>  汇编  =>  链接



## 模板开发在哪个阶段？

在编译阶段。

模板是C++泛型编程的基础，一个模板就是一个创建类或者函数的公式。

在具体使用时，需要将模板参数转化为具体类型，比如 int，float，Vector以及自定义类型；这种转换过程发生在编译阶段。







# C++11

## C++11新特性

**auto**

- C++ 11引入了类型推断能力
- 使用auto关键字，编译器可以自行推断变量的类型。

**lambda**

- C++ 11可以创建匿名函数，也称为Lambda函数
- Lambda表达式允许我们在本地定义函数
- 还允许在调用处定义函数，从而消除了许多复杂性和安全风险。

**nullptr**

- 使用nullptr代替NULL或0来指定一个指向无值的指针

**noexcept**

- 如果一个函数无法抛出异常，那么可以在C++ 11中将该函数声明为noexcept，这有助于解决未知类型的错误。

**override标识符**

- 随着项目变得越来越大，需要更多的文件来完成一个任务。
- 为了避免混淆，C++ 11引入了override标识符，用于明确表示子类中的函数覆盖了基类中的同名函数。

**无序容器**

- C++ 11引入了无序容器，如unordered_map和unordered_set。

**移动语义和右值引用**

- 通过引入移动构造函数和移动赋值操作符，C++ 11支持将对象的**资源“移动”到另一个对象**，而不是创建一个完全新的副本。
- 移动构造
- 右值引用
  - 右值引用使用  `&&` 表示，用于实现移动语义和完美转发
  - 右值引用只能绑定到即将销毁的对象（通常是临时对象），而不能绑定到持久的对象

**变长模板**

- C++ 11支持变长模板，这使得模板可以接受可变数量的参数



### auto和decltype ⭐

C++ 提供了 auto 和 decltype 来静态推导类型。当知道类型没有问题但又不想写出完整类型的时候，使用静态类型推导。

auto 编译器根据初始化表达式自动推导变量类型。

decltype 用于获取一个表达式的类型，而不对表达式进行求值。

| 特性           | `auto`                             | `decltype`                                   |
| -------------- | ---------------------------------- | -------------------------------------------- |
| 是否需要初始化 | 是                                 | 否                                           |
| 是否求值       | 是，推导需要实际值                 | 否，纯粹分析表达式类型                       |
| 保留引用/const | 默认不保留顶层 const，不保留引用   | 完全保留引用和 const                         |
| 典型用途       | 声明变量、函数返回类型（C++14 起） | 获取表达式类型，用于模板推导、返回类型声明等 |





### 左值右值引用？⭐

**左值引用**

- 传统引用，别名

- 常用于函数参数传递和局部变量的别名

- 可以取地址，有名字，非临时

- 左值，在内存有确定存储地址、有变量名，表达式结束依然存在的值

- 绑定到右确定存储空间以及变量名的对象上，表达式结束后对象依然存在

**右值引用**

- C++11引入的新类型引用

- 绑定到右值的引用，通过`&&`来获得右值引用

- 用于实现移动语义和完美转发

- 不能取地址，没有名字，临时的

- 右值，就是在内存没有确定存储地址、没有变量名，表达式结束就会销毁的值

- 绑定到要求转换的表达式、字面常量、返回右值的表达式等临时对象上，赋值表达式结束后对象被销毁





### std::move()

C++11 引入的一个**标准库函数模板**，用于**将左值强制转换为右值引用**，以支持**移动语义（move semantics）**。

~~~C++
template<typename T>
typename std::remove_reference<T>::type&& move(T&& arg);
~~~

**告诉编译器：我不再需要这个对象的资源，可以把它“搬”走（即转移其内部资源的所有权）**。

本身不做任何实际的“移动”操作，只是一个**类型转换**工具。

`std::move(obj)` 把 `obj` 从**左值**转换为一个**右值引用**类型（`T&&`）。

只有当某个对象类型提供了移动构造函数，或移动赋值运算符时，`std::move`才能有实际好处。

~~~C++
#include <iostream>
#include <string>
#include <utility>

int main() {
    std::string a = "hello";
    // a --> b
    std::string b = std::move(a);  // 触发 std::string 的移动构造函数
    std::cout << "a = " << a << std::endl;  // 通常为空或处于已被“移走”的状态
    std::cout << "b = " << b << std::endl;
}
~~~

适合的典型场景包括：

- 容器插入元素（如 `std::vector::emplace_back(std::move(obj))`）；
- 返回局部对象时优化性能；
- 对象的所有权转移（如智能指针）。



在**智能指针（如 `std::unique_ptr`）中使用 `std::move`** 是其核心特性之一，用于**转移资源所有权**，这是移动语义的典型应用。

`std::unique_ptr<T>`：**独占所有权**，不能拷贝，只能移动。

`std::shared_ptr<T>`：**共享所有权**，可以拷贝，也可以移动。

对于 `unique_ptr` 来说，只有通过 `std::move` 才能把资源的所有权从一个对象转移给另一个。

~~~C++
std::unique_ptr<int> p1 = std::make_unique<int>(10);
std::unique_ptr<int> p2 = p1;            // ❌ 错误：拷贝构造被删除
std::unique_ptr<int> p3 = std::move(p1); // ✅ 正确：移动构造，p1 被清空
~~~

- `std::move(p1)` 将 `p1` 转换为一个右值引用；
- 调用 `unique_ptr` 的 **移动构造函数**，将原始资源的所有权转移到 `p3`；
- `p1` 此后变为空（`nullptr`），防止双重释放。



## 智能指针

解决问题：**内存泄露**

传统指针需要手动管理new/delete，容易出现内存泄漏（没释放），野指针（释放后继续用），重复释放等问题。

内存管理库`<memory>`，包含了用于**动态内存管理**的模版和函数，提供了**智能指针**等工具。

动态内存管理允许程序在运行时分配和释放内存。

**智能指针是 C++11 引入的特性，是一种类模板，用于自动管理动态分配的内存。**

**智能指针的作用：**RAII 原则（资源获取即初始化），**让资源的释放和对象生命周期绑定，自动释放**，避免资源泄漏。

C++11提供了三种智能指针类型来管理动态对象：**shared_ptr、weak_ptr、unique_ptr**（auto_ptr或已废弃）

| 智能指针             | 特点                                                         | 使用场景                 |
| -------------------- | ------------------------------------------------------------ | ------------------------ |
| `std::unique_ptr<T>` | 独占式拥有，不能复制，<br />同一时间**只能有一个unique_ptr指向内存** | 独享资源                 |
| `std::shared_ptr<T>` | 引用计数共享，多个指针共同管理<br />多个 `shared_ptr` **可以指向同一内存**，内存在最后一个 `shared_ptr` 被销毁时释放。 | 多个对象需要**共享**资源 |
| `std::weak_ptr<T>`   | 辅助 `shared_ptr`，不增加引用计数                            | 避免循环引用             |



### std::unique_ptr

**创建**

~~~c++
// 方式1
std::unique_ptr<T> ptr; // 表示 unique_ptr 会管理一个类型为 T 的对象

// 创建ptr，ptr会自动管理一个new创建int类型的对象，并确保在它超出作用于时自动释放该资源
std::unique_ptr<int> ptr1(new int(10)); // 不推荐：手动使用 new 创建对象


// 方式2 make_unique
auto ptr = std::make_unique<T>(args...); // 比直接使用new更加安全

// 创建一个 int 类型的 unique_ptr，管理值为10的int对象
auto ptr = std::make_unique<int>(10);   


// 当 ptr 超出作用域时，ptr 自动调用其析构函数，释放所管理的内存
~~~

`std::make_unique`

- 是一个工厂函数，创建并返回一个新的 unique_ptr 对象。
- 内部使用 `new` 来动态分配内存并返回 `unique_ptr`，确保资源的正确管理。
- 相比直接使用 `new`，`std::make_unique` 更加安全，因为它能够防止创建 `unique_ptr` 后忘记初始化、或者出现内存泄漏等问题。

**访问unique_ptr**

~~~c++
std::cout << *ptr << std::endl; // * 解引用
~~~

#### **std::move() 转移所有权**

~~~c++
// 将 ptr 的所有权转移到 ptr2，使得 ptr 变为“空”，而 ptr2 变成新的资源持有者
auto ptr2 = std::move(ptr); 
~~~

`unique_ptr` 不允许复制，因此要使用 `std::move` 来显式地转移所有权。这样可以避免资源的重复管理，确保资源只有一个所有者。

#### get()

 `get()` 是 `std::unique_ptr` 智能指针的成员函数：

~~~C++
Acceptor* get() const noexcept;
~~~

`get()` 返回 `unique_ptr` 所管理的**原始裸指针**（raw pointer），**但不释放所有权**。也就是说，它不会影响智能指针的生命周期控制。



### std::shared_ptr

**创建**

~~~c++
// 方式1
std::shared_ptr<T> ptr;

std::shared_ptr<int> ptr(new int(10));;  // 管理一个 int 类型的对象


// 方式2 make_shared
auto ptr = std::make_shared<T>(args...);

auto ptr = std::make_shared<int>(10);  // 创建一个 shared_ptr，管理一个值为 10 的 int 对象

~~~

**访问shared_ptr**

~~~c++
std::cout << *ptr << std::endl;  // 解引用访问，输出: 10
~~~

如果 `shared_ptr` 管理的是类对象，则可以通过 `->` 操作符访问类的成员函数或数据成员。例如，如果 `ptr2` 是一个指向 `std::string` 类型的 `shared_ptr`，那么 `ptr2->size()` 就是调用 `std::string` 类的 `size()` 成员函数。

~~~c++
// 管理一个 std::string 类型的对象
std::shared_ptr<std::string> ptr2 = std::make_shared<std::string>("Hello!"); 

// 通过箭头操作符访问对象的成员
std::cout << ptr2->size() << std::endl;  
~~~

**拷贝shared_ptr**

`std::shared_ptr` 可以被拷贝。当一个 `shared_ptr` 被拷贝时，它们会**共享相同的资源**，同时**引用计数会增加**。

~~~c++
std::shared_ptr<int> ptr2 = ptr1;  // 引用计数增加
~~~

**引用计数**

- 每次拷贝 `shared_ptr` 时，引用计数都会增加，表示**有多个 `shared_ptr` 指向同一个资源**。
- 当 `shared_ptr` 被销毁时，引用计数会减少，**直到引用计数为 0 时，资源才会被释放**。

~~~c++
std::cout << "use_count = " << ptr.use_count() << std::endl;  // 输出当前引用计数
~~~

`use_count()` 返回当前有多少个 `shared_ptr` 指向同一个资源。

**销毁资源**

当 `shared_ptr` 的引用计数为 0 时，它管理的资源会被自动销毁。当最后一个指向资源的 `shared_ptr` 被销毁时，它所管理的资源会被释放。

~~~c++
{
    std::shared_ptr<int> ptr1 = std::make_shared<int>(10);
    std::shared_ptr<int> ptr2 = ptr1;  // 引用计数增加
    std::cout << *ptr1 << std::endl;  // 输出: 10
}  // 当 ptr1 和 ptr2 超出作用域时，资源被自动释放

// ptr1 和 ptr2 都指向相同的 int 对象，引用计数为 2。
// 当它们超出作用域时，引用计数会减少到 0，资源会被释放。
~~~



### std::weak_ptr

`std::weak_ptr` 是 C++ 标准库中与 `std::shared_ptr` 配套使用的智能指针。它主要用于**解决循环引用**的问题。

**是shared_ptr的观察者**，和shared_ptr**指向同一个资源**，**但不“拥有”资源**，对资源没有控制权。

所以`weak_ptr` 不会增加资源的引用计数，只是观察一个由 `shared_ptr` 管理的资源。

当所有的 `shared_ptr` 都被销毁时，`weak_ptr` 会变成一个**空指针**。

**创建**

`std::weak_ptr` 不能直接创建，它必须从一个有效的 `shared_ptr` 对象构造。

~~~c++
std::shared_ptr<T> shared_ptr = std::make_shared<T>(args...);
std::weak_ptr<T> weak_ptr(shared_ptr);

std::shared_ptr<int> sp = std::make_shared<int>(10);  // 先创建 shared_ptr
std::weak_ptr<int> wp(sp);  // 用 shared_ptr 创建 weak_ptr

~~~

**循环引用**

~~~c++
// 假设两个对象A B，它们通过shared_ptr相互持有对方的引用
class A {
public:
    std::shared_ptr<B> b;
};

class B {
public:
    std::shared_ptr<A> a;
};

~~~

`A` 持有 `B` 的 `shared_ptr`，而 `B` 又持有 `A` 的 `shared_ptr`。这样会导致循环引用，因为即使没有其他地方使用 `A` 或 `B`，它们的引用计数仍然大于 0，导致无法被销毁。

**解决循环引用**

通过将其中一个 `shared_ptr` 替换为 `weak_ptr`，我们可以打破循环引用。

~~~c++
class A {
public:
    std::shared_ptr<B> b;
};

class B {
public:
    std::weak_ptr<A> a;  // 使用 weak_ptr，避免循环引用
};

~~~

这样，`B` 类通过 `weak_ptr` 观察 `A` 类的对象，但不会影响 `A` 的引用计数。`A` 的对象可以在没有 `shared_ptr` 的情况下被销毁，从而避免了内存泄漏。

**访问weak_ptr**

`std::weak_ptr` 不能直接访问资源，因为它没有引用计数，也不保证资源一直有效。

它提供了 `lock()` 方法来尝试将 `weak_ptr` 转换为 `shared_ptr`，即获取一个有效的shared_ptr。

如果对象已经被销毁，`lock()` 会返回一个空的 `shared_ptr`。

~~~c++
std::shared_ptr<T> lock() const;
// lock() 会检查 weak_ptr 指向的对象是否仍然存在。
// 如果存在，返回一个新的 shared_ptr，否则返回一个空的 shared_ptr。
~~~

示例

~~~c++
#include <iostream>
#include <memory>

int main() {
    // 创建一个 shared_ptr 管理一个整数
    std::shared_ptr<int> sp = std::make_shared<int>(10);
    // 创建一个 weak_ptr，观察 sp 所管理的资源
    std::weak_ptr<int> wp = sp;

    // 尝试通过 weak_ptr 锁定并获取 shared_ptr
    std::shared_ptr<int> sp_copy = wp.lock();  // 锁定 weak_ptr

    if (sp_copy) {
        // sp_copy非空，锁定成功，资源依然有效，访问并打印资源
        std::cout << *sp_copy << std::endl;  // 输出: 10
    } else {
        std::cout << "The resource has been destroyed." << std::endl;
    }

    return 0;
}

~~~

`wp.lock()` 尝试将 `wp` 转换为 `shared_ptr`。**如果 `wp` 指向的资源没有被销毁**（即仍然被一个或多个 `shared_ptr` 引用），**`lock()` 返回一个新的 `shared_ptr`，它指向相同的资源。**

`sp_copy` 是通过 `lock()` 返回的新的 `shared_ptr`，它会增加引用计数，确保资源在 `sp_copy` 使用期间不会被销毁。

**如果 `wp` 指向的对象已经被销毁**（即没有任何 `shared_ptr` 引用它），`lock()` **返回一个空的 `shared_ptr`**（即 `nullptr`）。



#### lock()

`lock()` 是 `std::weak_ptr` 智能指针的一个成员函数，**尝试将 `weak_ptr` 升级为一个 `shared_ptr`**，如果原对象还存在（即引用计数未归零），返回一个有效的 `shared_ptr`；否则返回一个空的 `shared_ptr`。

~~~c++
std::shared_ptr<T> weak_ptr<T>::lock() const noexcept;
~~~

对象仍然存在，返回一个指向该对象的 `shared_ptr`

对象已经被销毁（引用计数归零），返回一个**空的 `shared_ptr`**







### 智能指针能管理多个连续空间吗？⭐







## Lambda

C++11提供了对**匿名函数**的支持，称为 **Lambda 函数**（也叫 Lambda 表达式）。

Lambda表达式**把函数看做对象**。Lambda表达式可以像对象一样使用。

~~~c++
[capture](parameters)->return-type{function body}

// capture 捕获的外部变量列表，可以为空
// parameters 形参列表，可以省略，表示无参数
// return-type 返回类型，可以省略，省略时根据函数体的return语句返回类型确定，无return就返回类型void
// body 函数体

// 例如
[](int x, int y){ return x < y; }

[](int x, int y) ->int{ 
    int z = x + y; 
    return z + x
};
~~~

如果Lambda函数没有返回值（如void），其返回类型可被完全忽略。

在Lambda表达式内，`[]`可以访问当前作用域的变量，这是Lambda表达式的闭包行为。

C++变量传递有传值和传引用的区别，可以通过前面的 [ ] 来指定：

 **`[]`  不捕获外部任何变量，沒有定义任何变量。使用未定义变量会引发错误。**

~~~C++
#include <iostream>
using namespace std;

int main()
{
    int i = 1;
    auto func = [](int i) { cout << i << endl; }; // 有一个形参i
    func(i);
}
~~~

**`[=]`  捕获外部作用域所有变量的值，只读无法修改**
任何被使用到的外部变量，都隐式地以传值方式加以引用

~~~C++
#include <iostream>
using namespace std;

int main()
{
    int i = 1;
    auto func = [=]() { cout << i << endl; }; // 没有形参，而且直接捕获的i的值
    func();
}
~~~

**[&] 捕获外部作用域所有变量的引用，引用捕获，可修改捕获的变量**
任何被使用到的外部变量都隐式地以引用方式加以引用

~~~C++
#include <iostream>
using namespace std;

int main()
{
    int i = 1;
    auto func = [&]() { // 没有形参，而且直接捕获的i的引用
		cout << "修改前，i = " << i << endl;
		i++;
	};
    func();
	cout << "修改后，i = " << i << endl;
}

// 输出
修改前，i = 1
修改后，i = 2
~~~

**[var] 只捕获外部变量var的值，只读无法修改**

**[&var] 只捕获外部变量var的引用，可修改**

**[=, &] 混合方式**

~~~C++
#include <iostream>
using namespace std;

int main()
{
    int i = 1;
	int j = 2;
    
	// [&, =j]() { // 变量j值方式捕获，其余变量捕获引用
    
    auto func = [=, &i]() { // 变量i引用方式捕获，其余变量值方式捕获
		cout << "j = " << j << endl;
		i++;
	};
    func();
	cout << "i = " << i << endl;
}

~~~




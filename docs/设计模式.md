# 设计模式

> 参考：https://github.com/youngyangyang04/kama-DesignPattern

## 什么是设计模式

设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。

设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。

使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 



## 设计模式的类型

根据设计模式的参考书 **Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）** 中所提到的，总共有 23 种设计模式。

这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。

创造型：单例、工厂、建造者、原型

结构型：适配器、代理、桥接、外观、组合、装饰、享元、

行为型：观察者、策略、命令、中介者、备忘录、模板方法、迭代器、状态、责任链、解释器、访问者



## 设计模式的六大原则

**1、开闭原则（Open Close Principle）**

开闭原则的意思是：**对扩展开放，对修改关闭**。

在程序需要进行拓展的时候，不能去修改原有的代码，实现一个**热插拔**的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。

**2、里氏代换原则（Liskov Substitution Principle）**

里氏代换原则是面向对象设计的基本原则之一。 

里氏代换原则中说，**任何基类可以出现的地方，子类一定可以出现。**

LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。

**3、依赖倒转原则（Dependence Inversion Principle）**

这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

**4、接口隔离原则（Interface Segregation Principle）**

使用多个隔离的接口，比使用单个接口要好。

它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

**5、迪米特法则，又称最少知道原则（Demeter Principle）**

指一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

**6、合成复用原则（Composite Reuse Principle）**

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。





# 单例模式

## 核心思想

属于创建型模式，核心思想：**保证一个类仅有一个实例，提供一个访问它的全局访问点**

> 只有一个实例的意思是，在整个应用程序中，只存在该类的一个实例对象，而不是创建多个相同类型的对象。
>
> 全局访问点，是为了让其他类能获取到这个唯一实例，通常是一个静态方法

注意：

- 单例类只能有一个实例
- 单例类必须**自己创建自己**的唯一实例
- 单例类必须给所有其他对象提供这一实例

主要针对的情况：

- 频繁创建和销毁全局使用的类实例的问题
- 需要控制实例数目，节省系统资源时，可以使用

应用实例：

- 设备管理器为单例模式，例如电脑有两台打印机，避免同时打印同一个文件
- Windows 在多进程多线程环境下操作文件时，避免多个进程或线程同时操作一个文件，需要通过唯一实例进行处理。

## 实现

> 关键代码：**构造函数是私有的**

**主要角色：**

- 单例类
  - **私有构造函数**：防止外部代码创建单例类的其他实例
  - 静态成员变量
  - 公有静态方法：通过公有静态方法来获取这一实例
- 线程安全处理



<img src="pic/image-20250804170225659.png" alt="image-20250804170225659" style="zoom:50%;" />



**实现方式：**

- **懒汉式**——只有在请求实例时，才创建这个实例（请求时已经创建了，就返回已有实例）
- **饿汉式**——在类加载时，就已经完成了实例的创建（不管后面有没有使用，先创建再说）



**例题**：[1 小明的购物车](https://kamacoder.com/problempage.php?pid=1074)

~~~C++
#include <iostream>
#include <map>
using namespace std;

class ShoppingCartManager
{
public:
    // 获取购物车实例 - 获取唯一实例的公有静态方法 ✅
    static ShoppingCartManager& getInstance()
    {
        static ShoppingCartManager instance;
        return instance;
    }

    // 添加商品到购物车
    void addToCart(const string& itemName, int quantity)
    {
        cart[itemName] += quantity;
    }
    // 查看购物车
    void viewCart() const {
        for (const auto& item : cart)
        {
            cout << item.first << " " << item.second << endl;
        }
    }


private:
    // 私有构造函数 ✅
    ShoppingCartManager() {}

    map<string, int> cart; // <车里存储商品，商品数量>
};




int main()
{
    string itemName;
    int quantity = 0;

    while (cin >> itemName >> quantity)
    {
        // 获取唯一实例
        ShoppingCartManager& cart = ShoppingCartManager::getInstance(); 
        cart.addToCart(itemName, quantity); // 添加
    }

    const ShoppingCartManager& cart = ShoppingCartManager::getInstance();
    cart.viewCart(); // 输出购物车内容

    return 0;
}
~~~













## 优缺点

优点：

- 全局控制，只有一个实例，就可以严格控制客户怎样访问它，以及何时访问它
- 节省资源，避免多次创建相同的对象，多个模块还可以通过这一个实例共享数据
- 懒加载：只有在需要时才进行实例化，提高程序的性能

缺点：

- 没有接口，不能继承
- 与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心实例化方法







# 工厂模式

## 工厂模式的类型

**1、简单工厂模式（Simple Factory Pattern）**：

- 简单工厂模式不是一个正式的设计模式，但它是工厂模式的基础。
- 它使用一个**单独的工厂类**来创建不同的对象，根据传入的参数决定创建哪种类型的对象。

**2、工厂方法模式（Factory Method Pattern）**：

- 工厂方法模式定义了一个创建对象的接口，但**由子类决定实例化哪个类**。工厂方法将对象的创建延迟到子类。

**3、抽象工厂模式（Abstract Factory Pattern）**：

- 提供一个**创建一系列相关或互相依赖对象的接口**，而无需指定它们具体的类。

> **简单工厂模式**（不是一个正式的设计模式，只是一种习惯，是工厂模式的基础）
>
> 核心思想：将产品的创建过程封装在一个工厂类中，把创建对象的流程集中在这个工厂类里
>
> - 主要用于创建对象
>
> - **用一个工厂来根据输入的条件产生不同的类**
>
> - 根据不同类的虚函数得到不同的结果
>
>
> 三个主要角色：
>
> - 工厂类
> - 抽象产品 —— 描述产品的通用行为
> - 具体产品 —— 实现抽闲产品接口，或继承抽象产品类，通过类里的if-else来实例化
>
> ![image-20250804173638316](pic/image-20250804173638316.png)
>
> 简单工厂模式只有一个工厂类，负责创建所有产品，如果要添加新的产品，通常需要修改工厂类的代码。

## 核心思想

**定义一个创建对象的接口，让其子类决定实例化哪一个具体的类。**工厂模式使对象的创建过程延迟到子类。

工厂方法模式也是一种创建型设计模式，提供了一种创建对象的方式，**无需指定要创建的具体类**，使得创建对象的过程与使用对象的过程分离。



**主要角色：**

- 抽象产品：定义产品的接口 
- 具体产品：实现了抽象产品接口，定义了具体产品的特定行为和属性

- 抽象工厂：声明创建产品的抽象方法

- 具体工厂：实现抽象工厂接口，创建具体的产品

  

![image-20250804174955456](pic/image-20250804174955456.png)



**例题**：[2 积木工厂](https://kamacoder.com/problempage.php?pid=1076)

~~~C++
#include <iostream>
#include <vector>
 

// 抽象积木接口 —— 抽象产品(产品表现，积木的行为和属性)
class Block {
public:
    virtual void produce() = 0;
};
 
// 具体圆形积木实现 —— 具体产品
class CircleBlock : public Block {
public:
    void produce() override {
        std::cout << "Circle Block" << std::endl;
    }
};
 
// 具体方形积木实现 —— 具体产品
class SquareBlock : public Block {
public:
    void produce() override {
        std::cout << "Square Block" << std::endl;
    }
};
 


// 抽象积木工厂接口 —— 抽象工厂(创建刚才定义过的产品)
class BlockFactory {
public:
    virtual Block* createBlock() = 0;
};
 
// 具体圆形积木工厂实现 —— 具体工厂
class CircleBlockFactory : public BlockFactory {
public:
    Block* createBlock() override {
        return new CircleBlock();
    }
};
 
// 具体方形积木工厂实现 —— 具体工厂
class SquareBlockFactory : public BlockFactory {
public:
    Block* createBlock() override {
        return new SquareBlock();
    }
};
 


// 积木工厂系统
class BlockFactorySystem {
private:
    std::vector<Block*> blocks;
 
public:
    void produceBlocks(BlockFactory* factory, int quantity) 
    {
        for (int i = 0; i < quantity; i++) { 
            Block* block = factory->createBlock(); // 创建积木
            blocks.push_back(block);
            block->produce();
        }
    }
 
    const std::vector<Block*>& getBlocks() const {
        return blocks;
    }
 
    ~BlockFactorySystem() {
        // 释放所有动态分配的积木对象
        for (Block* block : blocks) {
            delete block;
        }
    }
};
 

int main() {
    // 创建积木工厂系统
    BlockFactorySystem factorySystem;
 
    // 读取生产次数
    int productionCount;
    std::cin >> productionCount;
 
    // 读取每次生产的积木类型和数量
    for (int i = 0; i < productionCount; i++) {
        std::string blockType;
        int quantity;
        std::cin >> blockType >> quantity;
 		
        // 根据 输入的积木形状，选择具体的积木创建
        if (blockType == "Circle") {
            factorySystem.produceBlocks(new CircleBlockFactory(), quantity);
        } 
        else if (blockType == "Square") {
            factorySystem.produceBlocks(new SquareBlockFactory(), quantity);
        }
    }
 
    return 0;
}
~~~























观察者模式

- 定义一种一对多的关系
- 让多个观察对象同时监听一个主题对象
- 主题对象发生变化时，会通知所有观察者，使他们能更新自己





装饰模式

- 动态给对象添加一些额外的职责

- 就增加功能来说，装饰模式比生成派生类更为灵活
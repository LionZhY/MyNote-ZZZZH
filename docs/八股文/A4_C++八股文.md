

# 基础✅

## const

> 被const修饰的值不能改变，只读，必须在定义的时候就给它赋初值

### const 修饰

* **修饰变量**，说明变量不能被改变

* **修饰指针**，
  
  > 这两个名称网上说的会不一致，记内容就好，不要纠结名称
  
  * **<span style="color:#CC0000;">const 在星号左侧 —— 被指物是常量</span>**（指针常量）：指向的值不能变（底层）
    
    ~~~c++
    int a = 10;
    const int * p1 = &a; // 指向的值不能改，即a=10不能变         // 强调对象不能变
    int const * p1 = &a; // 也可以这么写
    ~~~
    
  * **<span style="color:#CC0000;">const 在星号右侧 —— 指针自身是常量</span>**（常量指针）：指针指向不能改（顶层）
    
    ~~~c++
    int a = 10;
    int * const p2 = &a; // 指向不能改变，只能指向a，但是a的值可以改  // 强调指针不能改
    ~~~
  
* **修饰引用**
  
  * <span style="color:#CC0000;">引用的值是常量</span>，用于形参类型，避免拷贝，避免函数对值的修改
  * `const int& ref = constantValue`
  
* **修饰成员函数（常函数）**
  
  * 常函数，不可修改对象的成员属性
  * 成员属性声明时加 `mutable` 后，常函数中依然可以修改
  
* **修饰对象（常对象）**
  
  * 常对象，对象前加const，对象的成员变量不会被修改
  * 属性值加mutable，在常对象中可修改
  * 常对象只能调用常函数
  
* **函数参数**
  
  * **为常量引用**：表示函数不会修改传入的参数
  * **为指向常量的指针**：表示函数不会通过指针修改传入的数据
  



### 成员函数前后的const

示例：

~~~C++
class Person {
private:
    std::string name;
public:
    const std::string& getName() const { return name; }  // 返回 const 引用
};
~~~

第一个`const`：

- 表示**返回的是一个 常量值**，不能被修改；
- 仅适用于返回值为引用或指针时才有效果，否则没意义（值拷贝本身不可改）。

第二个`const`

- `const`修饰成员函数，**不会修改类中的任何成员变量**（除非这些成员变量被声明为 `mutable`）。
- 只能调用其他 `const` 成员函数。可以被 `const` 类型的对象调用。





## **static**

> 控制变量和函数的声明周期、作用域、访问权限  ——> **静态**
>
> 不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在**该文件所在的编译模块中使用**
>
> 默认初始化为0

### static修饰变量函数

* **修饰普通变量**：
  * 在<span style="color:#0000FF;">函数内部修饰的变量</span> `static int count = 0`，在程序<span style="color:#0000FF;">整个生命周期内存在</span>，不会因为离开作用域而被销毁
  * 默认初始化为0
* **修饰普通函数**
  * 仅在<span style="color:#0000FF;">定义该函数的文件内才能使用</span>
  * 在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static
* **静态成员变量**
  * 所有类的对象，**<span style="color:#0000FF;">共享</span>**同一个静态成员变量的副本，该<span style="color:#0000FF;">变量为所有对象所有</span>
  * **类内声明，必须在类外部单独定义**，以便为其分配存储空间，static修饰的变量先于对象存在
  * 函数体内static变量的作用范围为该函数体，<span style="color:#0000FF;">该变量内存只被分配一次</span>，因此其值在下次调用时仍维持上次的值
  * 可以被非static成员函数任意访问
  * 模块内static全局变量，可以被模块内所有函数访问，不能被模块外其他函数访问
* **静态成员函数**
  * **<span style="color:#0000FF;">属于类</span>**，而不属于类的对象，**可以通过类名直接调用**，无需创建对象
  * 所以静态成员函数**<span style="color:#CC0000;">没有this指针</span>**（this指针是指向本对象的指针），只能访问static类成员
    * ➡️不能被virtual修饰（不能作为虚函数，因为没有this指针）
  * **不能被声明为const、虚函数、volatile**
  * 不能直接访问非静态； 但可以被非静态成员函数任意访问
  * 模块内static函数，只能被这一模块的其他函数调用，使用范围只在声明它的模块内



### static 分配内存空间的时机⭐

- **程序开始<span style="color:#0000FF;">运行前</span>**，数据段中被分配内存

- 在程序的**静态存储区域**（数据段）中被分配内存

- 声明周期始于启动，直到程序结束

静态成员变量**类内声明，类外部单独定义**，以便为其分配存储空间，**<span style="color:#0000FF;">static修饰的变量先于对象存在</span>**





### A.c 和B.c两个c文件中使用了两个相同名字的static变量，编译的时候会不会有问题?⭐

> 两个文件，同一个变量，加static，编译会不会报错？

- 不会有问题
- 在头文件中定义static，然后这个头文件被不同的文件引用。
- **static的作用域是定义它的源文件中**，这样的方式，会**在每个引用它的文件中都生成一个本地的static 变量**。
- static的全局变量说明这个变量只在本模块有意义，不会影响其他模块
- static 变量是静态变量，和全局变量一样，都存放在静态存储区，编译器在编译的时候，对他们的命名是不同的。因此，存放的位置也不同
- 这时，在头文件中定义的static变量，在不同的文件中引用，就是不同的静态变量。



## inline

### inline 内联函数

~~~c++
// 声明1（加 inline，建议使用）
inline int funName(int first, int second,...);

// 声明2（不加 inline）
int funName(int first, int second,...);
// 定义
inline int funName(int first, int second,...) {/****/};


// 类内定义，隐式内联
class A {
    int doA() { return 0; }         // 隐式内联
}

// 类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联
~~~

**特征**

- inline**建议**编译器调用函数编译时，把内联函数的代码副本直接**放在每个调用该函数的地方。**
- 不用执行进入函数的步骤**，**直接执行函数体。
- 通常与类一起使用，**类内定义的成员函数都是内联函数**（不需要显式使用inline关键字，类外定义需要）
- 内联函数声明必须在调用语句之前

**inline适用于什么函数**

- 频繁调用的、短小简单的函数，不能包含递归、循环、Switch等复杂条件

**编译器对inline函数的处理步骤**

1. 将inline函数体，复制到inline函数的调用点处
2. 为所用inline函数中的局部变量分配内存空间
3. 将inline函数的输入参数和返回值，映射到调用方法的局部变量空间中
4. 如果inline函数有多个返回点，将其转变为inline函数代码块末尾的分支（使用GOTO）

**优点**

- 减少函数调用的开销（在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等）

**缺点**

- 需要更多内存，10个地方调用同一个内联函数，就需要10个副本，过渡使用会导致代码膨胀，增加可执行文件的大小，降低缓存效率
- 编译时间增加，在头文件中定义inline函数，每次包含头文件时，都会重新编译函数体
- 调试困难，函数体被插入到调用处，不方便调试时查看函数的具体执行
- 链接，如果一个inline函数在多个编译单元中都被使用，会引发多重定义的问题



### 类内定义函数自动当做inline

类内定义的成员函数，被自动当做inline函数（建议，不是强制）

为什么适合放在 `.h` 文件中？

- 函数很短（1 行）；没有逻辑复杂度；

- 频繁调用（如 `tid()`、`name()`、`started()`）；

- 放在头文件中也不会增加太多编译开销；

- 有利于性能优化（inline 展开）



## #define宏

> 预处理器是一些指令，指示编译器在**实际编译之前**所需完成的预处理。
>
> 所有的预处理器指令都是以井号（#）开头，预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。
>
> 预处理指令包括比如 #include、#define、#if、#else、#line 等。

#define 用于创建**符号常量**，该符号常量称为**宏**。

是预处理指令，在**预编译时**处理宏

只是简单的**字符串替换**，无类型检查，不安全

~~~c++
#define macro-name replacement-text 
// 在该文件中后续出现的所有宏（macro-name），都会在编译之前被替换为replacement-text
~~~

**参数宏**

~~~c++
#include <iostream>
using namespace std;

// 带有参数的宏 MIN()
#define MIN(a,b) (a<b ? a : b)
 
int main ()
{
   int i, j;
   i = 100;
   j = 30;
   cout <<"较小的值为：" << MIN(i, j) << endl; // 输出30
   // MIN(i,j)被预处理器展开为：(i < j ? i : j)

   return 0;
}
~~~

在 C/C++ 预处理器中，**宏定义默认只能写在一行内**。**如果有多行，每行结尾要加 “ \\"**

~~~c++
#define LOG_INFO(logmsgFormat, ...) \
    do { \
        Logger &logger = Logger::instance(); \
        logger.setLogLevel(INFO); \
        char buf[1024] = {0}; \
        snprintf(buf, 1024, logmsgFormat, ##__VA_ARGS__); \
        logger.log(buf); \
    } while(0)

~~~

如果不加 `\`，编译器会**把换行当作宏定义的结束**，导致编译错误。

~~~c++
#define LOG_INFO(logmsgFormat, ...)  // 这里的宏在换行后就结束了
do { 
    Logger &logger = Logger::instance();  // 这里的代码不会被认为是宏的一部分
    logger.setLogLevel(INFO);
    char buf[1024] = {0};
    snprintf(buf, 1024, logmsgFormat, ##__VA_ARGS__);
    logger.log(buf);
} while(0)
~~~





### do{}while(0) 封装宏

常见的宏封装技巧，保证宏的代码块在调用时，不会因为分号或换行导致语法错误

~~~c++
#define LOG_INFO(logmsgFormat, ...) \
    do \
    { \
        Logger &logger = Logger::instance(); /*获取单例Logger实例*/ \
        logger.setLogLevel(INFO); /*设置当前日志级别*/ \
        char buf[1024] = {0}; \
        snprintf(buf, 1024, logmsgFormat, ##__VA_ARGS__); \
        logger.log(buf);  /*将格式化后的日志内容写入日志系统*/ \
    } while(0) 
// do {}while(0) 是常见的宏封装技巧，保证宏的代码块在调用时，不会因为分号或换行导致语法错误
~~~





### define和typedef的区别

**define：**

- 只是简单的字符串替换，没有类型检查
- 在编译的预处理阶段起作用
- 可以用来防止头文件重复引用
- 不分配内存，给出的是立即数，有多少次使用就进行多少次替换

**typedef：**

~~~c++
typedef 现有类型 新类型名;

typedef unsigned int uint;
uint a = 10;  // 等价于 unsigned int a = 10;
~~~

- 有对应的数据类型，要进行判断
- 在编译、运行的时候起作用
- 在静态存储区分配空间，在程序运行过程中，内存中只有一个拷贝

宏定义主要用于定义常量及书写复杂的内容，typedef主要用于定义类型别名。

宏不是语句，不用加分号；typedef是语句，需要加分号





### const和define的区别

const用于定义常量，define用于定义宏，而宏也可以用于定义常量

都用于定义常量时，区别：

- const生效于编译的阶段；define生效与预处理阶段
- const定义的常量，存储在内存中，需要额外的内存空间；define定义的常量，运行时是直接的操作数，不会放在内存中
- const定义的常量是带类型的，有类型检查；define定义的常量不带类型，没有类型检查

------



### define宏函数和普通函数

**编译过程上不同**

- 宏定义函数，**预编译时**会将这些宏定义函数**按展开的规则直接展开成语句**，并且宏定义函数在代码中书写多少次，便**展开多少次**，拷贝相应的代码插入，生成相应的指令
- 而对于普通函数而言其**只会生成一份相应的指令**，调用处会生成传参指令和调用指令实现对函数的调用。

**执行过程上不同**

- 宏定义式函数所有的语句都是**普通语句执行**
- 普通函数由于需要调用的缘故，需要进行**开辟栈空间、压栈、出栈等操作**。

------



### define宏函数和inline内联函数

**相同点**

- 都会在代码书写处，**直接拷贝一份指令**，不会像普通函数一样单独生产指令然后调用

**define：**

- 定义预编译时处理的宏，**预编译时展开**
- 只是简单的字符串替换（编译前），无类型检查，不安全
- 不能调试

**inline：**

- 先将内联函数编译完成，是在**编译阶段展开到生成指令中的**，而不是预编译阶段展开到代码中
- 什么时候调用内联函数，就会将展开后的指令插入进去
- 内联函数是一种特殊的函数，会进行类型检查（编译时）
- 可以使用调试器调试

**宏不可调试**，内联机制既具备宏代码的效率，又增加了安全性，而且可以自由操作的类的数据成员，所以**应该尽量使用内联函数来取代宏代码。**





## assert 断言

> 断言，是宏，而非函数

assert 宏的原型定义在 `<assert.h>`（C）、`<cassert>`（C++）中，其作用是**如果它的条件返回错误，则终止程序执行**。

~~~c++
#include <stdio.h>
#include <assert.h>

int main()
{
  int x = 7;

  /*  中间的一些大代码假设x意外地变成了9 */
  x = 9;

  // 程序员假设x在其余代码中为7
  assert(x == 7); // `x == 7' failed

  /* 其余代码 */
  return 0;
}
~~~

可以通过定义 `NDEBUG` 来关闭 assert，但是需要在源代码的开头，`include <assert.h>` 之前。

~~~c++
#define NDEBUG          // 加上这行，则 assert 不可用
#include <assert.h>

assert( p != NULL );    // assert 不可用
~~~





## volatile ❓

~~~c++
for(volatile int i=0; i<100000; i++); // 空循环，会执行，不会被优化掉
~~~

提醒编译器使用`volatile`声明的变量**随时有可能改变**，因此**编译器对访问该变量的代码不再进行优化。**

可以提供对特殊地址的稳定访问，编译生成的程序在每次存储或读取该变量时，都会**直接从内存中读取**，而不是直接从寄存器拷贝内容。

**用在哪？**

- 中断服务程序中，修改的供其他程序检测的变量，需要加volatile
- 多任务环境下，各任务之间共享的标志，应该加volatile
- 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义



## enum枚举 

**枚举类型**(enumeration)是 C++ 中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。

~~~c++
enum <类型名> {<枚举常量表>};
~~~

**"枚举常量"**或称"枚举成员"，是以标识符形式表示的整型量，表示该**枚举类型变量可能的取值**。

各枚举常量之间以"，"间隔，且必须各不相同。取值类型与条件表达式相同。

~~~c++
enum color_set1 {RED, BLUE, WHITE, BLACK}; // 定义枚举类型color_set1
enum week {Sun, Mon, Tue, Wed, Thu, Fri, Sat}; // 定义枚举类型week
~~~

编译系统**为每个枚举常量指定一个整数值**，默认状态下，这个数就是**所列举元素的编号**，**序号从0开始**。

可以在定义枚举类型时为部分或全部枚举常量**指定整数值**，在指定值之前的枚举常量仍按默认方式取值，指定值之后的枚举常量按依次加1的原则取值。

各枚举常量的值可以重复。

~~~c++
enum fruit_set {apple, orange, banana = 1, peach, grape};
// apple = 0, orange = 1, banana = 1, peach = 2, grape = 3
~~~

枚举常量智能以**标识符形式**表示，不能是整型、字符型等文字常量。

~~~c++
enum letter_set {'a','d','F','s','T'}; // 错误，枚举常量不能是字符常量
enum year_set{2000,2001,2002,2003,2004,2005}; // 错误，枚举常量不能是整型常量

// 可改为
enum letter_set {a, d, F, s, T};
enum year_set{y2000, y2001, y2002, y2003, y2004, y2005};
~~~



**枚举类型的使用**

定义枚举类型的目的是为了增加程序的可读性。

定义格式：定义枚举类型之后，就可以定义**该枚举类型的变量**

~~~c++
color_set1 color1, color2;
~~~

也可类型与变量同时定义（甚至类型名可省）

~~~c++
enum {Sun, Mon, Tue, Wed, Thu, Fri, Sat} weekday1, weekday2;
~~~

枚举变量的值，只能取枚举常量表中所列的值，就是整型数的一个子集。

枚举变量占用内存的大小与整型数相同。

枚举变量只能参与**赋值、关系运算、输出操作**，参与运算时**用其本身的整数值**。

~~~c++
enum color_set1 {RED, BLUE, WHITE, BLACK} color1, color2;
enum color_set2 { GREEN, RED, YELLOW, WHITE} color3, color4;

// 允许的赋值操作
color3 = RED;	// 将枚举常量赋给枚举变量
color4 = color3;// 相同类型的枚举变量赋值，color4的值为RED
int i = color3; // 将枚举变量赋给整型变量，i的值为1
int j = GREEN;  // 将枚举常量赋给整型变量，j的值为0

// 允许的关系运算 == < > <= >= != 等
if (color3 == color4) cout << "相等"; // 比较同类型枚举变量
cout << color3 < WHITE;// 比较变量color3和WHITE，结果为1
~~~

**枚举变量可以直接输出，输出的是变量的整数值。**

~~~c++
cout << color3; // 输出的是color3的整数值，即RED的整数值 1
~~~

**注意：**

- 枚举变量可以直接输出，但不能直接输入
- 不能直接将常量赋给枚举变量，例如 `color1 = 1`，非法
- 不同类型的枚举变量之间不能相互赋值
- 枚举变量的输入输出一般都采用Switch语句，将其转换为字符或字符串；枚举类型数据的其他处理也往往应用Switch语句，以保证程序的合法性和可读性





## explicit 禁止隐式转换

**禁止隐式转换**

explicit（显式的）的作用是"禁止单参数构造函数"被用于自动型别转换，其中比较典型的例子就是容器类型。

在这种类型的构造函数中你可以将初始长度作为参数传递给构造函数。

就是**不允许用 `=` 的方式来初始化对象**（防止“偷偷地”类型转换）。

**没有explicit，编译器会帮你转类型；有了explicit，就必须自己转**

~~~c++
class A {
public:
    A(int x) { std::cout << x << std::endl; } // 没加expicit
};

void func(A a) {} // 需要一个A类型的参数

int main() {
    func(10);  // ✅ 合法，10 会被自动转换为 A(10)，编译器自动转的，把int的10转为A(10)
}


class A {
public:
    explicit A(int x) { std::cout << x << std::endl; } // 加了expicit
};

void func(A a) {} // 需要一个A类型的参数

int main() {
    // func(10);  // // ❌ 错误：explicit 禁止了 int -> A 的隐式转换

    func(A(10));  // ✅ 正确：显式创建对象
}

~~~







## namespace

> namespace命名空间，是C++用来**防止名字冲突**的机制。

namespace 作为附加信息来**区分不同库中相同名称的函数、类、变量等**。使用了命名空间即定义了上下文。

本质上，命名空间就是**定义了一个范围**。（相当于不同文件夹里，可以有同名的文件，用的时候要指明是哪个文件夹里的文件）

**定义命名空间**

~~~c++
namespace namespace_name {
   // 代码声明
}
~~~

**调用带有命名空间的函数或变量，需要在前面加上命名空间的名称**

~~~c++
name::code;  // code 可以是变量或函数
~~~

示例

~~~c++
#include <iostream>
using namespace std;
 
// 第一个命名空间
namespace first_space{
   void func(){
      cout << "Inside first_space" << endl;
   }
}
// 第二个命名空间
namespace second_space{
   void func(){
      cout << "Inside second_space" << endl;
   }
}
int main ()
{
   // 调用第一个命名空间中的函数，输出Inside first_space
   first_space::func(); 
   // 调用第二个命名空间中的函数，输出Inside second_space
   second_space::func(); 
 
   return 0;
}
~~~

**using namespace指令**

> 可以使用 using namespace 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。
>
> 这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。
>

~~~c++
#include <iostream>
using namespace std;
 
// 第一个命名空间
namespace first_space{
   void func(){
      cout << "Inside first_space" << endl;
   }
}
// 第二个命名空间
namespace second_space{
   void func(){
      cout << "Inside second_space" << endl;
   }
}
using namespace first_space; // 后面的func()使用第一个命名空间里的
int main ()
{
   // 调用第一个命名空间中的函数
   func();

   return 0;
}
~~~





## extern

**外部声明，表示定义在别处。**这里只是声明，不分配内存。

extern（外部的）声明变量或函数为**外部链接**，即该变量或函数名在其它文件中可见。

被其修饰的变量（外部变量）是**静态分配空间**的，即**程序开始时分配，结束时释放**。

用其声明的变量或函数应该**在别的文件或同一文件的其它地方定义（实现）**。在文件内声明一个变量或函数默认为可被外部使用。

在 C++ 中，还可用来指定使用另一语言进行链接，这时需要与特定的转换符一起使用。目前仅支持 **C** 转换标记，来支持 C 编译器链接。使用这种情况有两种形式：

~~~c++
extern "C" 声明语句

extern "C" { 声明语句块 }
~~~



### 在C++中调用C函数怎么做？在C中调用C++又应该怎么做？⭐

C 中调用 C++

- 先在C++代码函数前，加上extern “C”

- 然后C代码中不要include C++的头文件, 而采用直接在C中增加函数声明的方式;

C++调用C 

- 在include的时候, 要采用extern “C” 代码块形式

- 对调用的C代码进行extern “C”



## final 关键字









## volatile final关键字









## 指针和引用

> 指针和应用都是一种**内存地址**的概念，**指针是一个实体，引用是一个别名**

### **指针**（地址）

~~~c++
int a = 10;
int *p; // 声明指针变量p
p = &a; // p指向a，p存放的就是a的地址, &a表示a的地址
		// *p = 10，*是解引用，*p就是通过p里存的地址找到a
~~~

- 存放某个对象的地址，**指针就是内存地址**，指针变量就是用来存放地址的变量

- 指针大小是固定的：32位平台上是4个字节，64位平台上是8个字节（和编译环境有关，和机器的位数无关）
- 指针本身就是变量，所以可以有指向指针的指针（二级指针）
- 可变化，所指向的地址，和地址中存放的数据都可变



### 指针常量和常量指针

> 这两个名称网上说的会不一致，记内容就好

* **const 在星号左侧 —— 被指物是常量**（指针常量）：指向的值不能变（底层）

  ~~~c++
  int a = 10;
  const int * p1 = &a; // 指向的值不能改，即a=10不能变         // 强调对象不能变
  int const *p1 = &a;// 也可以这么写
  ~~~
  
* **const 在星号右侧 —— 指针自身是常量**（常量指针）：指针指向不能改（顶层）

  ~~~c++
  int a = 10;
  int* const p2 = &a; // 指向不能改变，只能指向a，但是a的值可以改  // 强调指针不能改
  ~~~





### 引用（别名）

~~~c++
int a = 10;
int &ref = a;// ref是一个初始化为a的整型引用，且只能一直是a的别名，ref=10
~~~

- 引用是某个已存在变量的别名，可以用这个别名来指向原来的变量；别名可以和原名一样
- **引用必须初始化**，一旦初始化就**不可以发生改变**，本质上是一个指针常量（指向不能改变）
- 常量引用：函数形参列表中，加const修饰形参，防止形参改变实参



### 指针和引用的区别?

- 指针是变量，存放地址； 引用只是别名，是同一块内存的别名
- 指针内容可变； 引用不可变
- 指针可以指向空； 引用必须初始化，没有空引用
- sizeof (指针)，得到指针本身大小；sizeof (引用)，得到所引用对象的大小
- 指针自增，指向下一个内存单元；引用自增，改变引用对象的值
- 指针通常用于动态内存分配，数组操作，函数传参； 引用通常用于函数传参，操作符重载，创建别名





### 为什么指针指向能改，引用不能改？

程序在编译时，分别将<span style="color:#0000FF;">指针和引用添加到符号表上</span>，符号表中记录的是<span style="color:#0000FF;">变量名</span>和<span style="color:#0000FF;">变量所对应的地址</span>。

**指针变量**，在符号表上对应的地址值为**指针变量的地址值**；

**引用**，在符号表上对应的地址值为**引用对象的地址值**（即实参的地址）

符号表生成后不会再改，所以指针可以改变指向的对象，而引用不能改。





### 传值、传指针、传引用、传常量引用

![image-20250328221412456](C:\Users\h\AppData\Roaming\Typora\typora-user-images\image-20250328221412456.png)

- **传值** `(int x)`

  - 只是把实参（a）的数值传进去进行计算
  - **值传递：**形参作为被调函数的局部变量，在栈中开辟内存，**存放传进来的实参值**，形成一个**<span style="color:#0000FF;">实参的副本</span>**
  - 函数内部修改形参，是<span style="color:#0000FF;">在修改实参的副本</span>，**不会影响原始实参**

  ~~~c++
  #include <iostream>
  
  void func(int x) {  // 形参 x 是实参 a 的拷贝
      x = 100;  // 修改 x，不影响 a
  }
  
  int main() {
      int a = 10;
      func(a);  // 传递 a 的值
      std::cout << a << std::endl;  // 仍然输出 10
  }
  ~~~

- **传指针** `(int* x)`

  - 传指针，就是**传变量a的地址**，形参 p 存储a的地址
  - <span style="color:#0000FF;">修改 *p 就是在修改 a 的值</span>

  ~~~c++
  #include <iostream>
  
  void func(int *p) {  // p 是指向 a 的指针，存储a的地址
      *p = 100;  // 通过指针修改 a，*p访问p指向的地址（即a的地址），改变a的值
  }
  
  int main() {
      int a = 10;
      func(&a);  // 将a 的地址 &a，传给指针形参p
      std::cout << a << std::endl;  // 输出 100
  }
  ~~~

- **传引用 **`(int& x)`

  - 传指针的升级版，底层看传进来的也是**a的地址 &a**，x是a的**别名**，<span style="color:#0000FF;">不是拷贝，**x和a指向同一块内存**</span>
  - 直接用x操作就可以，**<span style="color:#0000FF;">操作x就是操作a</span>**
  - 传引用不会额外占用指针存储地址的空间，而传指针需要存储地址值。
  - **为什么不直接用指针找地址再操作呢？**因为有可能在函数里<span style="color:#0000FF;">指针可能不小心被改变指向</span>，这样就找不到原来的地址了，但是引用是直接用别名指向的同一块内存，引用是固定的

  ~~~c++
  #include <iostream>
  
  void func(int &x) {  // x 是 a 的引用，直接操作 a
      x = 100;  // 修改 x，相当于修改 a
  }
  
  int main() {
      int a = 10;
      func(a);  // 传递 a，但实际上传递的是 &a
      std::cout << a << std::endl;  // 输出 100
  }
  ~~~

- **传常量引用** `(const int& x)`

  - 避免了传值带来的性能开销，同时保证**实参不会被修改**

  ~~~c++
  #include <iostream>
  
  void func(const int &x) {  // x 是 a 的常量引用
      x = 20;  // 直接编译错误，不能修改常量引用
  }
  
  int main() {
      int a = 10;
      func(a);  // 传递 a，但实际上传递的是 &a
      std::cout << a << std::endl;  // a = 10 不会被改变
  }
  ~~~

  

**传指针和传引用对比**

![image-20250328222332190](C:\Users\h\AppData\Roaming\Typora\typora-user-images\image-20250328222332190.png)





## new、delete和malloc、free

> 都用于内存的动态申请和释放

### new

- 实际执行两个过程：
  - ① 分配未初始化的内存空间**（malloc）**
  - ② 使用对象的构造函数，对空间进行初始化，返回空间的首地址
- 异常
  - 第一步内存分配失败，会抛出std::bad_alloc异常
  - 第二步构造对象异常，会自动调用delete释放内存

### delete

- 两个过程：
  - ① 使用析构函数对对象进行析构
  - ② 回收内存空间**（free）**



### new和malloc的区别

> new是new一个类型，malloc是malloc一个字节长度的空间；
>
> delete是delete一个类型，free是free一个字节长度的空间

**相同点**：都可以在 **堆上** 分配和回收空间

**区别**：

- **类型**
  - new、delete是C++的运算符；malloc、free是C/C++的标准库函数
- **是否调用构造析构**
  - new、delete 分配和释放内存，**可以调用对象的构造函数和析构**
  - malloc、free **只能分配和回收内存**，不会调用构造和析构
  - new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象

- **返回类型**
  - new返回的是具体类型的指针，不需要进行类型转换
  - malloc返回的是void*，需要进行类型转换（因为它不知道所分配内存的用途）
- **分配内存大小**
  - new自动计算要分配空间的大小，动态分配，并知道大小
  - malloc只能分配指定大小的内存块，不了解分配内存块的具体用途
- **初始化**
  - new得到经过初始化的空间；malloc得到未初始化的空间

- **内存分配失败时**
  - new抛出`std::bad_alloc`异常；malloc返回`NULL`
- **释放内存**
  - **delete会调用对象的析构函数**，释放内存；free只是简单的释放内存块
  - 释放后
    - delete释放的内存块的指针，会被设置为`nullptr`，以避免野指针
    - free不会修改指针的值，可能导致野指针







### 为什么有了malloc/free还需要new/delete?

对于非内部数据而言，只有malloc和free无法满足动态对象的需求。

对象在创建的同时还要自动执行构造函数，消亡以前要自动执行析构函数。

malloc和free是库函数不是运算符，不在编译器控制权限内，不能把执行构造和析构函数的任务强加于malloc和free。





### C++怎么new一个数组？怎么delete？如果delete没加[ ]会怎么样？

**new和delete数组：**

![img](https://api2.mubu.com/v3/document_image/a954d366-22b8-4f88-92fe-b3caa3fb803d-915614.jpg)![img](https://api2.mubu.com/v3/document_image/be17ac6b-0fe3-429e-94c1-a8699b938aad-915614.jpg)

**delete没加[ ]**

- delete arr；释放内存，**只用来释放arr指向的内存**

- <span style="color:#CC0000;">delete [ ] arr;  释放 arr 指向的内存，**逐一调用数组中的每个对象的析构**</span>

- 普通内置类型数组

  - 没影响

  - 分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数， 它直接通过static指针可以获取实际分配的内存空间，哪怕是一个数组内存空间

- 类对象数组

  - delete 处理**数组类**类型的时候，会对每一个数组对象都调用它们的析构函数，然后再释放它们所占用的内存空间

  - delete 只释放了指针指向的第一个对象的内存，只调用 arr[0] 的析构函数，造成内存泄露

  - **new有析构函数的对象数组，必须要用delete[]删除**





## 函数在头文件中声明需要注意什么？

内部使用的函数（相当于类的私有方法），声明不应该放在头文件中

内部使用的宏、枚举、结构定义不应放在头文件中





## 变量和作用域

### **三种变量：**

- **局部变量：**在函数或一个代码块内部声明的变量（<span style="color:#0000FF;">大括号内{ }</span>）
- **形式参数：**函数参数的定义中声明的变量
- **全局变量：**在所有函数外部声明的变量

在程序中，**局部变量和全局变量的名称可以相同**，但是在**<span style="color:#CC0000;">函数内，局部变量的值会覆盖全局变量的值</span>。**

~~~c++
#include <iostream>
using namespace std;
 
// 全局变量声明
int g = 20;
 
int main ()
{
  // 局部变量声明
  int g = 10;
 
  cout << g; // 输出g=10
 
  return 0;
}
~~~



***初始化局部变量和全局变量***

- 局部变量被定义时，系统不会对其初始化，必须自行对其初始化

- 全局变量被定义时，**系统会自动初始化**

  <img src="C:\Users\h\AppData\Roaming\Typora\typora-user-images\image-20250330145939488.png" alt="image-20250330145939488" style="zoom: 50%;" />



### **作用域：**

- **局部作用域：**

  - 函数内部声明的变量，具有局部作用域，它们只能在函数内部访问
  - 局部变量在函数每次被调用时被创建，在函数执行完后被销毁

- **全局作用域：**

  - 在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的**任何函数**访问。
  - 全局变量在程序开始时被创建，在程序结束时被销毁。

- **块作用域：**

  - 在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。

  - 块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。

    ~~~c++
    #include <iostream>
    
    int main() {
        int a = 10;// 外部
        {
            int a = 20;  // 块作用域变量
            std::cout << "块变量: " << a << std::endl;// 20
        }
        std::cout << "外部变量: " << a << std::endl;// 10
        return 0;
    }
    ~~~

- **类作用域：**

  - 在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。
  - 类作用域变量的生命周期，与类的生命周期相同。



## template 模板

### 模板怎么实现的？

- 函数模板

  - 建立一个通用函数，返回值类型、形参类型可以不具体指定，用一个虚拟类型来代表

  - 类型参数化

  - template <typename  T>

  - 使用方式

    - 自动类型推导

    - 显示指定类型

- 类模板
  - template <class  T>

- 实现

  - 编译器并不是把函数模板处理成能够处理任意类的函数

  - 编译器从函数模板通过具体类型产生不同的函数

  - 编译器会对函数模板进行两次编译

    - 在声明的地方对模板代码本身进行编译

    - 在调用的地方对参数替换后的代码进行编译



### 模板和override的关系











## 数据类型

**整型数据长度**

- short 至少16位
- int 至少与short一样长
- long 至少32位，且至少与int一样长
- long long 至少64位，且至少与long一样长

在使用8位字节系统中，1byte = 8bit。

可以通过`sizeof()`判断数据类型长度

**很多系统都使用最小长度**

- short 16位（2字节）
- long 32位  （4字节）
- long long  64位（8字节）
- int  32位（4字节）

**头文件` <climits>`定义了符号常量，如：**

- INT_MAX  表示int最大值
- INT_MIN   表示int最小值

**无符号类型**

即不存储负数值的整型，可以增大变量能够存储的最大值，数据长度不变

int被设置为自然长度，即计算机处理起来效率最高的长度，所以选择类型时一般选用int





### 两个float怎么比较相同，为什么这样比较，什么原因导致的？

- 由于浮点数的表示是不精确的，所以不能直接比较两个数是否完全相等

- 一般都是在允许的某个范围内认为某个个浮点数相等
  - 如有两个浮点数a、b，允许的误差范围为 1e-6，则 abs(a-b) <= 1e-6，即可认为 a 和 b 相等。

- 扩大再取整
  - 比如 a=5.23、b=5.23，直接比较 a==b 有可能为 false，但是 a 和 b 都扩大一百倍，然后强制转换为 int 类型，再用 == 比较就可以了。









## C和C++的区别

- **C是一种结构化语言，**重点在于算法和数据结构，首先考虑是如何通过一个代码一个过程对输入进行运算处理输出

- **C++面向对象，**首先考虑如何构造一个对象模型，让这个模型能够契合对应的问题，通过获取对象的状态信息得到输出

- **C++允许自己定义自己的空间**，C不可以

- **函数方面：**C++中有重载和虚函数的概念

- **new和delete：**C++中的new和delete是对内存分配的运算符，取代了C中的malloc和free

- **C中没有字符串类型：**标准C++中的字符串类，取代了标准C函数库头文件中的字符数组处理函数

- **变量定义：**

  - C++中允许变量语句在程序中任何地方（使用之前就可以）；

  - C语言中必须在函数开头部分

- **C++中增加了引用**

- **struct方面：**

  - C++的struct可以有成员变量和成员函数，增加了权限访问，struct的默认成员访问权限和默认集成权限都是public

  - C的struct更适合看做一个数据结构的实现体，C++的class更适合看成一个对象的实现体

  - C的struct没有继承关系，C++的class有继承关系

  - C++中class的默认成员访问权限和集成权限都是private

- **C++中增加了模板，重用代码，提供了stl标准库**

- **C++相对与C增加了一些关键字**，如：bool、using、dynamic_cast、namespace等等

  





# 内存✅



## C++如何管理内存

<img src="C:\Users\h\AppData\Roaming\Typora\typora-user-images\image-20250330143032403.png" alt="image-20250330143032403" style="zoom:80%;" />

**栈：**

- <span style="color:#0000FF;">函数参数、局部变量</span>
- **编译器**自动分配释放
- 注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

**堆：**

- new开辟堆内存，delete释放
- **程序员**分配释放
- 如果程序员没有释放掉，在程序结束后，操作系统会自动回收

**自由存储区：**

- 如果说堆是操作系统维护的一块内存，那么自由存储区是C++中通过new和delete动态分配和释放对象的抽象概念。
- 需要注意的是，自由存储区，和堆比较像，但不等价

**全局（静态）存储区：**

- 全局变量、静态变量（static）
- 操作系统释放

**常量区：**

- 全局常量（const修饰的全局常量），字符串常量
- 操作系统释放

**代码区：**

- 函数体的二进制代码
- 操作系统管理
- 共享、只读



## 堆和栈的区别

内存管理：

- **堆内存是动态分配**的，即可以在运行时决定分配多少内存
- **栈内存是在编译时**就已经确定的

生命周期：

- **堆的生命周期取决于程序员**的管理，当使用new分配了一块堆内存后，它会一直存在，直到使用delete释放
- **栈的生命周期取决于其作用域**，当变量的作用域结束后，它占用的栈内存就会被自动释放

性能：

- 堆需要在运行时查找足够大的内存块来分配，速度相对较慢
- **栈是以连续、固定大小的块来管理的**，所以分配和释放速度都比堆内存要快

空间大小：

- 堆空间大，受限于计算机系统中可用的总内存
- 栈空间相对较小，当尝试在栈上分配大量内存，可能会导致栈溢出

碎片化：

- 频繁的在堆上分配和释放小块内存可能会导致内存碎片化，降低程序性能
- 栈上不会有这个问题







## 内存泄漏

### 什么是内存泄漏

一般指**<span style="color:#CC0000;">堆内存泄漏</span>**，内存申请后，**用完没释放**，造成可用内存越来越少。

> 堆内存使用完后必须显式释放，应用程序般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，必须调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了

和内存溢出的区别：

- **内存溢出**指的是内存越界，常见为调用递归函数没有结束条件，导致栈内存不足而溢出



### 造成内存泄漏的常见情况

- 指针重新赋值
- 错误的内存释放（new申请，但是用free释放；或者new的对象，没有释放）
- 智能指针的循环引用
  - 在使用智能指针（如 std::shared_ptr）时，如果存在循环引用，可能会导致内存泄露
- 返回值的不正确处理（返回值为指针或引用）



### 如何避免内存泄漏

- 尽量避免在堆上分配内存
- 有new就有delete，有malloc就有free，保证它们一定成对出现
- 对象数组的释放一定要用`delete[]`
- 计数：使用new或者malloc时，计数+1，使用delete或free后，计数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄漏
- 一定要将基类的析构函数声明为虚函数
- 使用`RALL`，它充分利用里C++语言局部对象自动销毁的特性来控制资源的生命周期
- 使用协程，协程具有独立的栈空间，并且能长时间的暂存栈上的数据



### 检测工具

- Linux下：Valgrind工具
- Windows下：CRT库



## 堆和栈溢出的原因？❓













## char a = -1 在计算机内存中是怎么存储的？❓

- C 语言中，负数在内存中存储的是**补码**形式

- 正数在内存中以原码形式存储

- 浮点数是采用某种规则转换后存储

- char 型是直接将其对应的**ASCII码**存储





# 面向对象✅



## 三大特性

### 封装

将客观实物抽象成类，类可以把自己的数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏。

一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。

### 继承

子类继承父类，某个类型的对象获得另一个类型对象的属性的方法。

三种方式：

- 实现继承：使用基类的属性和方法而无需额外编码的能力
- 接口继承：仅使用属性和方法的名称、但是子类必须提供实现的能力
- 可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力（不常用）

### 多态

同一事物表现出不同事物的能力，向不同对象发送同一消息，不同的对象在接收时会产生不同的行为

允许将父对象设置成和一个或多个它的子对象相等，赋值之后，父对象可以根据当前赋值给它的子对象的特性以不同的方式运作。**允许将子类类型的指针赋值给父类类型的指针**

实现方式：

- 重载 —>  <span style="color:#0000FF;">静态多态：允许存在多个同名函数，参数表不同</span>

- 覆盖 —>  <span style="color:#0000FF;">动态多态：子类重新定义父类的虚函数  </span>



多态与非多态的**实质区别就是函数地址是早绑定还是晚绑定的**。

- 如果函数的调用，在<span style="color:#0000FF;">编译期间</span>就可以确定函数的调用地址，并产生代码，就是<span style="color:#0000FF;">静态</span>的，即地址早绑定
- 如果函数调用的地址不能在编译期间确定，在<span style="color:#0000FF;">运行时</span>才能确定，就是<span style="color:#0000FF;">动态</span>的，地址晚绑定



## 类

### 什么是类？类如何调用自己的方法？（this指针）

类是封装数据和函数的组合，具有相同性质的对象，可以抽象为类。

类通过this指针调用自己的方法：

- this指针指向被调用成员函数所属的对象
- this指针隐含在每一个**非静态**成员函数内
- this指针不需要定义，直接使用
- 当形参和成员变量同名时，可以用this指针来区分
- 在类的非静态成员函数中，返回对象本身，可以用`return *this`





### 如何让一个类只在栈上创建？只在堆上创建？

**创建类对象**

- 静态创建 — <span style="color:#0000FF;">直接创建 — 栈上</span>
  - 编译器为对象在栈空间分配内存
  - 移动栈顶指针获得合适空间
  - 调用构造函数生成对象
- 动态创建 —<span style="color:#0000FF;"> new — 堆上</span>
  - new为对象在堆中分配内存，执行operator new()函数，在堆中搜索一块内存进行分配
  - 调用构造函数创建对象

**只在栈上（静态创建）**

- <span style="color:#0000FF;">限制new的使用</span>
- new和delete重载

**只在堆上（动态创建）**

- <span style="color:#0000FF;">构造、析构设为私有</span>



### 什么时候用到静态成员函数？

需要在<span style="color:#0000FF;">没有生成对象的时候，就能调用类的成员函数</span>。

如果需要调一个在类里，但跟类的实例无关的函数。



### class和stuct的区别 ⭐⭐⭐

- 默认访问权限：

  - 在struct中，成员的默认访问权限是public，这意味着它们可以在结构体外部直接访问。

  - 而在class中，成员的默认访问权限是private。

- 默认继承访问权：

  - struct进行继承时，默认的继承访问权限是public。

  - class进行继承时，默认的继承访问权限是private。

- 模板参数定义：

  - 在定义模板参数时，可以使用class关键字，但不能使用struct关键字



### 深拷贝、浅拷贝❓







### 拷贝构造函数，为什么最好自定义？❓❓

- 构造函数
  - 创建对象时为对象的成员属性赋值，编译器自动调用

- 默认情况下，编译器至少给一个类添加3个函数

  - 默认构造（无参，函数体空）

  - 默认析构 （无参，函数体空）

  - 默认拷贝构造

- 构造函数调用规则

  - 用户定义有参构造 --- 不再提供默认无参构造，会提供默认拷贝构造

  - 用户定义拷贝构造 --- 不再提供其他构造

- 拷贝构造

  - 调用拷贝构造的时机

    - 使用一个已经创建完的对象，来初始化一个新对象

    - 值传递的方式给函数参数传值

    - 以值方式返回局部对象

- 浅拷贝

  - 简单的赋值拷贝

  - 单纯地将原对象的指针指向新对象，而不复制它所指向的实体

  - 问题：堆区内存的重复释放

  - 如果属性有在堆区开辟的，一定要自己提供拷贝构造，防止浅拷贝问题

- 深拷贝
  - 堆区重新申请空间，进行拷贝





### static_cast和dynamic_cast的区别，父类向子类转化会有危险吗，哪个更安全❓❓

- https://blog.csdn.net/u012411498/article/details/80804755





### 友元函数，是单向的吗，可以继承吗？

友元函数 friend：

- 定义在类外部，有权访问类的私有和保护成员

- 友元函数不是成员函数

- 三种实现：

  - 全局函数做友元

  - 类做友元

  - 成员函数做友元

- **单向，不具有交换性**

- **不能被继承**

- 不具有传递性





## 多态

### 静态多态

- <span style="color:#CC0000;">函数重载，运算符重载、复用函数名</span>
- 函数地址早绑定 --- <span style="color:#0000FF;">**编译阶段**确定函数地址</span>

### 动态多态

- <span style="color:#CC0000;">派生类、虚函数</span>实现运行时多态

- 函数地址晚绑定 --- <span style="color:#0000FF;">**运行阶段**确定函数地址</span>

- 类之间通过**<span style="color:#CC0000;">继承</span>**关联时，用到多态

- 调用成员函数时，会根据调用函数的**对象类型**来执行不同的函数

- 可以有多个不同的类，都带有**同一个名称但具有不同实现的函数**，函数的参数甚至可以是相同的。

- **满足条件**
- **有继承关系**
  
- **子类重写父类的虚函数**
  - 重写：函数返回值类型，函数名，参数列表，完全相同
  
  - 子类中的virtual可加可不加

- **使用**
- <span style="color:#0000FF;">父类的指针或引用，指向子类对象</span>





### 公有继承，保护继承，私有继承 ❓







### 派生类的构造，析构调用顺序？❓







## 虚函数

### 什么是虚函数？

类中使用`virtual`声明的函数。

**实现动态多态**（静态多态主要是重载）

- 满足条件
  - 有**继承**关系
  - 子类要**重写**父类的虚函数 （函数返回值类型，函数名，参数列表 完全相同）（子类中的virtual可加可不加）
- 使用（什么情况会触发虚函数）：
  - 子类继承父类，父类中有虚函数
  - 子类重写父类虚函数
  - <span style="color:#0000FF;">父类的指针或引用指向子类对象</span>


在子类中，重新定义基类中定义的虚函数时，会告诉编译器，不要静态链接到该函数。

一个父类类型的指针，指向一个子类对象时，使用父类的指针去调用【子类中重写了父类中的虚函数】时，会调用子类重写过的函数。

<span style="color:#CC0000;">**不要在构造或者析构中调用虚函数！！！** **析构函数一定是虚函数！**</span>



**虚函数实现：**

- 在有虚函数的类中，类的最开始部分是一个**<span style="color:#0000FF;">虚函数表指针</span>**，指向一个**<span style="color:#0000FF;">虚函数表</span>**，表中存放**虚函数的地址**
- 当子类继承了父类的时候，也会继承父类的虚函数表
- 当子类**重写父类中的虚函数**，会将其继承到的虚函数表中的地址，**替换为子类重新写的虚函数地址**
- 使用虚函数，会增加访问内存开销，降低效率

![image-20250531181702370](C:\Users\h\AppData\Roaming\Typora\typora-user-images\image-20250531181702370.png)

![image-20250531182214157](C:\Users\h\AppData\Roaming\Typora\typora-user-images\image-20250531182214157.png)



### 哪些函数不能是虚函数？

- **构造函数**
- **内联函数 inline**
  - 内联函数表示在编译阶段进行函数体的替换操作
  - 虚函数在运行期间进行类型确定
- **静态函数 static**
  - 静态函数不属于对象，属于类
  - 静态函数没有this指针（虚函数表是通过this指针调用的）
- **友元函数**
  - 友元函数不属于类的成员函数，不能被继承
- **普通函数**
  - 不属于类的成员函数，不具有继承特性



### 为什么static成员函数不能被virtual修饰（为什么不能作为虚函数 - vptr）

虚函数的实现，是为每个对象分配一个vptr虚指针，<span style="color:#0000FF;">vptr是通过**this指针**调用的</span>

而**static成员函数属于类，不属于类的对象，所以它没有this指针**（this指针指向对象本身）

虚函数调用关系：this–>vptr–>ctable–>virtual function



### 构造函数里调用虚函数会怎样？⭐

- 语法上允许，但通常不会起作用
- 当构造函数正在执行时，对象的类型被视为**当前构造函数所属的类类型**，而不是子类型
- **父类构造无法调用子类虚函数**
- 继承关系中，先构造父类，再构造子类，析构相反
- 构造函数和析构函数，调用其他虚函数时，由于<span style="color:#0000FF;">虚函数表指针指向的是【当前类的虚函数表】，调用的是当前类的函数</span>
- 父类构造函数调用虚函数，调用的就是父类的版本，而不是子类版本
- <span style="color:#0000FF;">在执行构造函数前对象未完成创建，虚函数表还不存在</span>





### 析构函数应该设置为虚函数吗？⭐

只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。**<span style="color:#CC0000;">基类的析构函数</span>一般建议声明为虚函数**。

**解决问题：<span style="color:#0000FF;">父类指针，释放子类对象</span>**

- 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构

**析构可以为虚函数，构造不行**

- 构造函数不能被声明为虚函数，因为在<span style="color:#0000FF;">执行构造函数前对象未完成创建，虚函数表还不存在</span>

纯虚析构

- 如果是纯虚析构，该类属于<span style="color:#0000FF;">抽象类</span>，无法实例化对象






### virtual 在构造和析构中作用？为什么基类析构要设置为虚析构？❓













### 一个类有几个虚表指针？类对象有虚表指针吗？

**虚指针**：

- <span style="color:#0000FF;">每个含有虚函数的类都有一张虚函数表</span>，存储这个类所有<span style="color:#0000FF;">虚函数的入口地址</span>。
- 虚指针指向虚函数表

**存在虚函数的类至少有一个虚表指针**

- 多重继承：一个类可以从多个类中继承虚函数，可能会有多个虚表指针，<span style="color:#0000FF;">每个父类一个</span>
- 虚继承：解决菱形继承，可能会有多个虚指针

**虚函数表是针对类的，而不是对象**

- 同一个类的所有对象，**共享类的虚函数表**，不同对象的虚函数表一样。
- 每个对象内部都保存一个指向该类的虚函数表的指针 vptr
- 每个对象的vptr存放地址不同，但**指向同一虚函数表**





## C++ 重载

重载：
- 允许在同一作用域中的某个函数和运算符指定<span style="color:#0000FF;">多个定义</span>

**函数重载**

- 同个作用域，声明<span style="color:#0000FF;">同名函数</span>，形式参数（参数个数、类型或顺序）不同

- 函数名相同，提高复用性

- 条件：

  - 同一个作用域

  - 函数名称相同

  - 函数参数类型、或者个数、或者顺序不同

- 不能仅通过返回类型的不同进行重载

**运算符重载**

- 对已有运算符重新定义，赋予其另一种功能

- 成员函数重载

- 全局函数重载







# STL✅

## vector成员函数有哪些？

- 构造函数 vector（）

- 尾部增加 push_back

- 指定位置增加 insert

- 尾部删除 pop_back

- 指定位置删除 erase

- 移除所有元素 clear

- 返回首部元素 front

- 返回尾部元素 back

- 迭代器函数

  - 返回第一个元素 begin

  - 返回最后一个元素 end

  - 元素数量 size

  - 可能容纳的最大元素数量 max_size

  - 已分配空间 capacity

  - 是否为空 empty



## vector中size和capacity的区别，哪个大（capcaity）

- size --- 元素数量

- capacity --- 容量（更大）



## 用过的STL⭐⭐⭐

STL --- 标准模板库

六大组件

- 容器：vector、list、deque、set、map

- 算法

- 迭代器

- 仿函数

- 适配器 （配接器）

- 空间配置器



vector：

- 采用一维数组实现，元素在内存连续存放。

- 查看操作的时间复杂度为：O(1)。

deque：

- 采用双向队列实现，元素在内存连续存放。

- 查看操作的时间复杂度为：O(1)。

list：

- 采用双向链表实现，元素存放在堆中。

- 查看操作的时间复杂度为：O(N)。

set/map/multiset/multimap：

- 这四种容器采用<span style="color:#0000FF;">红黑树</span>实现，红黑树是平衡二叉树的一种。

- 查看操作的时间复杂度近似为: O(logN)。





## vector底层实现，实现原理，动态申请内存⭐⭐⭐⭐⭐⭐❓

- **动态数组**

- vector使用灵活的动态空间配置，维护一块**连续的线性空间**，在空间不足时，可以自动扩展空间容纳新元素，做到按需供给。

- 其在扩充空间的过程中仍然需要经历：
  - 重新配置空间 ➡️ 移动数据 ➡️ 释放原空间等操作



## vector如何扩容⭐⭐⭐❓

- 扩容规则

  - 当数组大小不够容纳新增元素时，开辟更大的内存空间，把旧空间上的数据<span style="color:#0000FF;">复制</span>过来，然后在新空间中继续增加。

  - 新的更大的内存空间，<span style="color:#0000FF;">一般是当前空间的1.5倍或者2倍</span>，这个1.5或者2被称为**扩容因子**，不同系统实现扩容因子也不同。

    - 扩容因子越大，需要分配的新内存空间越多，越耗时。空闲空间较多，内存利用率低。

    - 扩容因子越小，需要再分配的可能性就更高，多次扩容耗时。空闲空间较少，内存利用率高。

- 假设按2倍扩容，给一个vector1，初始化reserve(10000)和另一个vector2，无操作，问对两个vector添加10000个元素，第二个比第一个多了多少个操作（等比数列求和）



## vector 插入元素发生了什么？ ❓





## 什么是迭代器失效？❓









## list底层实现

- 双向链表

- 支持任意位置高效插入和删除，不支持快速随机访问

- 插入或删除都只作用于一个元素空间

- list与vector的另一个区别是，在插入和接合操作之后，都不会造成原迭代器失效，而vector可能因为空间重新配置导致迭代器失效

- list是一个双向链表，也是一个<span style="color:#0000FF;">环形链表</span>

- 插入或删除都只作用于一个元素空间







## list 和 vector 的区别，适用场景？❓





## map底层实现⭐⭐⭐

- 红黑树

- 支持快速查找，不支持快速随机访问



















































# 编译✅

## C++编译过程

<span style="color:#0000FF;">预处理  =>  编译  =>  汇编  =>  链接</span>



## 模板开发在哪个阶段？

在编译阶段。

模板是C++泛型编程的基础，一个模板就是一个创建类或者函数的公式。

在具体使用时，需要将模板参数转化为具体类型，比如 int，float，Vector以及自定义类型；这种转换过程发生在编译阶段。





## 动态链接库，静态链接库





## pragma pack编译宏





## C++程序如何从源代码到可执行文件

- 预处理 --- <span style="color:#0000FF;">xxx.i</span>

  - 处理以“#”开头的预编译指令

  - 删除所有的#define，展开所有的宏定义

  - 处理“#include”预编译指令，将文件内容替换到它的位置

  - 删除所有的注释，“//”和“/**/”

  - 保留所有的#pragma 编译器指令

- 编译
  - 词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件

- 汇编 --- <span style="color:#0000FF;">xxx.o</span>
  - 将汇编代码转变成机器可以执行的指令

- 链接
  - 将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序

- 生成可执行文件



## 预编译过程中条件编译，include和宏定义的执行顺序

- 宏定义

- \#include 头文件展开

- 条件编译

- 注释删除

- 其他预处理指令，如# pragma





## 预编译？❓





# C++11✅

## C++11新特性

**auto**

- C++ 11引入了类型推断能力
- 使用auto关键字，编译器可以自行推断变量的类型。

**lambda**

- C++ 11可以创建匿名函数，也称为Lambda函数
- Lambda表达式允许我们在本地定义函数
- 还允许在调用处定义函数，从而消除了许多复杂性和安全风险。

**nullptr**

- 使用nullptr代替NULL或0来指定一个指向无值的指针

**noexcept**

- 如果一个函数无法抛出异常，那么可以在C++ 11中将该函数声明为noexcept，这有助于解决未知类型的错误。

**override标识符**

- 随着项目变得越来越大，需要更多的文件来完成一个任务。
- 为了避免混淆，C++ 11引入了override标识符，用于明确表示<span style="color:#0000FF;">子类中的函数覆盖了基类中的同名函数</span>。

**无序容器**

- C++ 11引入了无序容器，如unordered_map和unordered_set。

**移动语义和右值引用**

- 通过引入移动构造函数和移动赋值操作符，C++ 11支持将对象的**资源“移动”到另一个对象**，而不是创建一个完全新的副本。
- 移动构造
- 右值引用
  - 右值引用使用  `&&` 表示，用于实现移动语义和完美转发
  - 右值引用只能绑定到即将销毁的对象（通常是临时对象），而不能绑定到持久的对象

**变长模板**

- C++ 11支持变长模板，这使得模板可以接受可变数量的参数



### auto和decltype ⭐

C++ 提供了 auto 和 decltype 来静态推导类型。当知道类型没有问题但又不想写出完整类型的时候，使用静态类型推导。

auto 编译器根据初始化表达式自动推导变量类型。

decltype 用于获取一个表达式的类型，而不对表达式进行求值。

| 特性           | `auto`                             | `decltype`                                   |
| -------------- | ---------------------------------- | -------------------------------------------- |
| 是否需要初始化 | 是                                 | 否                                           |
| 是否求值       | 是，推导需要实际值                 | 否，纯粹分析表达式类型                       |
| 保留引用/const | 默认不保留顶层 const，不保留引用   | 完全保留引用和 const                         |
| 典型用途       | 声明变量、函数返回类型（C++14 起） | 获取表达式类型，用于模板推导、返回类型声明等 |





### 左值右值引用？⭐

**左值引用**

- 传统引用，别名

- 常用于函数参数传递和局部变量的别名

- 可以取地址，有名字，非临时

- 左值，在内存有确定存储地址、有变量名，表达式结束依然存在的值

- 绑定到右确定存储空间以及变量名的对象上，表达式结束后对象依然存在

**右值引用**

- C++11引入的新类型引用

- 绑定到右值的引用，通过`&&`来获得右值引用

- 用于实现移动语义和完美转发

- 不能取地址，没有名字，临时的

- 右值，就是在内存没有确定存储地址、没有变量名，表达式结束就会销毁的值

- 绑定到要求转换的表达式、字面常量、返回右值的表达式等临时对象上，赋值表达式结束后对象被销毁





### std::move

> `std::move` 是一个“右值引用转换器”，告诉编译器：“我不再需要这个对象的内容了，可以直接转移资源”。这叫“移动语义”。

**左值和右值**

| 名称 | 含义                           | 举例                               |
| ---- | ------------------------------ | ---------------------------------- |
| 左值 | 有名字、可以取地址的变量       | `int a = 10;` → `a` 是左值         |
| 右值 | 临时的值，没有名字，不能取地址 | `a + 1`、`10`、`std::string("hi")` |

~~~c++
int x = 5;
int y = x + 2;   // x 是左值；x+2 是右值
~~~

**移动语义**

C++11引入的新机制，在可以避免拷贝的场景下，直接“搬走”资源，提高效率。

~~~c++
// 不使用移动语义
std::string s1 = "hello";
std::string s2 = s1;  // 拷贝构造 → 复制内容，开销大


// 使用移动语义
std::string s1 = "hello";
std::string s2 = std::move(s1); // 移动构造 → 把 s1 的内容“挪给” s2

~~~

s1的内容直接搬给s2，之后 **s1 的内容被清空，s2 拿到原来的内容**。

移动时发生的事情：

- 把s1的资源指针交给s2，s2现在拥有这块内存，s1把自己的指针设为nullptr

`std::move()`**把 obj 转换成一个右值引用**，告诉编译器：“这个对象可以被搬走，你别拷贝了”。

~~~c++
std::move(obj) 
~~~

~~~c++
std::vector<int> v1 = {1, 2, 3};
std::vector<int> v2 = std::move(v1);  // 移动构造
~~~

**适合的典型场景：**

- 容器插入元素（如 `std::vector::emplace_back(std::move(obj))`）；
- 返回局部对象时优化性能；
- 对象的所有权转移（如智能指针）。



在**智能指针（如 `std::unique_ptr`）中使用 `std::move`** 是其核心特性之一，用于**转移资源所有权**，这是移动语义的典型应用。

`std::unique_ptr<T>`：**独占所有权**，不能拷贝，只能移动。

`std::shared_ptr<T>`：**共享所有权**，可以拷贝，也可以移动。

对于 `unique_ptr` 来说，只有通过 `std::move` 才能把资源的所有权从一个对象转移给另一个。

~~~C++
std::unique_ptr<int> p1 = std::make_unique<int>(10);
std::unique_ptr<int> p2 = p1;            // ❌ 错误：拷贝构造被删除
std::unique_ptr<int> p3 = std::move(p1); // ✅ 正确：移动构造，p1 被清空
~~~

- `std::move(p1)` 将 `p1` 转换为一个右值引用；
- 调用 `unique_ptr` 的 **移动构造函数**，将原始资源的所有权转移到 `p3`；
- `p1` 此后变为空（`nullptr`），防止双重释放。



## 智能指针

解决问题：**内存泄露**

传统指针需要手动管理new/delete，容易出现内存泄漏（没释放），野指针（释放后继续用），重复释放等问题。

内存管理库`<memory>`，包含了用于**动态内存管理**的模版和函数，提供了**智能指针**等工具。

动态内存管理允许程序在运行时分配和释放内存。

智能指针是 C++11 引入的特性，是一种类模板，用于<span style="color:#0000FF;">自动管理动态分配的内存</span>。

**智能指针的作用：**RAII 原则（资源获取即初始化），**让资源的释放和对象生命周期绑定，自动释放**，避免资源泄漏。

C++11提供了三种智能指针类型来管理动态对象：**shared_ptr、weak_ptr、unique_ptr**（auto_ptr或已废弃）

| 智能指针             | 特点                                                         | 使用场景                 |
| -------------------- | ------------------------------------------------------------ | ------------------------ |
| `std::unique_ptr<T>` | **独占式拥有**，不能复制，<br />同一时间**只能有一个unique_ptr指向内存** | 独享资源                 |
| `std::shared_ptr<T>` | **引用计数共享**，多个指针共同管理<br />多个 `shared_ptr` **可以指向同一内存**，内存在最后一个 `shared_ptr` 被销毁时释放。 | 多个对象需要**共享**资源 |
| `std::weak_ptr<T>`   | 辅助 `shared_ptr`，不增加引用计数                            | 避免循环引用             |



### std::unique_ptr

**创建**

~~~c++
// 方式1
std::unique_ptr<T> ptr; // 表示 unique_ptr 会管理一个类型为 T 的对象

// 创建ptr，ptr会自动管理一个new创建int类型的对象，并确保在它超出作用于时自动释放该资源
std::unique_ptr<int> ptr1(new int(10)); // 不推荐：手动使用 new 创建对象


// 方式2 make_unique
auto ptr = std::make_unique<T>(args...); // 比直接使用new更加安全

// 创建一个 int 类型的 unique_ptr，管理值为10的int对象
auto ptr = std::make_unique<int>(10);   


// 当 ptr 超出作用域时，ptr 自动调用其析构函数，释放所管理的内存
~~~

`std::make_unique`

- 是一个工厂函数，创建并返回一个新的 unique_ptr 对象。
- 内部使用 `new` 来动态分配内存并返回 `unique_ptr`，确保资源的正确管理。
- 相比直接使用 `new`，`std::make_unique` 更加安全，因为它能够防止创建 `unique_ptr` 后忘记初始化、或者出现内存泄漏等问题。

**访问unique_ptr**

~~~c++
std::cout << *ptr << std::endl; // * 解引用
~~~

#### **std::move() 转移所有权**

~~~c++
// 将 ptr 的所有权转移到 ptr2，使得 ptr 变为“空”，而 ptr2 变成新的资源持有者
auto ptr2 = std::move(ptr); 
~~~

`unique_ptr` 不允许复制，因此要使用 `std::move` 来显式地转移所有权。这样可以避免资源的重复管理，确保资源只有一个所有者。

#### get()

 `get()` 是 `std::unique_ptr` 智能指针的成员函数：

~~~C++
Acceptor* get() const noexcept;
~~~

`get()` 返回 `unique_ptr` 所管理的**原始裸指针**（raw pointer），**但不释放所有权**。也就是说，它不会影响智能指针的生命周期控制。



### std::shared_ptr

**创建**

~~~c++
// 方式1
std::shared_ptr<T> ptr;

std::shared_ptr<int> ptr(new int(10));;  // 管理一个 int 类型的对象


// 方式2 make_shared
auto ptr = std::make_shared<T>(args...);

auto ptr = std::make_shared<int>(10);  // 创建一个 shared_ptr，管理一个值为 10 的 int 对象

~~~

**访问shared_ptr**

~~~c++
std::cout << *ptr << std::endl;  // 解引用访问，输出: 10
~~~

如果 `shared_ptr` 管理的是类对象，则可以通过 `->` 操作符访问类的成员函数或数据成员。例如，如果 `ptr2` 是一个指向 `std::string` 类型的 `shared_ptr`，那么 `ptr2->size()` 就是调用 `std::string` 类的 `size()` 成员函数。

~~~c++
// 管理一个 std::string 类型的对象
std::shared_ptr<std::string> ptr2 = std::make_shared<std::string>("Hello!"); 

// 通过箭头操作符访问对象的成员
std::cout << ptr2->size() << std::endl;  
~~~

**拷贝shared_ptr**

`std::shared_ptr` 可以被拷贝。当一个 `shared_ptr` 被拷贝时，它们会**共享相同的资源**，同时**引用计数会增加**。

~~~c++
std::shared_ptr<int> ptr2 = ptr1;  // 引用计数增加
~~~

**引用计数**

- 每次拷贝 `shared_ptr` 时，引用计数都会增加，表示**有多个 `shared_ptr` 指向同一个资源**。
- 当 `shared_ptr` 被销毁时，引用计数会减少，**直到引用计数为 0 时，资源才会被释放**。

~~~c++
std::cout << "use_count = " << ptr.use_count() << std::endl;  // 输出当前引用计数
~~~

`use_count()` 返回当前有多少个 `shared_ptr` 指向同一个资源。

**销毁资源**

当 `shared_ptr` 的引用计数为 0 时，它管理的资源会被自动销毁。当最后一个指向资源的 `shared_ptr` 被销毁时，它所管理的资源会被释放。

~~~c++
{
    std::shared_ptr<int> ptr1 = std::make_shared<int>(10);
    std::shared_ptr<int> ptr2 = ptr1;  // 引用计数增加
    std::cout << *ptr1 << std::endl;  // 输出: 10
}  // 当 ptr1 和 ptr2 超出作用域时，资源被自动释放

// ptr1 和 ptr2 都指向相同的 int 对象，引用计数为 2。
// 当它们超出作用域时，引用计数会减少到 0，资源会被释放。
~~~



### std::weak_ptr

`std::weak_ptr` 是 C++ 标准库中与 `std::shared_ptr` 配套使用的智能指针。它主要用于**解决循环引用**的问题。

**是shared_ptr的观察者**，和shared_ptr**指向同一个资源**，**但不“拥有”资源**，对资源没有控制权。

所以`weak_ptr` 不会增加资源的引用计数，只是观察一个由 `shared_ptr` 管理的资源。

当所有的 `shared_ptr` 都被销毁时，`weak_ptr` 会变成一个**空指针**。

**创建**

`std::weak_ptr` 不能直接创建，它必须从一个有效的 `shared_ptr` 对象构造。

~~~c++
std::shared_ptr<T> shared_ptr = std::make_shared<T>(args...);
std::weak_ptr<T> weak_ptr(shared_ptr);

std::shared_ptr<int> sp = std::make_shared<int>(10);  // 先创建 shared_ptr
std::weak_ptr<int> wp(sp);  // 用 shared_ptr 创建 weak_ptr

~~~

**循环引用**

~~~c++
// 假设两个对象A B，它们通过shared_ptr相互持有对方的引用
class A {
public:
    std::shared_ptr<B> b;
};

class B {
public:
    std::shared_ptr<A> a;
};

~~~

`A` 持有 `B` 的 `shared_ptr`，而 `B` 又持有 `A` 的 `shared_ptr`。这样会导致循环引用，因为即使没有其他地方使用 `A` 或 `B`，它们的引用计数仍然大于 0，导致无法被销毁。

**解决循环引用**

通过将其中一个 `shared_ptr` 替换为 `weak_ptr`，我们可以打破循环引用。

~~~c++
class A {
public:
    std::shared_ptr<B> b;
};

class B {
public:
    std::weak_ptr<A> a;  // 使用 weak_ptr，避免循环引用
};

~~~

这样，`B` 类通过 `weak_ptr` 观察 `A` 类的对象，但不会影响 `A` 的引用计数。`A` 的对象可以在没有 `shared_ptr` 的情况下被销毁，从而避免了内存泄漏。

**访问weak_ptr**

`std::weak_ptr` 不能直接访问资源，因为它没有引用计数，也不保证资源一直有效。

它提供了 `lock()` 方法来尝试将 `weak_ptr` 转换为 `shared_ptr`，即获取一个有效的shared_ptr。

如果对象已经被销毁，`lock()` 会返回一个空的 `shared_ptr`。

~~~c++
std::shared_ptr<T> lock() const;
// lock() 会检查 weak_ptr 指向的对象是否仍然存在。
// 如果存在，返回一个新的 shared_ptr，否则返回一个空的 shared_ptr。
~~~

示例

~~~c++
#include <iostream>
#include <memory>

int main() {
    // 创建一个 shared_ptr 管理一个整数
    std::shared_ptr<int> sp = std::make_shared<int>(10);
    // 创建一个 weak_ptr，观察 sp 所管理的资源
    std::weak_ptr<int> wp = sp;

    // 尝试通过 weak_ptr 锁定并获取 shared_ptr
    std::shared_ptr<int> sp_copy = wp.lock();  // 锁定 weak_ptr

    if (sp_copy) {
        // sp_copy非空，锁定成功，资源依然有效，访问并打印资源
        std::cout << *sp_copy << std::endl;  // 输出: 10
    } else {
        std::cout << "The resource has been destroyed." << std::endl;
    }

    return 0;
}

~~~

`wp.lock()` 尝试将 `wp` 转换为 `shared_ptr`。**如果 `wp` 指向的资源没有被销毁**（即仍然被一个或多个 `shared_ptr` 引用），**`lock()` 返回一个新的 `shared_ptr`，它指向相同的资源。**

`sp_copy` 是通过 `lock()` 返回的新的 `shared_ptr`，它会增加引用计数，确保资源在 `sp_copy` 使用期间不会被销毁。

**如果 `wp` 指向的对象已经被销毁**（即没有任何 `shared_ptr` 引用它），`lock()` **返回一个空的 `shared_ptr`**（即 `nullptr`）。



#### lock()

`lock()` 是 `std::weak_ptr` 智能指针的一个成员函数，**尝试将 `weak_ptr` 升级为一个 `shared_ptr`**，如果原对象还存在（即引用计数未归零），返回一个有效的 `shared_ptr`；否则返回一个空的 `shared_ptr`。

~~~c++
std::shared_ptr<T> weak_ptr<T>::lock() const noexcept;
~~~

对象仍然存在，返回一个指向该对象的 `shared_ptr`

对象已经被销毁（引用计数归零），返回一个**空的 `shared_ptr`**



#### get()

 `get()` 是 `std::unique_ptr` 智能指针的成员函数：

~~~C++
Acceptor* get() const noexcept;
~~~

`get()` 返回 `unique_ptr` 所管理的**原始裸指针**（raw pointer），**但不释放所有权**。也就是说，它不会影响智能指针的生命周期控制。



### 智能指针使用场景

管理动态分配的内存，帮助避免内存泄露并使资源管理更加容易和安全





### 智能指针能管理多个连续空间吗？⭐





### 智能指针，shared_ptr原理，weak_ptr原理，weak_ptr为什么能防止两个shared_ptr相互引用⭐⭐⭐⭐⭐⭐

- https://blog.csdn.net/qq_43684922/article/details/89407311











### 什么时候会发生内存泄露？智能指针什么时候会发生内存泄露？ 

**内存泄露**

- 使用了一块内存区域，但是却没有释放，那么这块内存区域谁都用不了了，这就是内存泄漏。
- 己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费

**未及时释放不再使用的内存**

- new分配内存，没有使用delete释放

- delete处理类对象数组，没有加[ ]

**智能指针的内存泄漏**

- 循环引用：在使用智能指针（如 std::shared_ptr）时，如果存在循环引用，可能会导致内存泄露。

- 循环引用：

  - 两个或多个对象互相持有对方的引用或指针，形成一个闭环

  - 在使用智能指针（如C++中的 std::shared_ptr）时特别常见







## Lambda

C++11提供了对**匿名函数**的支持，称为 **Lambda 函数**（也叫 Lambda 表达式）。

Lambda表达式**把函数看做对象**。Lambda表达式可以像对象一样使用。

~~~c++
[capture](parameters)->return-type{function body}

// capture 捕获的外部变量列表，可以为空
// parameters 形参列表，可以省略，表示无参数
// return-type 返回类型，可以省略，省略时根据函数体的return语句返回类型确定，无return就返回类型void
// body 函数体

// 例如
[](int x, int y){ return x < y; }

[](int x, int y) ->int{ 
    int z = x + y; 
    return z + x
};
~~~

如果Lambda函数没有返回值（如void），其返回类型可被完全忽略。

在Lambda表达式内，`[]`可以访问当前作用域的变量，这是Lambda表达式的闭包行为。

C++变量传递有传值和传引用的区别，可以通过前面的 [ ] 来指定：

 **`[]`  不捕获外部任何变量，沒有定义任何变量。使用未定义变量会引发错误。**

~~~C++
#include <iostream>
using namespace std;

int main()
{
    int i = 1;
    auto func = [](int i) { cout << i << endl; }; // 有一个形参i
    func(i);
}
~~~

**`[=]`  捕获外部作用域所有变量的值，只读无法修改**
任何被使用到的外部变量，都隐式地以传值方式加以引用

~~~C++
#include <iostream>
using namespace std;

int main()
{
    int i = 1;
    auto func = [=]() { cout << i << endl; }; // 没有形参，而且直接捕获的i的值
    func();
}
~~~

**[&] 捕获外部作用域所有变量的引用，引用捕获，可修改捕获的变量**
任何被使用到的外部变量都隐式地以引用方式加以引用

~~~C++
#include <iostream>
using namespace std;

int main()
{
    int i = 1;
    auto func = [&]() { // 没有形参，而且直接捕获的i的引用
		cout << "修改前，i = " << i << endl;
		i++;
	};
    func();
	cout << "修改后，i = " << i << endl;
}

// 输出
修改前，i = 1
修改后，i = 2
~~~

**[var] 只捕获外部变量var的值，只读无法修改**

**[&var] 只捕获外部变量var的引用，可修改**

**[=, &] 混合方式**

~~~C++
#include <iostream>
using namespace std;

int main()
{
    int i = 1;
	int j = 2;
    
	// [&, =j]() { // 变量j值方式捕获，其余变量捕获引用
    
    auto func = [=, &i]() { // 变量i引用方式捕获，其余变量值方式捕获
		cout << "j = " << j << endl;
		i++;
	};
    func();
	cout << "i = " << i << endl;
}

~~~





## = delete 显示删除

C++11引入的 **显式删除函数（Deleted Function）** 语法，主要用于**禁用默认的函数**（如构造函数、拷贝构造、赋值运算符等）

```c++
noncopyable(const noncopyable &) = delete;// 显式删除了拷贝构造函数

noncopyable &operator=(const noncopyable &) = delete;// 显式删除了拷贝赋值运算符的语法

// 重载运算符=
// ClassName& operator=(const ClassName& other) {
//     if (this != &other) {  
//         // 赋值逻辑
//     }
//     return *this;
// }

```





## using

是 C++11 引入的 **类型别名** 语法，等价于 `typedef`，但更**清晰、易读**。

```c++
using 别名 = 目标类型;
```

channel.h

```c++
// channel.h
using EventCallback = std::function<void()>;
using ReadEventCallback = std::function<void(Timestamp)>;

// 等价的 `typedef` 形式：
typedef std::function<void()> EventCallback;
typedef std::function<void(Timestamp)> ReadEventCallback;
```





## function

`std::function` 是 C++11 引入的**通用函数封装器**，可以存储、调用和复制任何可调用对象**（普通函数、Lambda、成员函数、仿函数）**。

在头文件`<functional>`中。

`std::function` 主要用于**回调函数、事件处理、线程任务等场景**。

**基本用法**

```c++
#include <functional>

// 语法
std::function<返回类型(参数类型1, 参数类型2, ...)> 变量名;

// 示例
std::function<void()> func; // 存储无参数、无返回值的可调用对象
std::function<int(int, int)> add; // 存储两个 int 参数、返回 int 的可调用对象
```

**示例**

~~~c++
#include <iostream>
#include <functional>

void greet() {
    std::cout << "Hello, World!" << std::endl;
}

int main() {
    // f 是一个 std::function<void()> 类型的变量，表示一个“无参、无返回值”的函数对象
    std::function<void()> f = greet; // 将greet函数赋给f
    f(); // 输出: Hello, World!

    // lambda表达式作为回调
    std::function<void()> lambda = []() { 
        std::cout << "Hello, Lambda!" << std::endl;
    };
    lambda(); // 输出: Hello, Lambda!

    return 0;
}
~~~

**回调函数**

回调函数（Callback Function）是通过参数传递到另一个函数中，并在适当时机被“回调”执行的函数。

一个函数作为参数，传给另一个函数，并在后者中被调用。













# 多线程



## std::thread

C++ 11 之后添加了新的标准线程库 **std::thread**，std::thread 在 `<thread>` 头文件中声明。

`<thread>` 库是 C++ 标准库的一部分，提供了**创建和管理线程**的基本功能，它包括以下几个关键组件：

- `std::thread`：表示一个线程，可以创建、启动、等待和销毁线程。
- `std::this_thread`：提供了一些静态成员函数，用于操作当前线程。
- `std::thread::id`：线程的唯一标识符。

`std::thread` 表示一个可执行的线程。核心作用是：**创建并管理一个新线程**，让这个线程**执行你提供的函数**或 lambda 表达式。

**创建线程**

要创建一个线程，你需要实例化 `std::thread` 类，并传递一个可调用对象（函数、lambda 表达式或对象的成员函数）作为参数。

创建 `std::thread` 对象后，线程会立即开始执行。

~~~c++
#include<thread>
std::thread thread_object(callable, args...);
// callable：可调用对象，可以是函数指针、函数对象、Lambda 表达式等。
// args...：传递给 callable 的参数列表。
~~~

**示例**

~~~c++
#include <iostream>
#include <thread>

void printMessage(int count) {
    for (int i = 0; i < count; ++i) {
        std::cout << "Hello from thread (function pointer)!\n";
    }
}

int main() {
    // 创建一个 std::thread 类型的对象 t，它启动一个新线程去执行 func。
    std::thread t1(printMessage, 5); 
    
    t1.join(); // 等待线程完成
    return 0;
}


// 输出
Hello from thread (function pointer)!
Hello from thread (function pointer)!
Hello from thread (function pointer)!
Hello from thread (function pointer)!
Hello from thread (function pointer)!
~~~

必须调用 `join()` 或 `detach()` 处理线程，如果直接销毁线程对象，会导致程序崩溃。

```c++
std::thread t(task);  // 启动线程但没 join 或 detach
```

C++ 会报错：

> ```C++
> terminate called without an active exception
> ```

因为线程资源没有被正确处理，违反了 C++ 的线程语义。



**join()**

`join()` 用于**等待线程完成执行**。阻塞当前线程，直到被调用的线程完成执行。

```
t.join();
```

**detach()**

`detach()` 将**线程与主线程分离**，线程在后台独立运行，主线程不再等待它。

当线程执行完毕后，你可以使用 `detach()` 方法来分离线程，或者让 `std::thread` 对象超出作用域自动销毁。

```
t.detach();
```





## detach() 和 join()

| 操作       | 作用说明                           | 资源管理方式                   |
| ---------- | ---------------------------------- | ------------------------------ |
| `join()`   | 主线程**等待**子线程执行完成       | 线程资源由主线程清理           |
| `detach()` | 主线程**不等待**子线程，放它自由跑 | 子线程自己清理资源（后台线程） |

**主线程**（Main Thread）是 C++ 程序中最先执行的那条线程，也就是**从 `main()` 函数开始运行**的那条线程。

**子线程**是程序运行过程中**由主线程或其他线程手动创建的线程**。

**示例**

~~~c++
#include <iostream>
#include <thread>
#include <chrono>

void task() {
    std::this_thread::sleep_for(std::chrono::seconds(2));
    std::cout << "子线程完成任务\n";
}

~~~

**使用`join()`**

~~~c++
int main() {
    std::thread t(task);
    
    t.join();  // 等待子线程跑完
    std::cout << "主线程继续执行\n";
}
// 主线程 等子线程执行完毕后 才继续执行

// 输出
（等待 2 秒）
子线程完成任务
主线程继续执行
~~~

**使用`detach()`**

~~~c++
int main() {
    std::thread t(task);
    t.detach();  // 不等，直接分离
    std::cout << "主线程继续执行\n";
}

// 主线程 不等子线程，子线程后台自己跑

// 输出
主线程继续执行
（稍后）子线程完成任务

~~~

主线程和子线程在 **不同的 CPU 核心或时间片上并发运行**，互不阻塞。即使主线程先退出，**子线程还是照常完成任务**，因为它已经“脱离”主线程的生命周期了。





## atomic

### atomic原子类型

在多线程程序中，**如果多个线程同时访问并修改同一个普通变量**，就会发生**竞态条件（race condition）**，导致程序行为不确定。

为解决这个问题，传统方法是使用 `mutex` 加锁，而 `std::atomic` 提供了一个**更高效的替代方案**，**不需要锁就能安全操作变量**。

C++11 标准引入了 `<atomic>` 库，它提供了一组**原子操作**，用于保证**在多线程环境下，对共享数据的访问是原子的，即不可分割的**。这可以避免数据竞争和保证线程安全。

> **原子操作**是指在执行过程中**不会被其他线程中断**的操作。在多线程环境下，原子操作要么完全执行，要么完全不执行，不会出现中间状态。

`std::atomic` **能保证多个线程在同时访问变量时**，**不会互相打扰**，每次操作都是“**一步到位**”的，不会被中途打断。

**常见的原子类型**

| 类型                  | 说明             |
| --------------------- | ---------------- |
| `std::atomic<int>`    | 原子化的整数     |
| `std::atomic<bool>`   | 原子化的布尔值   |
| `std::atomic<size_t>` | 原子化的计数类型 |
| `std::atomic<T*>`     | 原子化的指针类型 |

**示例：在多线程环境中安全的更新一个共享计数器**

~~~c++
#include <iostream>
#include <atomic>
#include <thread>

std::atomic<int> counter(0); // 初始化原子计数器

void increment() {
    for (int i = 0; i < 10000; ++i) {
        counter++;
    }
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);
    t1.join();
    t2.join();

    std::cout << "Counter = " << counter << std::endl;  // 理论输出 20000
}
~~~

如果不用 `atomic`，可能输出不是 20000，因为两个线程竞争修改 `counter`。使用 `std::atomic<int>` 可确保每次修改是安全的。

**Thread.h中**

~~~c++
static std::atomic_int numCreated_; // 记录全局创建的线程数，每创建一个Thread，计数+1
~~~

在 C++ 标准库中， `std::atomic_int` 是通过 `typedef`（或 `using`）定义的 **类型别名**，它等价于：

~~~c++
typedef std::atomic<int> atomic_int;
// 或者 
using atomic_int = std::atomic<int>;
~~~



C++ 标准库中为了方便，也定义了多个**原子类型的别名**，例如：

| 别名                | 等价于                      |
| ------------------- | --------------------------- |
| `std::atomic_bool`  | `std::atomic<bool>`         |
| `std::atomic_int`   | `std::atomic<int>`          |
| `std::atomic_long`  | `std::atomic<long>`         |
| `std::atomic_llong` | `std::atomic<long long>`    |
| `std::atomic_uint`  | `std::atomic<unsigned int>` |



### fetch_add(1)方法

`fetch_add(1)` 是 C++ 原子类型（如 `std::atomic<int>`) 提供的原子操作方法。

表示**以原子方式将当前值加上指定值，并返回加之前的旧值**。

在`TcpServer::start()`中：

~~~C++
if (started_.fetch_add(1) == 0)
~~~

这里 `started_` 是一个 `std::atomic_int`，`fetch_add(1)` 表示：

- 将`started_`加1
- 返回加之前的值
- 所有操作都是线程安全的原子操作

用于 **只允许首次执行某段初始化逻辑**：

- 如果旧值是0，说明是第一次调用`start()`，应该进入if执行
- 如果旧值不是0， 说明之前`started_`已经加1了，已经执行过一次了，不再执行





## 信号量sem

**什么是信号量？**

是一个用来**控制协调多个线程访问共享资源**（同步和互斥）的 **“计数器” 机制**，防止出现数据竞争和资源冲突。

可以理解为线程之间用来同步的一种工具，资源计数器。所以其实是 “**信号计数量**”。

>  **首先是一个变量，其次是计数器。**

信号量在**创建时需要设置一个初始值**，表示**同时可以有几个任务（线程）可以访问**某一块共享资源。

- 一个任务要想访问共享资源，需要信号量大于0；
- 当该任务成功获得资源后，将信号量的值减 1；
- 当任务执行完之后，必须释放信号量，对应操作就是信号量的值加 1。

- 若当前信号量的值小于 0，表明无法获得信号量，该任务必须被挂起，等待信号量恢复为正值的那一刻；

另外，对信号量的操作（加、减）都是原子的。

**声明信号量**

`sem_t` 是 POSIX 信号量的数据类型，用于表示一个信号量对象（适用于Linux/UNIX下的多线程）

包含在头文件`<semaphore.h>`中。

~~~C++
#include <semaphore.h>
sem_t sem;// 声明一个信号量
~~~

**初始化信号量 `sem_init()`**

~~~C++
int sem_init(sem_t* sem, int pshared, unsigned int value);

// sem		信号量变量（的地址）
// pshared	是否在进程间共享，
// 			设为 0 表示仅用于线程间共享（同一个进程内）；1 表示可以进程间共享(需要放在共享内存中)
// value	信号量的初始值（比如资源数量、允许进入线程数）
~~~

**等待信号量（P 操作）`sem_wait()`**

~~~C++
int sem_wait(sem_t* sem);

// 用于等待某个资源或条件就绪
// 如果信号量的值 > 0，执行成功，同时信号量减 1；
// 如果值 = 0，当前线程阻塞，等待别人释放信号量。
~~~

**释放信号量（V 操作）`sem_post()`**

~~~C++
int sem_post(sem_t* sem);

// 信号量的值加 1；
// 如果有线程在 sem_wait 阻塞，它会被唤醒
~~~

**销毁信号量`sem_destory()`**

~~~C++
int sem_destory(sem_t* sem);

// 清理资源
// 一般在线程退出、或程序结束前调用
~~~











# end
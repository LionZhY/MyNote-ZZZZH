> 力扣hot100总结，主要参考[代码随想录](https://programmercarl.com/)和力扣题解区各位大神的题解以及gpt
>
> 完结啦 🎉🎉🎉



# 哈希 ✅

> ***需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法***

## 1 [两数之和](https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked)

@哈希 @数组

![image-20250601163055315](pic/image-20250601163055315.png)

遍历数组，需要一个集合**存放【遍历过的元素】**，在遍历数组nums的时候，同时去这个组合中寻找，某元素【 target - 当前遍历元素 nums[i] 】是否出现过。

因为最后要找到这个元素是否出现过，还需要得到这个元素的下标，需要使用key-value结构存放：

**< key: 元素nums[i]， value：下标 i >**

判断元素是否出现过，那么元素就要作为key，通过元素找下标，下标作为value。

> std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。
>
> std::map 和std::multimap 的key也是有序的,**这道题目中并不需要key有序，选择std::unordered_map 效率更高！** 



![image-20250601171032968](pic/image-20250601171032968.png)

~~~C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        
        // unordered_map 不重复 无序key 存放遍历过的元素
        unordered_map<int, int> umap; // < nums[i], 下标 i>

        for (int i = 0; i < nums.size(); i++)
        {
            //find 查找 target - nums[i] 在不在 umap中
            if (umap.find(target - nums[i]) != umap.end()) 
            {
                return {umap[target - nums[i]], i}; // 找到，直接返回下标数组
            }
            umap.insert(pair<int, int>(nums[i], i));// 没找到，就存到umap里
        }

        return {}; // 没符合条件的，返回空数组
        
    }
};
~~~

时间复杂度：O(N)

空间复杂度：O(N)



**ACM** 

~~~C++
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

vector<int> twoSum(vector<int>& nums, int target)
{
	unordered_map<int, int> umap;
	for (int i = 0; i < nums.size(); i++)
	{
		if (umap.find(target - nums[i]) != umap.end())
		{
			return { umap[target - nums[i]], i };
		}
		umap.insert(pair<int, int>(nums[i], i));
	}
	
	return {};
}

int main() {
	int n, target; // 数组长度n，目标值target
	cin >> n >> target;
	vector<int> nums(n);

	for (int i = 0; i < n; i++) {
		cin >> nums[i]; // 输入数组元素
	}

	vector<int> result = twoSum(nums, target);

	if (!result.empty()) {
		cout << result[0] << " " << result[1] << endl;
	}
	else {
		cout << "No result" << endl;
	}

	return 0;

}
~~~

 示例输入：

~~~C++
4 9
2 7 11 15
~~~

示例输出：

~~~C++
0 1
~~~



## [49 字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250603102842280](pic/image-20250603102842280.png)

![image-20250603103135066](pic/image-20250603103135066.png)

![image-20250603104320749](pic/image-20250603104320749.png)



~~~C++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {

        // 哈希 
        // key: 排序后的字符串（异位词排序后结果相同）
        // value: 原始字符串组成的列表（属于同一组的异位词组合）--> 即答案

        unordered_map<string, vector<string>> umap;

        for (string& s : strs)
        {
            // 排序strs中每一个字符串
            string sorted_s = s;
            ranges::sort(sorted_s);// 按照ASCII值排序s，排序后异位词会变成相同的字符串

            // sorted_s 相同的原字符串，归到一组
            umap[sorted_s].push_back(s);
        }

        // 整理返回的字符串数组
        vector<vector<string>> ans;
        ans.reserve(umap.size()); // 预分配空间

        for (auto& [_, value] : umap) // 遍历umap，解构umap，只关心value的值
        {
            ans.push_back(value); // 每个分组列表加入结果
        }

        return ans;    
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <vector>
#include <string>
#include <unordered_map>
#include <algorithm>

using namespace std;

vector<vector<string>> groupAnagrams(const vector<string>& strs)
{
    unordered_map<string, vector<string>> umap;

    for (const string& s : strs)
    {
        string sorted_s = s;
        // 排序 分组
        sort(sorted_s.begin(), sorted_s.end()); // 或者ranges::sort(sorted_s);
        umap[sorted_s].push_back(s);
    }

    vector<vector<string>> ans;
    ans.reserve(umap.size());
    for (auto& [_, value] : umap) 
    {
        ans.push_back(value);
    }

    return ans;
}

int main()
{
    int n; // 字符串数量
    cin >> n;
    vector<string> inputStr(n); // 字符串
    for (int i = 0; i < n; i++)
    {
        cin >> inputStr[i];
    }

    // 调用函数
    vector<vector<string>> result = groupAnagrams(inputStr);

    // 输出
    for (const auto& group : result)
    {
        for (const string& word : group)
        {
            cout << word << " ";
        }
        cout << endl;
    }

    return 0;
}
~~~

示例输入：

~~~C++
6
eat tea tan ate nat bat
~~~

示例输出：

~~~C++
eat tea ate 
tan nat 
bat 
~~~



## [128 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&envId=top-100-liked)

![image-20250604104439319](pic/image-20250604104439319.png)

![image-20250604104627175](pic/image-20250604104627175.png)

`contains()` 是 C++20 引入的成员函数，用于判断某个元素是否存在于关联容器中。

将数组 nums 中的所有元素存入一个哈希集合 st，这样可以在 **O(1)** 时间内判断某个数是否存在。

![image-20250604104849078](pic/image-20250604104849078.png)

~~~C++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {

        int ans = 0;

        // 把nums转成哈希集合 （无序不重复）
        unordered_set<int> st(nums.begin(), nums.end());

        // 注意：这里遍历的是集合，不是原数组
        for (int x : st)
        {
            // 如果 x-1 在集合中，说明 x 不是某个连续序列的起点，跳过
            if (st.contains(x - 1))
            {
                continue;
            }

            // x 是序列的起点
            int y = x + 1;
            while (st.contains(y)) // 不断向后查找下一个数是否在哈希集合中
            {
                y++;
            }

            // 一直找知道找不到下一个连续的数为止，此时的 y 是第一个不在集合中的数
            // y - 1 就是最后一个在哈希集合中的数

            // 更新长度
            ans = max(ans, y - x); // [x, y-1]是一个连续序列，长度是 y - x
        }

        return ans;
    }
};
~~~

ACM 模式：

~~~C++
#include <vector>
#include <unordered_set>
#include <iostream>
#include <algorithm>


int longestConsecutive(const std::vector<int>& nums)
{
    int ans = 0;

    std::unordered_set<int> st(nums.begin(), nums.end()); // 无序不重复
    for (int x : st)
    {
        // 如果 x 不是连续序列的起点，跳过
        if (st.find(x - 1) != st.end())
        {
            continue;
        }
        // x 是连续序列的起点，不断向后寻找下一个数
        int y = x + 1;
        while (st.find(y) != st.end())
        {
            y++;
        }

        ans = std::max(ans, y - x); // 更新连续序列最大长度
    }

    return ans;
}


int main()
{
    int n;
    std::cin >> n; // 输入数字个数

    std::vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        std::cin >> nums[i]; // 输入数组 nums
    }

    int result = longestConsecutive(nums);
    std::cout << result << std::endl;

    return 0;
}
~~~



# 双指针 ✅

## [283 移动零（快慢指针）](https://leetcode.cn/problems/move-zeroes/?envType=study-plan-v2&envId=top-100-liked)

@快慢指针

![image-20250608105541481](pic/image-20250608105541481.png)



**和 27、移除元素 相同，多一步slow及slow之后置零**

~~~C++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // 快慢指针

        int slowIndex = 0;
        int fastIndex = 0;

        for (fastIndex = 0; fastIndex < nums.size(); fastIndex++)
        {
            if (nums[fastIndex] != 0)
            {
                nums[slowIndex++] = nums[fastIndex]; // 覆盖 0
            }
        }

        // 将slowIndex及slowIndex之后的元素都置零
        for (int i = slowIndex; i < nums.size(); i++)
        {
            nums[i] = 0;
        }

    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <vector>

using namespace std;

void moveZero(vector<int>& nums)
{
    int slowIndex = 0;
    int fastIndex = 0;

    for (fastIndex = 0; fastIndex < nums.size(); fastIndex++)
    {
        if (nums[fastIndex] != 0)
        {
            nums[slowIndex++] = nums[fastIndex]; // 原地向前覆盖0
        }
    }

    for (int i = slowIndex; i < nums.size(); i++)
    {
        nums[i] = 0;
    }
}


int main() 
{
    int n;
    cin >> n; // 输入数组个数

    vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i]; // 输入数组元素
    }

    moveZero(nums); // 移动 0

    for (int i = 0; i < n; i++)
    {
        cout << nums[i] << " "; // 输出移动0后的nums
    }
    cout << endl;

    return 0;
}
~~~

示例输入：

~~~C++
6
0 1 0 3 12 0
~~~

输出：

~~~C++
1 3 12 0 0 0
~~~





## [11 盛最多水的容器（收缩）](https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250609102202043](pic/image-20250609102202043.png)

![image-20250609103156207](pic/image-20250609103156207.png)



~~~C++
class Solution {
public:
    int maxArea(vector<int>& height) {

        // 双指针 收缩
        
        int ans = 0;

        int left = 0;
        int right = height.size() - 1;

        while(left < right) // 只要 left < right 就还能构成矩形面积
        {
            int area = (right - left) * min(height[left], height[right]); // 矩形面积
            ans = max(ans, area); // ans保持最大值

            // 移动短边
            height[left] < height[right] ? left++ : right--;

            // 因为短边能构成的最大的面积，就是area
        }
        
        return ans;
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <vector>

using namespace std;

int maxArea(vector<int>& height)
{
    int ans = 0;

    int left = 0;
    int right = height.size() - 1;

    while (left < right)
    {
        int area = (right - left) * min(height[left], height[right]);
        ans = max(ans, area);

        // 移动短边
        height[left] < height[right] ? left++ : right--;
    }

    return ans;
}

int main()
{
    int n;
    cin >> n; // height数组长度（柱子数量）

    vector<int> height(n);
    for (int i = 0; i < n; i++)
    {
        cin >> height[i]; // 输入每根柱子的高度
    }

    int result = maxArea(height);
    cout << result << endl; // 输出最大盛水面积

    return 0;
}
~~~

示例输入：

~~~C++
9
1 8 6 2 5 4 8 3 7
~~~

输出：

~~~C++
49
~~~



## [15 三数之和（收缩）](https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&envId=top-100-liked)

@双指针收缩

![image-20250609112752426](pic/image-20250609112752426.png)



双指针收缩，大了往左，小了往右

<img src="pic/image-20250609112849338.png" alt="image-20250609112849338" style="zoom:50%;" />

![image-20250609112912089](pic/image-20250609112912089.png)



![image-20250609113009075](pic/image-20250609113009075.png)

![image-20250610101954614](pic/image-20250610101954614.png)



~~~C++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {

        // 先排序nums
        sort(nums.begin(), nums.end());
        
        vector<vector<int>> result;
        
        for (int i = 0; i < nums.size(); i++)
        {
            // 排序后第一个元素已经大于0，不可能凑成三元组
            if (nums[i] > 0)    break;
            
            // 去重 a
            // 如果i和i-1元素相同，说明后面遍历组合的三数之和在nums[i-1]的时候被组合过了，跳过
            if (i > 0 && nums[i] == nums[i - 1])    continue;

            // a = nums[i]  b = nums[left]  c = nums[right]   固定i，移动left right
            int left = i + 1;
            int right = nums.size() - 1;
            while(left < right) 
            {
                // 三数之和 > 0，right向左移动，让和变小
                if (nums[i] + nums[left] + nums[right] > 0) right--;
                
                // 三数之和 < 0，left向右移动，让和变大
                else if (nums[i] + nums[left] + nums[right] < 0) left++;
                
                // 三数之和 = 0，找到一个三元组
                else 
                {
                    // 收集三元组
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    
                    // 去重b和c，向里收缩
                    while (right > left && nums[right] == nums[right - 1])	right--;
                    while (right > left && nums[left] == nums[left + 1])	left++;
                    
                    // 找到一组三元组后，left和right同时向里收缩，寻找下一组
                    right--;
                    left++;
                }
                
            }
        }

        return result;        
    }
};
~~~

时间复杂度：*O*(*n*2)

空间复杂度：O(1)



ACM

~~~C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<vector<int>> threeSum(vector<int>& nums) 
{
    vector<vector<int>> result;
    
    // 排序nums
    sort(nums.begin(), nums.end());

    // a = nums[i]  b = nums[left]   c = nums[right]
    for (int i = 0; i < nums.size(); i++)
    {
        // 排序后第一个元素已经大于0，不可能凑成三元组
        if (nums[i] > 0)    break;
        
        // 去重 a
        if (i > 0 && nums[i] == nums[i - 1])    continue;

        // 移动left right 判断三数之和
        int left = i + 1;
        int right = nums.size() - 1;
        while(left < right)
        {
            if (nums[i] + nums[left] + nums[right] > 0) right--;
            else if (nums[i] + nums[left] + nums[right] < 0) left++;
            else // 三数之和 = 0，找到一个三元组
            {
                // 收集三元组
                result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                // 去重b和c，向里收缩
                while (right > left && nums[right] == nums[right - 1])
                {
                    right--;
                }
                while (right > left && nums[left] == nums[left + 1])
                {
                    left++;
                }
                // 找到一组三元组后，left和right同时向里收缩，寻找下一组
                right--;
                left++;
            }
        }
    }
    return result;        
}


int main()
{
    int n;
    cin >> n; // nums数组长度

    vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i]; // 输入nums数组
    }

    vector<vector<int>> result = threeSum(nums);

    for (int i = 0; i < result.size(); i++)
    {
        for (int j = 0; j < result[i].size(); j++)
        {
            cout << result[i][j] << " ";
        }
        cout << endl;
    }
    
    return 0;
}
~~~





## 42 [接雨水](https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-100-liked)

@前缀和 @双指针收缩

![image-20250610110445823](pic/image-20250610110445823.png)

### 1、前后缀分离

分割成每个 height[i] 一块，把每块看成是宽度是1，高度为 height[i] 的水桶，能盛多少水，**取决于左右两边挡板的短板有多高**，也就是当前height[i]**前后的最高高度取较小值**。

<img src="pic/image-20250610114059789.png" alt="image-20250610114059789" style="zoom:50%;" />

<img src="pic/image-20250610113706432.png" alt="image-20250610113706432" style="zoom: 50%;" />

height[i] 的**【左边最高高度，右边最高高度】取最小值**，再**减去 height[i]** 就是当前这个块能盛的水的高度，也即面积（底部宽度为1）。

~~~C++
ans += min(pre_max[i], suf_max[i]) - height[i]; // 每块的面积，宽度是1
~~~

~~~C++
class Solution {
public:
    int trap(vector<int>& height) {
        
        // 前后缀分离
		// 时间复杂度 O(n)   空间复杂度 O(n)
        int n = height.size();

        // 从 height[0] 到 height[i] 的最大值，从前向后
        vector<int> pre_max(n); 
        pre_max[0] = height[0];
        for (int i = 1; i < n; i++)	pre_max[i] = max(pre_max[i - 1], height[i]);
        
        // 从 height[n-1] 到 height[i] 的最大值，从后向前
        vector<int> suf_max(n); 
        suf_max[n - 1] = height[n - 1];
        for (int i = n - 2; i >= 0; i--)	suf_max[i] = max(suf_max[i + 1], height[i]);
        

        int ans = 0;
        for (int i = 0; i < n; i++)
        {
            // 取 前缀后缀的较小值 - height[i] 作为当前盛水的高度
            ans += min(pre_max[i], suf_max[i]) - height[i]; // 每块的面积，宽度是1
        }

        return ans;
    }
};
~~~



ACM：

~~~C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int trap(vector<int>& height) 
{
    int n = height.size();

    // 前缀最大值
    vector<int> pre_max(n);
    pre_max[0] = height[0];
    for (int i = 1; i < n; i++)
    {
        pre_max[i] = max(pre_max[i - 1], height[i]);
    }
    // 后缀最大值
    vector<int> suf_max(n);
    suf_max[n - 1] = height[n - 1];
    for (int i = n - 2; i >= 0; i--)
    {
        suf_max[i] = max(suf_max[i + 1], height[i]);
    }

    int ans = 0;
    for (int i = 0; i < n; i++)
    {
        ans += min(suf_max[i], pre_max[i]) - height[i]; // 累加面积
    }
    return ans;
    
}

int main()
{
    int n;
    cin >> n; // 输入height长度

    vector<int> height(n);
    for (int i = 0; i < n; i++)
    {
        cin >> height[i]; // 输入height数组
    }

    int result = trap(height);
    cout << result << endl;

    return 0;
}
~~~

示例输入：

~~~C++
12
0 1 0 2 1 0 1 3 2 1 2 1
~~~

输出：

~~~C++
6
~~~





### 2、相向双指针

<img src="pic/image-20250612104513382.png" alt="image-20250612104513382" style="zoom: 50%;" />

**总结：**接水多少由**短的木板**决定，left right指针向中间收缩

接水的高度由前缀最大值和后缀最大值中的**较小值**决定，左右指针谁小谁移动，相遇位置会是最高

- 如果**前缀最大值 < 后缀最大值**，这个木桶的容量就是**前缀最大值-height[left]**，算完之后left指针**向右**；
- 如果**后缀最大值 < 前缀最大值**，这个木桶的容量就是**后缀最大值-height[right]**，算完之后right指针**向左**

~~~C++
class Solution {
public:
    int trap(vector<int>& height) {

        // 相向双指针
        // 时间复杂度 O(n)   空间复杂度 O(1)
        int ans = 0;

        int left = 0, right = height.size() - 1; // 左右指针，向中间移动

        int pre_max = 0, suf_max = 0; // 前后缀最大值

        while (left < right) // 可以不加等号，因为在「谁小移动谁」的规则下，相遇的位置一定是最高的柱子，这个柱子是无法接水的
        {
            pre_max = max(pre_max, height[left]);
            suf_max = max(suf_max, height[right]);

            // 找能确定的较短的柱子
            if (pre_max < suf_max)
            {
                ans += pre_max - height[left];
                left++; 
            }
            else
            {
                ans += suf_max - height[right];
                right--;
            }
        }

        return ans;        
    }
};
~~~





# 滑动窗口 ✅

## 3 [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-100-liked)

@滑动窗口

![image-20250616162717463](pic/image-20250616162717463.png)

![image-20250616163704232](pic/image-20250616163704232.png)

![image-20250616163714515](pic/image-20250616163714515.png)



~~~C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {

        int n = s.size();
        int ans = 0; // 窗口长度，即最长不重复子串长度

        // 窗口 [left, right]
        int left = 0;
        int right = 0;

        unordered_map<char, int> cnt; // cnt <出现的字符，字符出现的次数>

        for (right = 0; right < n; right++) // right++, 窗口右移
        { 
            char c = s[right];
            cnt[c]++; // 遇到的字符，次数+1

            // cnt[c] > 1 说明有重复字符
            while (cnt[c] > 1)
            {
                cnt[s[left]]--; // 左边界收缩，去除一个左边界字符的数量
                left++; // 缩小窗口
            }

            ans = max(ans, right - left + 1); // 更新窗口长度最大值
        }

        return ans;    
    }
};
~~~



ACM 

~~~C++
#include <iostream>
#include <string>
#include <unordered_map>

using namespace std;

int lengthOfLongestSubstring(const string& s)
{
    int ans = 0;

    int left = 0; 
    int right = 0;

    unordered_map<char, int> cnt; // <字符，字符出现次数>

    for (right = 0; right < s.size(); right++)
    {
        char c = s[right];
        cnt[c]++; // 统计字符出现次数

        while (cnt[c] > 1)
        {
            cnt[s[left]]--;
            left++;
        }

        ans = max(ans, right - left + 1);
    }

    return ans;
}

int main()
{
    string s;
    cin >> s; // 输入字符串

    int result = lengthOfLongestSubstring(s);
    cout << result << endl;

    return 0;
}
~~~

示例输入：

~~~C++
abcabcbb
~~~

输出：

~~~C++
3
~~~





## 438 [找到字符串中所有的字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked)

@滑动窗口

![image-20250617110241918](pic/image-20250617110241918.png)

![image-20250617112439541](pic/image-20250617112439541.png)



### 1、定长窗口（推荐）

![image-20250617112250564](pic/image-20250617112250564.png)

![image-20250617112552844](pic/image-20250617112552844.png)

<img src="pic/image-20250617114503142.png" alt="image-20250617114503142" style="zoom: 33%;" />

~~~C++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) { // s = "cbaebabacd", p = "abc"

        // 定长滑动窗口s'  窗口长度是p.size()

        vector<int> ans;

        vector<int> cnt_p(26); // p 中的每个字母出现次数
        vector<int> cnt_s(26); // 窗口子串 s'的每个字母出现次数

        for (char c : p)
        {
            cnt_p[c - 'a']++; // 字母对应下标位置的数++
        }

        for (int right = 0; right < s.size(); right++) // 右边界++
        {
            cnt_s[s[right] - 'a']++; // 右边界字母进入窗口 s'
            int left = right - p.size() + 1;// 左边界 窗口长度是p.size()

            // 窗口长度不够p.size() 跳过
            if (left < 0)   continue; 

            // s'和 p 的每种字母出现次数相同，收集结果
            if (cnt_s == cnt_p)
            {
                ans.push_back(left); // s'的左边界下标加入结果
            }

            cnt_s[s[left] - 'a']--; // 接下来进入下一组s', 左边界字母离开窗口，次数--
        }

        return ans;  
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <string>
#include <iostream>

using namespace std;

// s = "cbaebabacd", p = "abc"
vector<int> findAnagrams(const string& s, const string& p)
{
    vector<int> ans;

    vector<int> cnt_s(26);
    vector<int> cnt_p(26);

    for (char c : p)
    {
        cnt_p[c - 'a']++;
    }

    for (int right = 0; right < s.size(); right++)
    {
        cnt_s[s[right] - 'a']++;
        int left = right - p.size() + 1;

        if(left < 0)    continue;

        if (cnt_s == cnt_p)
        {
            ans.push_back(left);
        }

        cnt_s[s[left] - 'a']--;
    }

    return ans;
}


int main()
{
    string s;
    string p;
    cin >> s >> p; // 输入字符串 s p

    vector<int> result = findAnagrams(s, p);
    for (int idx : result)
    {
        cout << idx << " ";
    }
    cout << endl;
    
    return 0;
}
~~~

示例输入：

~~~C++
cbaebabacd abc
~~~

输出：

~~~C++
0 6
~~~





### 2、变长窗口

![image-20250617163418441](pic/image-20250617163418441.png)

![image-20250617162142140](pic/image-20250617162142140.png)

![image-20250617162148186](pic/image-20250617162148186.png)



~~~C++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) { // s = "cbaebabacd", p = "abc"

        // 不定长窗口

        vector<int> ans;

        vector<int> cnt(26); // 统计字母，合并了 cnt_s 和 cnt_p

        for (char c : p)
        {
            cnt[c - 'a']++;
        }

        int left = 0;
        for (int right = 0; right < s.size(); right++)
        {
            int c = s[right] - 'a';
            cnt[c]--; // 右端字符进入窗口，消去对应字符在cnt中的个数

            // 窗口里cnt[c]对应字符消去太多了，超过了p的需求，收缩左边界，直到cnt>=0
            while (cnt[c] < 0)
            {
                cnt[s[left] - 'a']++; // 左端点离开，次数再补给cnt
                left++;
            }

            // 因为当出现不属于p的字符，或者字符重复时，窗口已经被上面的while处理了
            // 根本到不了 窗口长度 = p.size() 这一步

            // 所以只要遇到 窗口长度 = p.size()，就说明当前窗口找到了结果
            if (right - left + 1 == p.size())
            {
                ans.push_back(left);
            }
        }

        return ans;
    }
};
~~~















# 子串 ✅

## [560 和为k的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked)

@前缀和

![image-20250617175344196](pic/image-20250617175344196.png)

**子数组的和可以由==两个前缀和之差==表示**

<img src="pic/image-20250617231427634.png" alt="image-20250617231427634" style="zoom:50%;" />

<img src="pic/image-20250617231437509.png" alt="image-20250617231437509" style="zoom:50%;" />

<img src="pic/image-20250617231448024.png" alt="image-20250617231448024" style="zoom:50%;" />

<img src="pic/image-20250617231502464.png" alt="image-20250617231502464" style="zoom:50%;" />

![image-20250617231510992](pic/image-20250617231510992.png)

![image-20250617232228785](pic/image-20250617232228785.png)

~~~C++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {

        int n = nums.size();
        vector<int> s(n + 1); // 前缀和 s[i] = nums[0] + ... + nums[i - 1]
        for (int i = 0; i < n; i++)
        {
            s[i + 1] = s[i] + nums[i];
        }

        // s[j] - s[i] = nums区间[i, j-1]的和
        // 题意找这个区间和是k的，有几个这样的区间
        // 就是找有几个 s[j] - s[i] = k ==> s[i] = s[j] - k

        int ans = 0;
        unordered_map<int, int> cnt; // <s[i], s[i]出现次数>

        // 注意！！！遍历的是前缀和 s
        for (int sj : s)
        {
            // 如果有 sj - k 在cnt出现过，说明存在 si = sj - k，把 sj - k 出现过的次数都加到ans上
            ans += cnt.contains(sj - k) ? cnt[sj - k] : 0;
            cnt[sj]++; // cnt中当前sj的次数+1
        }
        
        return ans;
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <unordered_map>
#include <iostream>

using namespace std;

int subarraySum(const vector<int>& nums, int k)
{
    int n = nums.size();

    vector<int> s(n + 1, 0); // 前缀和
    for (int i = 0; i < n; i++)
    {
        s[i + 1] = s[i] + nums[i];
    }

    // s[j] - s[i] = k => s[i] = s[j] - k

    int ans = 0;
    unordered_map<int, int> cnt; // <s[i], s[i]出现的次数>
    for (int sj : s)
    {
        if (cnt.count(sj - k))
        {
            ans += cnt[sj - k];
        }
        cnt[sj]++;
    }
    
    return ans;
}


int main() 
{
    int n, k;
    cin >> n >> k; // 输入nums长度 和 k

    vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i]; // 输入nums
    }

    int result = subarraySum(nums, k);
    cout << result << endl;

    return 0;
}
~~~

示例输入：

~~~C++
3 2
1 1 1
~~~

输出：

~~~C++
2
~~~







## [239 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&envId=top-100-liked)

@单调队列

![image-20250620153953637](pic/image-20250620153953637.png)



<img src="pic/image-20250620160701011.png" alt="image-20250620160701011" style="zoom:80%;" />

<img src="pic/image-20250620160836709.png" alt="image-20250620160836709" style="zoom:80%;" />

<img src="pic/image-20250620160921994.png" alt="image-20250620160921994" style="zoom:80%;" />

![239.滑动窗口最大值-2](pic/239.滑动窗口最大值-2.gif)

![image-20250620153818438](pic/image-20250620153818438.png)

![image-20250620154103490](pic/image-20250620154103490.png)



~~~C++
class Solution {
private:
    // deque实现单调队列 从大到小
    class MyQueue
    {
    public:
        deque<int> que; // 使用deque实现单调队列

        // push
        void push(int value)
        {
            // 即将放进que的value > back入口数值，就将que后端的数值弹出，直到value < 入口
            // 保证队列前面都是比value大的值，才能从大到小
            while (!que.empty() && value > que.back())  que.pop_back();
            que.push_back(value);
        }

        // pop
        void pop(int value)
        {
            // 每次pop比较要弹出的数值，是否等于que出口的数值，如果相等则弹出
            if (!que.empty() && value == que.front())   que.pop_front();
        }

        // getMaxvalue 查询当前队列里的最大值，直接返回que的front
        int getMax()
        {
            return que.front();
        }
    };


public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {

        vector<int> result;

        MyQueue que; // 创建单调队列
        
        // 前k个元素（第一个窗口）放入que
        for (int i = 0; i < k; i++)
        {
            que.push(nums[i]); // push的时候已经保证了单调
        }
        result.push_back(que.getMax()); // result 记录第一个窗口最大值

        // 继续计算后面的窗口
        for (int i = k; i < nums.size(); i++)
        {
            que.pop(nums[i - k]); // 移动窗口，pop出que中当前窗口的第一个元素
            que.push(nums[i]); // 新元素push进新窗口

            result.push_back(que.getMax()); // 记录当前窗口内的最大值
        }
        
        return result;
        
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <deque>
#include <vector>

using namespace std;

// 单调队列类
class MyQueue
{
public:
    deque<int> que;
    
    // push 保证从大到小
    void push(int value)
    {
        while (!que.empty() && value > que.back()) // 如果value > que.back() 就弹出原来较小的back
        {
            que.pop_back();
        }
        que.push_back(value); // 新值放进去，队列前面是比value大的值，才能从大到小
    }

    // pop 窗口滑出元素与队头相等时弹出
    void pop(int value)
    {
        if (!que.empty() && value == que.front())
        {
            que.pop_front();
        }
    }

    // getMax 返回当前窗口的最大值（就是队列的front）
    int getMax()
    {
        return que.front();
    }

};

// 返回滑动窗口中的最大值
vector<int> maxSlidingWindow(const vector<int>& nums, int k)
{
    vector<int> result;
    MyQueue que;

    // 初始化前k个元素（第一个窗口）
    for (int i = 0; i < k; i++)
    {
        que.push(nums[i]);
    }
    result.push_back(que.getMax());

    // 开始滑动窗口
    for (int i = k; i < nums.size(); i++)
    {
        que.pop(nums[i - k]);
        que.push(nums[i]);
        result.push_back(que.getMax());
    }

    return result;
}

int main()
{
    int n, k;
    cin >> n >> k; // 输入nums元素个数，和窗口大小k

    vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i]; // 输入nums元素
    }

    vector<int> ans = maxSlidingWindow(nums, k);
    for (int x : ans)
    {
        cout << x << " ";
    }
    cout << endl;

    return 0;
}
~~~

示例输入：

~~~C++
8 3 
1 3 -1 -3 5 3 6 7
~~~

输出：

~~~C++
3 3 5 5 6 7 
~~~





## 76 [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/?envType=study-plan-v2&envId=top-100-liked)

@滑动窗口

![image-20250621115145749](pic/image-20250621115145749.png)		

![image-20250621115156244](pic/image-20250621115156244.png)

![image-20250622103406601](pic/image-20250622103406601.png)

![image-20250621115208025](pic/image-20250621115208025.png)

![image-20250621115228527](pic/image-20250621115228527.png)



~~~C++
class Solution {
public:
    // 判断子串是否覆盖（字母出现次数）
    bool is_covered(int cnt_s[], int cnt_t[]) 
    {
        for (int i = 'A'; i <= 'Z'; i++)
        {
            if (cnt_s[i] < cnt_t[i])
            {
                return false;
            }
        }

        for (int i = 'a'; i <= 'z'; i++)
        {
            if (cnt_s[i] < cnt_t[i])
            {
                return false;
            }
        }
        
        return true;
    }

    string minWindow(string s, string t) {
        
        int m = s.length();

        int ans_left = -1, ans_right = m; // 最短子串的左右端点

        int cnt_s[128]{}; // s 子串字母的出现次数
        int cnt_t[128]{}; // t 中字母的出现次数
        for (char c : t)
        {
            cnt_t[c]++;
        }

        // 遍历 s
        int left = 0;
        for (int right = 0; right < m; right++)
        {
            cnt_s[s[right]]++; // 右端点字母移入子串
            
            while (is_covered(cnt_s, cnt_t)) // s子串涵盖t
            {
                if (right - left < ans_right - ans_left) // 当前子串更短，更新端点
                {
                    ans_left = left;
                    ans_right = right; 
                }

                cnt_s[s[left]]--; // 左端点字母移出子串
                left++;
            }
        }

        // 返回子串
        return ans_left < 0 ? "" : s.substr(ans_left, ans_right - ans_left + 1);
        
    }
};
~~~



ACM

~~~C++
#include <string>
#include <iostream>

using namespace std;

// 判断子串是否覆盖 t 中所有字符
bool is_covered(int cnt_s[], int cnt_t[])
{
    for (int i = 'A'; i <= 'Z'; i++) 
    {
        if (cnt_s[i] < cnt_t[i]) return false;
    }

    for (int i = 'a'; i <= 'z'; i++) 
    {
        if (cnt_s[i] < cnt_t[i]) return false;
    }

    return true;
}

// 求最小覆盖子串
string minWindow(const string& s, const string& t)
{
    int m = s.length();

    int ans_left = -1, ans_right = m;

    int cnt_s[128] = {0};
    int cnt_t[128] = {0};
    for (char c : t)
    {
        cnt_t[c]++;
    }

    // 遍历 s
    int left = 0;
    for (int right = 0; right < m; right++)
    {
        cnt_s[s[right]]++;

        // 如果符合覆盖，更新最短子串端点，左移left
        while (is_covered(cnt_s, cnt_t))
        {
            if (right - left < ans_right - ans_left)
            {
                ans_left = left;
                ans_right = right;
            }

            cnt_s[s[left]]--;
            left++;
        }
    }

    return (ans_left < 0) ? "" : s.substr(ans_left, ans_right - ans_left + 1);
}


int main()
{
    string s, t;
    cin >> s >> t;

    string result = minWindow(s, t);
    cout << result << endl;

    return 0;
}
~~~

示例输入：

~~~C++
ADOBECODEBANC ABC
~~~

输出：

~~~C++
BANC
~~~



# 普通数组 ✅



## 53 [最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked)

@动态规划 @贪心

![image-20250622105708128](pic/image-20250622105708128.png)



### 贪心

<img src="pic/image-20250622110414358.png" alt="image-20250622110414358" style="zoom:50%;" />

![53.最大子序和](pic/53.最大子序和.gif)

~~~C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {

        // 贪心

        // 注意找的只是 【最大和】，没让找子数组

        // 主要思路：负数只会拖累加和，所以遇到和变成负的，舍弃，负的只会减小后面的加和
        
        int result = INT32_MIN;
        int count = 0;

        // 记录连续和count，如果count < 0，舍弃，再从下一个数开始计和
        for (int i = 0; i < nums.size(); i++)
        {
            count += nums[i];
            result = max(count, result); // 更新result，取大的count
            
            if (count <= 0)	count = 0; // 舍弃，从下一个数nums[i + 1]重新加和
        }

        return result;
    }
};
~~~



### 动态规划

![image-20250622110929679](pic/image-20250622110929679.png)

<img src="pic/20210303104129101.png" alt="53.最大子序和（动态规划）" style="zoom:50%;" />



~~~C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        
        if (nums.size() == 0)   return 0;
        
        // 动态规划

        // dp[i] - 以nums[i]结尾(包括)的最大连续子序列和为dp[i]
        vector<int> dp(nums.size());

        // 初始化
        dp[0] = nums[0];

        int result = dp[0];

        // 递推
        for (int i = 1; i < nums.size(); i++)
        {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]);// 两种推出dp[i]的方式，取max

            if (dp[i] > result) result = dp[i]; // 取dp[i]的最大值返回
        }

        return result;  
    }
};
~~~





ACM

~~~C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdint>

using namespace std;

// 力扣53 最大子数组和

/**************  动态规划 *****************/ 
// int maxSubArray(const vector<int>& nums)
// {
//     if (nums.size() == 0)   return 0;

//     // 动态规划
//     vector<int> dp(nums.size()); // 以nums[i]结尾(包括)的最大连续子序列和为dp[i]
//     dp[0] = nums[0];

//     int result = dp[0];

//     for (int i = 1; i < nums.size(); i++)
//     {
//         dp[i] = max(dp[i - 1] + nums[i], nums[i]);
//         result = max(result, dp[i]);
//     }

//     return result;
// }


/**************  贪心 *****************/ 
int maxSubArray(const vector<int>& nums)
{
    int result = INT32_MIN;
    int count = 0;

    // 记录连续和count，如果count < 0，舍弃，再从下一个数开始计和 (负的只会减小后面的加和)
    for (int i = 0; i < nums.size(); i++)
    {
        count += nums[i];
        if (result < count) result = count;
        if (count <= 0)  count = 0; // 舍弃，从下一个数nums[i + 1]重新加和
    }

    return result;
}


int main()
{
    int n;
    cin >> n; // 输入数组元素个数

    vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i]; // 输入数组
    }

    int result = maxSubArray(nums);
    cout << result << endl;

    return 0;
}

~~~

示例输入：

~~~shell
9
-2 1 -3 4 -1 2 1 -5 4
~~~

输出：

~~~shell
6 #对应 [4, -1, 2, 1]
~~~





## 56 [合并区间](https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked)

@贪心

![image-20250623104644609](pic/image-20250623104644609.png)

<img src="pic/image-20250623104950499.png" alt="image-20250623104950499" style="zoom: 50%;" />



<img src="pic/image-20250623105338164.png" alt="image-20250623105338164" style="zoom:40%;" />



<img src="pic/image-20250623105441129.png" alt="image-20250623105441129" style="zoom:50%;" />

~~~C++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {

        if (intervals.size() == 0)  return intervals;

        // 先按左边界排序，从小到大 (lambda)
        sort(intervals.begin(), intervals.end(),
                [](const vector<int>& a, const vector<int>& b) {return a[0] < b[0];} );

        vector<vector<int>> result;
        result.push_back(intervals[0]); // 第一个区间放进result
        for (int i = 1; i < intervals.size(); i++)
        {
            // 有重叠，更新前一个范围的右边界 
            if (intervals[i][0] <= result.back()[1]) // 需要<=，边界重叠也算
            {
                // 更新右边界，要比较取较大值，不能直接取新的intervals[i][1]
                result.back()[1] = max(result.back()[1], intervals[i][1]); 
            }
            // 无重叠，直接放进result
            else 
            {
                result.push_back(intervals[i]);
            }
        }

        return result;  
    }
};
~~~



lambda表达式：

~~~C++
  // 先按左边界排序，从小到大 (lambda)
  sort(intervals.begin(), intervals.end(),
          [](const vector<int>& a, const vector<int>& b) {return a[0] < b[0];});
~~~

如果用仿函数：

~~~C++
class Solution {
public:
    // 仿函数
    static bool cmp (const vector<int>& a, const vector<int>& b)
    {
        return a[0] < b[0];
    }

    vector<vector<int>> merge(vector<vector<int>>& intervals) {

        if (intervals.size() == 0)  return intervals;

        // 先按左边界排序，从小到大 (lambda)
        sort(intervals.begin(), intervals.end(), cmp); // 替换成 cmp
		
        // ...
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<vector<int>> merge(vector<vector<int>>& intervals)
{
    if (intervals.size() == 0)  return intervals;

    // 按左边界排序 从小到大
    sort(intervals.begin(), intervals.end(),
        [](const vector<int>& a, const vector<int>& b) {return a[0] < b[0];} );

    vector<vector<int>> result;
    result.push_back(intervals[0]);
    for (int i = 1; i < intervals.size(); i++)
    {
        if (result.back()[1] >= intervals[i][0]) // 有重叠，更新右边界
        {
            result.back()[1] = max(result.back()[1], intervals[i][1]);
        }
        else // 无重叠，直接放进result
        {
            result.push_back(intervals[i]);
        }
    }

    return result;
}


int main()
{
    int n;
    cin >> n; // intervals数组元素个数 (区间个数)

    vector<vector<int>> intervals(n, vector<int>(2));
    for (int i = 0; i < n; i++)
    {
        cin >> intervals[i][0] >> intervals[i][1];// 输入每个区间左右端点
    }

    vector<vector<int>> result = merge(intervals);
    for (const auto& interval : result)
    {
        cout << interval[0] << " " << interval[1] << endl;
    }

    return 0;
}
~~~

示例输入：

~~~C++
4
1 3
2 6
8 10
15 18
~~~

输出：

~~~C++
1 6
8 10
15 18
~~~









## [189 轮转数组](https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250623163553318](pic/image-20250623163553318.png)

~~~C++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        // [1,2,3,4,5,6,7] k = 3

        k = k % nums.size(); // 如果 k 超过nums.size()的话

        reverse(nums.begin(), nums.end());      // 整体反转      [7,6,5,4,3,2,1]
        reverse(nums.begin(), nums.begin() + k);// 反转前k个     [5,6,7,4,3,2,1]
        reverse(nums.begin() + k, nums.end());  // 反转k+1到最后 [5,6,7,1,2,3,4]
        
    }
};
~~~

![image-20250623163609915](pic/image-20250623163609915.png)



ACM

~~~c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;


// 轮转数组函数
void rotate(vector<int>& nums, int k)
{
    if (nums.size() == 0)   return;

    k = k % nums.size();

    // 三次反转
    reverse(nums.begin(), nums.end());
    reverse(nums.begin(), nums.begin() + k);
    reverse(nums.begin() + k, nums.end());
}


int main()
{
    int n, k;
    cin >> n >> k; // 输入数组长度 和轮转步数k

    vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i]; // 输入数组元素
    }

    rotate(nums, k);

    for (int x : nums)
    {
        cout << x << " ";
    }
    cout << endl;

    return 0;
}
~~~

示例输入：

~~~c++
7 3
1 2 3 4 5 6 7
~~~

输出：
~~~
5 6 7 1 2 3 4
~~~



## [238 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked)

@前缀@后缀乘积

![image-20250624105932275](pic/image-20250624105932275.png)

![image-20250624110050465](pic/image-20250624110050465.png)

~~~C++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {

        // nums[i]前的乘积 * nums[i]后的乘积

        int n = nums.size();

        // nums[i]前的乘积  nums[0]*nums[1]*...*nums[i-1]
        vector<int> pre(n, 1);
        for (int i = 1; i < n; i++)
        {
            pre[i] = pre[i - 1] * nums[i - 1];
        }

        // nums[i]后的乘积 nums[i+1]*nums[i+2]*...*nums[n-1]
        vector<int> suf(n, 1);
        for (int i = n - 2; i >= 0; i--)
        {
            suf[i] = suf[i + 1] * nums[i + 1]; // 从后向前乘
        }

        vector<int> ans(n);
        for (int i = 0; i < n; i++)
        {
            ans[i] = pre[i] * suf[i];
        }

        return ans;
    }
};
~~~



![image-20250624110818200](pic/image-20250624110818200.png)

~~~C++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {

        // nums[i]前的乘积 * nums[i]后的乘积

        // 优化

        int n = nums.size();

        vector<int> suf(n);
        suf[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--)
        {
            suf[i] = suf[i + 1] * nums[i + 1];
        }

        int pre = 1;
        for (int i = 0; i < n; i++)
        {
            // 此时 pre 为 nums[0] 到 nums[i-1] 的乘积，直接乘到 suf[i] 中
            suf[i] *= pre;
            pre *= nums[i];
        }

        return suf; // suf已经乘上了pre，就是ans
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <vector>

using namespace std;


vector<int> productExceptSelf(const vector<int>& nums)
{
    int n = nums.size();

    // nums[i]前的乘积 * nums[i]后的乘积

    // pre[i] = nums[0]*nums[1]*...*nums[i-1]
    vector<int> pre(n, 1);
    for (int i = 1; i < n; i++)
    {
        pre[i] = pre[i - 1] * nums[i - 1];
    }

    // suf[i] = nums[i+1]*nums[i+2]*...*nums[n-1]
    vector<int> suf(n, 1);
    for (int i = n - 2; i >= 0; i--)
    {
        suf[i]  = suf[i + 1] * nums[i + 1]; // 从后向前乘
    }

    vector<int> ans(n);
    for (int i = 0; i < n; i++)
    {
        ans[i] = pre[i] * suf[i];
    }

    return ans;
}


int main()
{
    int n;
    cin >> n;// nums元素个数

    vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i];// 输入数组
    }

    vector<int> result = productExceptSelf(nums);
    for (int x : result)
    {
        cout << x << " ";
    }
    cout << endl;

    return 0;
}
~~~

示例输入：

~~~C++
4
1 2 3 4
~~~

输出：

~~~C++
24 12 8 6
~~~



## [41 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&envId=top-100-liked)

@哈希

![image-20250625101823232](pic/image-20250625101823232.png)



https://leetcode.cn/problems/first-missing-positive/solutions/7703/tong-pai-xu-python-dai-ma-by-liweiwei1419

本题的难点在：只能使用常数级别的额外空间，在这个限制下本题的思路有一个非正式的名称：**原地哈希**。

![image-20250625102204090](pic/image-20250625102204090.png)

![image-20250625102219196](pic/image-20250625102219196.png)

![image-20250625110120087](pic/image-20250625110120087.png)

![image-20250625102516136](pic/image-20250625102516136.png)



![image-20250625110017460](pic/image-20250625110017460.png)

~~~C++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {

        // 如果不缺失正数：下标i的位置，放的应该是i+1，即nums[i] = i + 1
        // nums = [1, 2, 3, 4, ...]
        // 下标    0  1  2  3 ...

        // 当下标 i 位置的数，不是 i+1 时(nums[i] != i + 1)，i+1 就是缺失的最小正数

        // 注意是把数放到正确位置，数找位置，而不是位置找数！！！


        // 遍历nums，给每个nums[i]找正确的位置
        for (int i = 0; i < nums.size(); i++)
        {
            // 给nums[i]找位置，交换后的nums[i]可能位置也不对，所以while直到位置正确
            while (nums[i] != i + 1)
            {
                if (nums[i] <= 0 ||               // 负数或0
                    nums[i] > nums.size() ||      // 超过数组长度的数
                    nums[i] == nums[nums[i] - 1]) // nums[i]重复，nums[i]该在的位置已经有正确的数了
                {
                    break; // 这三种情况不移动
                }

                // 将nums[i]放到对应位置（即交换 nums[i] 与 nums[nums[i] - 1]）
                int idx = nums[i] - 1;
                swap(nums[i], nums[idx]); 
            }
        }


        // 查找第一个不满足 nums[i] == i + 1 的位置
        for (int i = 0; i < nums.size(); i++)
        {
            if (nums[i] != i + 1)   return i + 1;
        }

        // 如果所有都相符，缺少的就是最后一个数的下一个 [1, 2, 3, 4, ..., n-1]  n = nums.size()
        return (nums.size() + 1);
        
    }
};
~~~





ACM

~~~C++
#include <iostream>
#include <vector>

using namespace std;


int firstMissingPositive(vector<int>& nums)
{
    int n = nums.size();

    // 把每个数放到正确的位置上（即 nums[i] 应该在 下标为nums[i] - 1 位置上）
    for (int i = 0; i < n; i++)
    {
        while (nums[i] != i + 1)
        {
            if (nums[i] < 0 || nums[i] > n || nums[i] == nums[nums[i] - 1]) 
            {
                break; // 非法数字或重复，不处理
            }

            // 把nums[i]交换到正确位置
            int idx = nums[i] - 1;
            swap(nums[i], nums[idx]);
        }
    }

    // 查找第一个不满足 nums[i] == i + 1 的位置
    for (int i = 0; i < n; i++)
    {
        if (nums[i] != i + 1)   return i + 1;
    }

    // 所有都满足，返回 n + 1
    return n + 1;
}

int main()
{
    int n;
    cin >> n; // 输入nums元素个数

    vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i]; // 输入数组
    }

    int result = firstMissingPositive(nums);
    cout << result << endl;

}
~~~

示例输入：

~~~C++
5
3 4 -1 1 2
~~~

输出：

~~~C++
5
~~~



# 矩阵 ✅



## [73 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250626113039919](pic/image-20250626113039919.png)

![image-20250626162610999](pic/image-20250626162610999.png)

![image-20250626162624915](pic/image-20250626162624915.png)

![image-20250626162915024](pic/image-20250626162915024.png)

~~~C++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {

        if (matrix.size() == 0) return;

        const int m = matrix.size();    // 有几行
        const int n = matrix[0].size(); // 有几列

        bool firstRow = false; // 记录第一行是否有0
        bool firstCol = false; // 记录第一列是否有0

        // 遍历所有元素，将 0 所在行列的第一个元素（即第一行和第一列的元素置零）
        for (int i = 0; i < m; i++) // 行
        {
            for (int j = 0; j < n; j++)
            {
                const int item = matrix[i][j];
                if (item == 0) 
                {
                    if (i == 0) firstRow = true; // 如果是第一行的元素是0，记录
                    if (j == 0) firstCol = true; // 如果是第一列的元素是0，记录

                    // 将对应第一行第一列的元素置零，作为修改其他行列的标志
                    matrix[0][j] = 0;
                    matrix[i][0] = 0;
                }
            }
        }

        // 再根据第一行和第一列的数，置零其他行列的元素
        for (int i = 1; i < m; i++)
        {
            for (int j = 1; j < n; j++)
            {
                const int item = matrix[i][j];
                // 如果当前元素所在行列的第一行或第一列中有0，则置零当前元素
                if (matrix[0][j] == 0 || matrix[i][0] == 0)
                {
                    matrix[i][j] = 0;
                }
            }
        }

        
        // 最后修改第一行 第一列（如果第一行或第一列中有0）
        if (firstRow) 
        {
            for (int j = 0; j < n; j++)
            {
                matrix[0][j] = 0; // 第一行全部置零
            }
        }
        if (firstCol)
        {
            for (int i = 0; i < m; i++)
            {
                matrix[i][0] = 0; // 第一列全部置零
            }
        }

    }
};
~~~



ACM 

~~~C++
#include <vector>
#include <iostream>

using namespace std;


// 原地将矩阵中包含0的行列全置0
void setZeroes(vector<vector<int>>& matrix)
{
    if (matrix.size() == 0) return;

    const int m = matrix.size();    // 行数
    const int n = matrix[0].size(); // 列数

    bool firstRow = false; // 第一行是否包含0
    bool firstCol = false; // 第一列是否包含0

    // 标记行列
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (matrix[i][j] == 0)
            {
                if (i == 0) firstRow = true; // 第一行的元素
                if (j == 0) firstCol = true; // 第一列的元素
                matrix[0][j] = 0; // 标记列
                matrix[i][0] = 0; // 标记行
            }
        }
    }

     // 遍历非首行首列，使用首行首列的0标记清零
     for (int i = 1; i < m; i++)
     {
        for (int j = 1; j < n; j++)
        {
            if (matrix[0][j] == 0 || matrix[i][0] == 0)     matrix[i][j] = 0;
        }
     }

     // 根据 firstRow firstCol 处理第一行和第一列
     if (firstRow)
     {
        for (int j = 0; j < n; j++)
        {
            matrix[0][j] = 0;
        }
     }
     if (firstCol)
     {
        for (int i = 0; i < m; i++)
        {
            matrix[i][0] = 0;
        }
     }

}



int main()
{
    int m, n;
    cin >> m >> n; // 输入行列数

    vector<vector<int>> matrix(m, vector<int>(n));
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            cin >> matrix[i][j]; // 输入矩阵
        }
    }

    cout << endl;
    
    setZeroes(matrix);
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            cout << matrix[i][j] << " "; // 输出结果
        }
        cout << endl;
    }

    return 0;
}
~~~



示例输入：

~~~C++
3 4
1 1 1 0
1 0 1 1
1 1 1 1
~~~

输出

~~~C++
0 0 0 0
0 0 0 0
1 0 1 0
~~~





## [螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250627114210513](pic/image-20250627114210513.png)



### 1、标记 + 方向数组

![image-20250627114220015](pic/image-20250627114220015.png)

![image-20250627114225565](pic/image-20250627114225565.png)

![image-20250627114235868](pic/image-20250627114235868.png)

~~~C++
class Solution {
	// 方向数组，注意顺序！！！！
    static constexpr int DIRS[4][2] = {
        {0, 1},   // 向右
        {1, 0},   // 向下
        {0, -1},  // 向左
        {-1, 0}   // 向上
	};

public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size();    // 行数
        int n = matrix[0].size(); // 列数

        vector<int> ans(m * n);

        int i = 0, j = 0, di = 0; // 初始行号，列号，前进方向
        for (int k = 0 ; k < m * n; k++) // 一共走m*n步，收集m*n个数据为止
        {
            ans[k] = matrix[i][j];  // 收集
            matrix[i][j] = INT_MAX; // 标记，表示已经访问过，加入到ans里

            // (x, y) 是下一步的位置，前进方向是 DIRS[i]
            int x = i + DIRS[di][0]; // 移动，行号 + DIRS[di][0]
            int y = j + DIRS[di][1]; // 移动，列号 + DIRS[di][1]

            // 先判断 (x, y) 是否出界或者已经访问过
            if (x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] == INT_MAX)
            {
                di = (di + 1) % 4; // 右转90度
            }

            // 确定下一个位置
            i += DIRS[di][0]; 
            j += DIRS[di][1];
        }

        return ans;       
    }
};
~~~



`constexpr`是 C++11 引入的一个关键字，用来声明“常量表达式”。它的核心作用是：**在编译期就能确定结果**。



### 2、收缩边界

![image-20250627114331643](pic/image-20250627114331643.png)



~~~C++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {

        vector <int> ans;
        if(matrix.empty()) return ans; //若数组为空，直接返回答案

        int u = 0; //赋值上下左右边界
        int d = matrix.size() - 1;
        int l = 0;
        int r = matrix[0].size() - 1;

        while(true)
        {
            // 向右移动直到最右
            for(int i = l; i <= r; ++i) ans.push_back(matrix[u][i]);
            if(++ u > d) break; //重新设定上边界，若上边界大于下边界，则遍历完成，下同
            
            // 向下
            for(int i = u; i <= d; ++i) ans.push_back(matrix[i][r]); 
            if(-- r < l) break; //重新设定右边界

            // 向左
            for(int i = r; i >= l; --i) ans.push_back(matrix[d][i]); 
            if(-- d < u) break; //重新设定下边界

            // 向上
            for(int i = d; i >= u; --i) ans.push_back(matrix[i][l]); 
            if(++ l > r) break; //重新设定左边界
        }


        return ans;
    }
};
~~~

**`++u` 先自增，再比较**

~~~C++
if (++u > d) 
~~~







ACM 

~~~C++
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

static constexpr int DIRS[4][2] = {
    {0, 1},   // 向右
    {1, 0},   // 向下
    {0, -1},  // 向左
    {-1, 0}   // 向上
};

// 返回矩阵的螺旋遍历顺序
vector<int> spiralOrder(vector<vector<int>>& matrix) {
    int m = matrix.size();        // 行数
    int n = matrix[0].size();     // 列数
    vector<int> ans(m * n);

    int i = 0, j = 0, di = 0;     // 当前坐标 (i, j)，方向索引 di

    for (int k = 0; k < m * n; k++) {
        ans[k] = matrix[i][j];      // 收集当前元素
        matrix[i][j] = INT_MAX;     // 标记访问

        int x = i + DIRS[di][0];    // 下一行
        int y = j + DIRS[di][1];    // 下一列

        // 出界或已访问，右转
        if (x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] == INT_MAX) {
            di = (di + 1) % 4;
        }

        i += DIRS[di][0];
        j += DIRS[di][1];
    }

    return ans;
}

int main() {
    int m, n;
    cin >> m >> n; // 输入矩阵行列数

    vector<vector<int>> matrix(m, vector<int>(n));
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            cin >> matrix[i][j];
        }
    }

    vector<int> result = spiralOrder(matrix);
    for (int x : result) {
        cout << x << " ";
    }
    cout << endl;

    return 0;
}
~~~

示例输入：

~~~C++
3 3
1 2 3
4 5 6
7 8 9
~~~

输出：

~~~C++
1 2 3 6 9 8 7 4 5
~~~



## [48 旋转图像](https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250628113029036](pic/image-20250628113029036.png)

![image-20250628113058397](pic/image-20250628113058397.png)

![image-20250628113104568](pic/image-20250628113104568.png)



~~~C++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {

        // 两次翻转：(i,j) --> (j,i) --> (j,n−1−i)
        // - 转置：按照主对角线翻转， (i,j) --> (j,i)
        // - 行翻转：每一行的内部元素对称翻转，(j,i) --> (j,n−1−i)

        int n = matrix.size();

        // 第一步：主对角线翻转 (i, j) --> (j, i)
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < i; j++) // 找主对角线下方的元素
            {
                swap(matrix[i][j], matrix[j][i]);
            }
        }

        // 第二步：行内对称翻转 (i, j) --> (i,n−1−j) 注意下标是i还是j！！！
        for (auto& row : matrix)
        {
            ranges::reverse(row); // 或者reverse(row.begin(), row.end());
        }
   
    }
};

        // 第二步如果直接写普通循环  （注意下标是i还是j！！！）
        // for (int i = 0; i < n; i++)
        // {
        //     for (int j = 0; j < (n/2); j++)
        //     {
        //         swap(matrix[i][j], matrix[i][n - 1 -j]);
        //     }
        // }
        // 
        // 或者 （推荐）
        // for (int i = 0; i < matrix.size(); i++) 
        // {
        //     int left = 0;
        //     int right = matrix[i].size() - 1;
        //     while (left < right) 
        //     {
        //         swap(matrix[i][left], matrix[i][right]);
        //         left++;
        //         right--;
        //     }
        // }


~~~



ACM：

~~~C++
#include <iostream>
#include <vector>
#include <algorithm> // for std::swap, std::ranges::reverse

using namespace std;

// 将矩阵原地顺时针旋转90度
void rotate(vector<vector<int>>& matrix) {
    int n = matrix.size();

    // 第一步：主对角线翻转 (i, j) -> (j, i)
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < i; j++) {
            swap(matrix[i][j], matrix[j][i]);
        }
    }

    // 第二步：每行左右翻转 (j, i) -> (j, n-1-i)
    for (auto& row : matrix) {
        reverse(row.begin(), row.end());  // 使用 std::reverse 替代 ranges::reverse
    }
}

int main() {
    int n;
    cin >> n; // 输入矩阵大小（n x n）

    vector<vector<int>> matrix(n, vector<int>(n));
    for (int i = 0; i < n; i++) 
    {
        for (int j = 0; j < n; j++) 
        {
            cin >> matrix[i][j]; // 输入矩阵
        }
    }

    rotate(matrix);

    // 输出旋转后的矩阵
    for (const auto& row : matrix) 
    {
        for (int x : row) 
        {
            cout << x << " ";
        }
        cout << endl;
    }

    return 0;
}

~~~

输入：

~~~C++
3
1 2 3
4 5 6
7 8 9
~~~

输出：

~~~C++
7 4 1
8 5 2
9 6 3
~~~



## 240 搜索二维矩阵II

![image-20250629105356412](pic/image-20250629105356412.png)

依旧是灵神！！！

![image-20250629105411464](pic/image-20250629105411464.png)

![image-20250629105431219](pic/image-20250629105431219.png)



~~~C++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {

        // 比较右上角，target大删行，target小删列

        int m = matrix.size(), n = matrix[0].size();
        
        int i = 0, j = n - 1; // 右上角

        while (i < m && j >= 0)
        {
            if (target == matrix[i][j]) return true; // 找到
            
            if (target > matrix[i][j])  i++; // target大，去下一行
            else                        j--; // target小，去前一列
        }
        
        return false;
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <ratio>
#include <vector>

using namespace std;


bool searchMatrix(vector<vector<int>>& matrix, int target) {

    // 比较右上角，target大删行，target小删列

    int m = matrix.size(), n = matrix[0].size();
    
    int i = 0, j = n - 1; // 右上角

    while (i < m && j >= 0)
    {
        if (target == matrix[i][j]) return true; // 找到
        
        if (target > matrix[i][j])  i++; // target大，去下一行
        else                        j--; // target小，去前一列
    }
    
    return false;
}


int main()
{
    int m, n, target;
    cin >> m >> n >> target; // 输入矩阵行数，列数，目标值

    vector<vector<int>> matrix(m, vector<int>(n));
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            cin >> matrix[i][j]; // 输入矩阵元素
        }
    }

    bool found = searchMatrix(matrix, target);
    cout << (found ? "true" : "false") << endl;


    return 0;
}
~~~

输入：

~~~C++
3 4 5
1 4 7 11
2 5 8 12
3 6 9 16
~~~

输出：

~~~C++
true
~~~





# 链表 ✅

## 基本ACM结构

~~~C++
#include <iostream>
using namespace std;

// 定义单链表结构体
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};


// 工具函数：尾插法构建链表（从 vector<int>）
ListNode* buildList(const vector<int>& nums) 
{
    if (nums.empty()) return nullptr;
    ListNode* head = new ListNode(nums[0]);
    ListNode* cur = head;
    for (int i = 1; i < nums.size(); i++) 
    {
        cur->next = new ListNode(nums[i]);
        cur = cur->next;
    }
    return head;
}

// 工具函数：打印链表
void printList(ListNode* head) 
{
    while (head) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}


// 根据题目需求定义函数，比如反转链表
ListNode* solve(ListNode* head) {
   
}


// 主函数：读取输入，调用逻辑，输出结果
int main() {
    int n;
    cin >> n;  // 输入链表长度
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i]; // 输入每个节点值
    }
    ListNode* head = buildList(nums); // 构建链表

    ListNode* result = solve(head); // 调用题解逻辑
    printList(result); // 输出结果链表

    return 0;
}

~~~

如果不构建工具函数：

~~~C++
#include <iostream>
using namespace std;

// 定义单链表结构体
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};


// 根据题目需求定义函数
ListNode* solve(ListNode* head) {
    
}


int main()
{
    // 直接构建链表
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    ...
    // 执行题目逻辑
    ListNode* result = solve(head);
    
    // 打印
    while (head)
    {
        cout << result->val << endl;
        result = result->next;
    }
    
    return 0;
}
~~~





## 160 [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250630104059221](pic/image-20250630104059221.png)

==**注意是指针相等！！！** **不是数值相等！！**==



### 1、拼接链表（推荐！）

> [Krahets 题解](https://leetcode.cn/problems/intersection-of-two-linked-lists/solutions/12624/intersection-of-two-linked-lists-shuang-zhi-zhen-l/?envType=study-plan-v2&envId=top-100-liked)

- 假设拼接两个链表 分别**BA拼接，AB拼接**，拼接后两链表长度肯定相同
- 如果A和B有相交，则 **BA 和 AB** 的**末尾几位肯定是相同的**
- 这样的两个叠加链表同时遍历到有相同节点的时候，一定一边是A 链表一边是 B 链表
- 相交节点开始到结尾的节点都相同，所以**第一个相同的节点**就是 A 链表和 B 链表的交点

 ![image-20250630105036574](pic/image-20250630105036574.png)



~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {

        ListNode* curA = headA;
        ListNode* curB = headB;
        
        // curA 走 A->B, curB 走 B->A，直到 curA = curB
        while (curA != curB)
        {  
            curA = curA  ? curA->next : headB;// curA走到null，再继续走B，相当于拼接 A->B           
            curB = curB  ? curB->next : headA;// curB走到null，再继续走A，相当于拼接 B->A
        }
        
        return curA; // 最后两个指针重合 curA = curB
        
        // 有交点，返回交点
        // 无交点，curA 和 curB 会一起走到nullptr，返回的也就是 curA = nullptr  
    }
};
~~~



### 2、对齐尾部（常规）

![image-20250906155422786](./pic/image-20250906155422786.png)

<img src="pic/image-20250630104237243.png" alt="image-20250630104237243" style="zoom:30%;" />

![image-20250630104252589](pic/image-20250630104252589.png)

<img src="pic/image-20250630104257026.png" alt="image-20250630104257026" style="zoom:33%;" />

![image-20250630104329816](pic/image-20250630104329816.png)



**注意最后比较的一定是 `curA == curB` ，<span style="color:#CC0000;">节点相等，包括数值相等，内存位置相同</span>**

~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {

        ListNode* curA = headA;
        ListNode* curB = headB;

        // 求链表A和链表B的长度
        int lenA = 0, lenB = 0;
        while (curA != nullptr)
        {
            lenA++;
            curA = curA->next;
        }
        while (curB != nullptr)
        {
            lenB++;
            curB = curB->next;
        }

        // cur再移回头节点
        curA = headA;
        curB = headB;

        // 让curA称为较长链表的头，lenA为其长度
        if (lenB > lenA)
        {
            swap(lenA, lenB);
            swap(curA, curB);
        }

        // 末尾对齐，移动curA到与curB相对应的位置
        int gap = lenA - lenB;
        while (gap--)	curA = curA->next;

        // 然后 curA curB 同时向后移动，遇到相同节点即相交节点
        while (curA != nullptr)
        {
            if (curA == curB)   return curA; // 注意是指针相等，不是数值相等！！！

            curA = curA->next;
            curB = curB->next;
        }

        return nullptr; // 无相交节点
    }
};
~~~



### ACM

~~~C++
#include <iostream>

using namespace std;

struct ListNode
{
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* getIntersectionNode(ListNode* headA, ListNode* headB)
{
    
    ListNode* curA = headA;
    ListNode* curB = headB;

    // 求链表A和链表B的长度
    int lenA = 0, lenB = 0;
    while (curA != nullptr)
    {
        lenA++;
        curA = curA->next;
    }
    while (curB != nullptr)
    {
        lenB++;
        curB = curB->next;
    }

    // cur再移回头节点
    curA = headA;
    curB = headB;

    // 让curA称为较长链表的头，lenA为其长度
    if (lenB > lenA)
    {
        swap(lenA, lenB);
        swap(curA, curB);
    }

    // 末尾对齐，移动curA到与curB相对应的位置
    int gap = lenA - lenB;
    while (gap--)
    {
        curA = curA->next;
    }

    // 然后 curA curB 同时向后移动，遇到相同节点即相交节点
    while (curA != nullptr)
    {
        if (curA == curB)   return curA; // 注意是指针相等，不是数值相等！！！

        curA = curA->next;
        curB = curB->next;
    }

    return nullptr; // 无相交节点
        
}


int main()
{
    // 构建链表 A: 4 -> 1 -> [8 -> 4 -> 5]
    ListNode* a1 = new ListNode(4);
    ListNode* a2 = new ListNode(1);
    ListNode* a3 = new ListNode(8);
    ListNode* a4 = new ListNode(4);
    ListNode* a5 = new ListNode(5);
    a1->next = a2;
    a2->next = a3;
    a3->next = a4;
    a4->next = a5;


    // 构建链表 B: 5 -> 0 -> 1 -> [8 -> 4 -> 5]
    ListNode* b1 = new ListNode(5);
    ListNode* b2 = new ListNode(0);
    ListNode* b3 = new ListNode(1);
    b1->next = b2;
    b2->next = b3;
    b3->next = a3; // 直接连在A中的节点 与链表 A 相交于节点值 8

    ListNode* result = getIntersectionNode(a1, b1);

    if (result) cout << result->val << endl; // 输出相交节点值
    else        cout << "null" << endl;

    
    return 0;
}
~~~

输出：

~~~C++
8
~~~





## 206 [反转链表](https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250701104653159](pic/image-20250701104653159.png)

### 1、双指针

<img src="pic/image-20250701104705438.png" alt="image-20250701104705438" style="zoom:50%;" />

~~~C++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        
        // 双指针

        ListNode* tmp;
        ListNode* cur = head;
        ListNode* pre = nullptr;

        while (cur)
        {
            tmp = cur->next;
            cur->next = pre; // 断开cur和cur->next，反转

            // 后移pre和cur
            pre = cur;
            cur = tmp;
        }

        return pre;// 新的头节点
        
    }
};
~~~



### 2、递归

![image-20250701111833504](pic/image-20250701111833504.png)

![image-20250701112439377](pic/image-20250701112439377.png)

~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 递归 构建reverse函数
    ListNode* reverse(ListNode* pre, ListNode* cur)
    {
        if (cur == nullptr) return pre; // 直到cur = nullptr，返回pre就是新的头节点

        ListNode* tmp = cur->next;
        cur->next = pre; // 反转

        return reverse(cur, tmp); // 相当于 pre = cur, cur = tmp
    }


    ListNode* reverseList(ListNode* head) {
        return reverse(nullptr, head); // 初始 cur = head, pre = nullpt  
    }
};
~~~





### ACM

~~~C++
#include <cstddef>
#include <iostream>
using namespace std;

// 链表结构
struct ListNode
{
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// 反转链表
ListNode* reverseList(ListNode* head)
{
    // 双指针
    ListNode* tmp;
    ListNode* cur = head;
    ListNode* pre = nullptr;

    while (cur)
    {
        tmp = cur->next;
        cur->next = pre;

        pre = cur;
        cur = tmp;
    }

    return pre;
}


int main()
{
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);

    ListNode* result = reverseList(head);

    while (result)
    {
        cout << result->val << endl;
        result = result->next;
    }


    return 0;

}
~~~

输出：

~~~C++
4
3
2
1
~~~





## [234 回文链表](https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250702100234589](pic/image-20250702100234589.png)

### 1、利用数组

~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        
        // 链表值放入数组，再判断数组是否回文
        vector<int> vec;
        ListNode* cur = head;
        while (cur)
        {
            vec.push_back(cur->val);
            cur = cur->next;
        }

        for (int i = 0, j = vec.size() - 1; i < j; i++, j--)
        {
            if (vec[i] != vec[j])   return false;
        }

        return true;    
    }
};
~~~

时间复杂度：*O*(*n*)，其中 *n* 指的是链表的元素个数。

空间复杂度：*O*(*n*)，其中 *n* 指的是链表的元素个数，使用了一个数组列表存放链表的元素值。



### 2、*O*(*1*)空间做法：

> [**灵茶山艾府 O(1) 空间做法：寻找中间节点+反转链表**](https://leetcode.cn/problems/palindrome-linked-list/solutions/2952645/o1-kong-jian-zuo-fa-xun-zhao-zhong-jian-rv0f3/?envType=study-plan-v2&envId=top-100-liked) 

![image-20250702102934665](pic/image-20250702102934665.png)

时间复杂度：O(*n*)，其中 *n* 是链表的长度（节点个数）。

空间复杂度：O(1)。

~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 876 链表的中间节点
    ListNode* middleNode(ListNode* head)
    {
        ListNode* slow = head, *fast = head;
        while (fast && fast->next)
        {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }

    // 206 反转链表
    ListNode* reverseList(ListNode* head)
    {
        ListNode* tmp;
        ListNode* cur = head;
        ListNode* pre = nullptr;
        while (cur)
        {
            tmp = cur->next;
            cur->next = pre;

            pre = cur;
            cur = tmp;
        }
        return pre;
    }


    bool isPalindrome(ListNode* head) {

        // 找中间节点，反转比较

        ListNode* mid = middleNode(head);
        ListNode* head2 = reverseList(mid); // 注意，mid和原链表前面的节点没有断开

        //                                  head                 head2
        // 1 -> 2 -> 3 -> 4 -> 5        =>  1 -> 2 -> 3          5 -> 4 -> 3
        // 1 -> 2 -> 3 -> 4 -> 5 -> 6   =>  1 -> 2 -> 3 - > 4    6 -> 5 -> 4 

        while (head2) // 偶数节点时，head2要比head少一个节点
        {
            if (head->val != head2->val)    return false;

            head = head->next;
            head2 = head2->next;
        }

        return true;     
    }
};
~~~



### ACM

~~~C++
#include <cstddef>
#include <iostream>
using namespace std;

// 234 回文链表：中间节点 + 反转
// 时间复杂度: O(n)
// 空间复杂度: O(1)

// 链表结构定义
struct ListNode
{
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {};
};


// 876 找中间节点
ListNode* middleNode(ListNode* head)
{
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast && fast->next)
    {
        slow = slow->next;
        fast = fast->next->next;
    }

    return slow;
}

// 206 反转链表
ListNode* reverseList(ListNode* head)
{
    ListNode* tmp;
    ListNode* cur = head;
    ListNode* pre = nullptr;

    while (cur)
    {
        tmp = cur->next;
        cur->next = pre;

        pre = cur;
        cur = tmp;
    }

    return pre;
}


// 回文
bool isPalindrome(ListNode* head)
{
    ListNode* mid = middleNode(head);
    ListNode* head2 = reverseList(mid);

    while(head2)
    {
        if (head->val != head2->val)    return false;
        head = head->next;
        head2 = head2->next;
    }

    return true;
}



int main()
{
    int n;
    cin >> n; // 链表长度
    if (n <= 0)
    {
        cout << "false" << endl;
        return 0;
    }

    // 构建链表
    int x;
    cin >> x;
    ListNode* head = new ListNode(x);
    ListNode* cur = head;
    for (int i = 1; i < n; i++)
    {
        cin >> x;
        cur->next = new ListNode(x);
        cur = cur->next;
    }

    bool result = isPalindrome(head);
    cout << (result ? "true" : "false") << endl;

    
    return 0;
}
~~~

输入：

~~~C++
5
1 2 3 2 1
~~~

输出：

~~~C++
true
~~~





## 141 [环形链表](https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-100-liked)

@判断有没有环   @快慢指针

![image-20250702105023599](pic/image-20250702105023599.png)

![image-20250702105039365](pic/image-20250702105039365.png)

<img src="pic/image-20250703111628478.png" alt="image-20250703111628478" style="zoom: 33%;" />



![image-20250702105122723](pic/image-20250702105122723.png)

<img src="pic/image-20250702105136005.png" alt="image-20250702105136005" style="zoom: 50%;" />



- 时间复杂度：O(*n*)，其中 *n* 为链表的长度。
- 空间复杂度：O(1)，仅用到若干额外变量。

~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {

        // 快慢指针
        ListNode* fast = head;
        ListNode* slow = head;

        while (fast && fast->next)
        {
            slow = slow->next;      // slow 走一步
            fast = fast->next->next;// fast 走两步

            if (slow == fast)   return true; // 相遇，说明有环
        }

        return false;
        
    }
};
~~~



ACM

~~~C++
#include <iostream>
using namespace std;

// 141 环形链表 （快慢指针相遇）
// 时间复杂度: O(n)
// 空间复杂度: O(1)

// 定义链表节点结构
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// 判断链表是否有环
bool hasCycle(ListNode* head) 
{
    ListNode* fast = head;
    ListNode* slow = head;
    while (fast && fast->next) 
    {
        slow = slow->next;       // slow 走一步
        fast = fast->next->next; // fast 走两步
        if (slow == fast) return true; // 快慢指针相遇说明有环
    }

    return false;
}


int main() {
    // 构建链表 3 -> 2 -> 0 -> -4
    ListNode* n1 = new ListNode(3);
    ListNode* n2 = new ListNode(2);
    ListNode* n3 = new ListNode(0);
    ListNode* n4 = new ListNode(4);

    n1->next = n2;
    n2->next = n3;
    n3->next = n4;
    n4->next = n2;  // 制造环，使得 -4 指向 2，形成环

    if (hasCycle(n1)) {
        cout << "true" << endl;
    } else {
        cout << "false" << endl;
    }

    return 0;
}
~~~

输出：

~~~C++
true
~~~





## 142 [环形链表II](https://leetcode.cn/problems/linked-list-cycle-ii/description/?envType=study-plan-v2&envId=top-100-liked)

@ 找到入环的节点

![image-20250703110210183](pic/image-20250703110210183.png)

**1、判断是否有环 slow fast**

- slow走1，fast走2
- 如果有环，slow会和fast相遇（并相遇在环中）
- 无环，fast走到nullptr即结束

**2、slow = fast有环，查找入口**

- index1 从相遇点走，走z + n圈
- index2 从head走，走x
- 会在入口相遇

![image-20250703113759595](pic/image-20250703113759595.png)

![image-20250703115139195](pic/image-20250703115139195.png)

![image-20250703114035170](pic/image-20250703114035170.png)



![image-20250703114047706](pic/image-20250703114047706.png)



![image-20250703114815004](pic/image-20250703114815004.png)



~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {

        // 1 是否有环
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next)
        {
            slow = slow->next;
            fast = fast->next->next;

            // 如果没环，fast走到null结束

            // 2 有环，fast = slow  查找入口
            if (slow == fast)
            {
                ListNode* index1 = fast; // 从相遇点开始
                ListNode* index2 = head; // 从头开始

                // index1 和 index2 每次走一步，直到相遇，即入环口
                while (index1 != index2)
                {
                    index1 = index1->next;// 只不过index1会比index2多走几圈
                    index2 = index2->next; 
                }

                return index2; // 返回相遇点，即入口
            }
        }

        return nullptr;
    }
};
~~~









## 21 [合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250704100529835](pic/image-20250704100529835.png)



![image-20250704101318932](pic/image-20250704101318932.png)



![image-20250704101434522](pic/image-20250704101434522.png)



~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {

        ListNode* dummyHead = new ListNode(0);
        ListNode* cur = dummyHead;
        while (list1 && list2)
        {
            if (list1->val < list2->val)
            {
                cur->next = list1; // 取小的节点拼接在cur后面
                list1 = list1->next;
            }
            else
            {
                cur->next = list2;
                list2 = list2->next;
            }

            cur = cur->next;
        }

        // 上面while终止，是由于list1或list2为nullptr
        // 判断是哪个终止了，将另一个链表的剩下部分也拼接上
        cur->next = (list1 != nullptr) ? list1 : list2;

        return dummyHead->next; // 返回真正的头节点
        
    }
};
~~~

时间复杂度 O(M+N) ：M，N是两个链表的长度，合并操作需要操作两链表

空间复杂度 O(1)：节点引用dummyHead，cur使用常数大小的额外空间



ACM

~~~C++
#include <iostream>
using namespace std;

// 21 合并两个有序链表
// 时间复杂度：O(n + m)
// 空间复杂度：O(1)

struct ListNode
{
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// 合并
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2)
{
    ListNode* dummyHead = new ListNode(0);
    ListNode* cur = dummyHead;

    while (list1 && list2)
    {
        if (list1->val < list2->val)
        {
            cur->next = list1;
            list1 = list1->next;
        }
        else 
        {
            cur->next = list2;
            list2 = list2->next;
        }
        
        cur = cur->next;
    }

    cur->next = (list1 != nullptr) ? list1 : list2;

    return dummyHead->next;
}


int main()
{
    // 构建链表 list1: 1 -> 2 -> 4
    ListNode* list1 = new ListNode(1);
    list1->next = new ListNode(2);
    list1->next->next = new ListNode(4);

    // 构建链表 list2: 1 -> 3 -> 4
    ListNode* list2 = new ListNode(1);
    list2->next = new ListNode(3);
    list2->next->next = new ListNode(4);

    // 合并链表
    ListNode* mergeNode = mergeTwoLists(list1, list2);

    // 打印
    while (mergeNode)
    {
        cout << mergeNode->val << " ";
        mergeNode = mergeNode->next;
    }
    cout << endl;

    return 0;
}
~~~





## 2 [两数相加](https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250704104153847](pic/image-20250704104153847.png)

题解：[将链表反过来看](https://leetcode.cn/problems/add-two-numbers/solutions/2826226/jiang-lian-biao-fan-guo-lai-kan-jiu-bu-b-mfhh/?envType=study-plan-v2&envId=top-100-liked)

<img src="pic/image-20250704105742420.png" alt="image-20250704105742420" style="zoom:50%;" />

~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

        ListNode* dummyHead = new ListNode(0);
        ListNode* node = dummyHead;

        int carrier = 0; // 进位

        // 只要2个链表中有没走到尽头的，或者进位不为0，就一直前进
        while (l1 || l2 || carrier)
        {
            // 求和 
            int sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carrier;

            // 在尾部添加新节点
            node->next = new ListNode(sum % 10); // 对10取余（取个位）
            
            // 更新进位
            carrier = sum / 10;

            // 往下走，加下一位
            node = node->next;
            if (l1) l1 = l1->next;
            if (l2) l2 = l2->next;
        }

        return dummyHead->next;        
    }
};
~~~



ACM

~~~C++
#include <iostream>
using namespace std;

// 2 两数之和
// 时间复杂度：O(m + n)
// 空间复杂度：O(1)

struct ListNode
{
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};


ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)
{
    ListNode* dummyHead = new ListNode(0);
    ListNode* node = dummyHead;

    int carrier = 0;
    while (l1 || l2 || carrier)
    {
        int sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carrier;

        node->next = new ListNode(sum % 10);
        carrier = sum / 10;

        node = node->next;
        if (l1)     l1 = l1->next;
        if (l2)     l2 = l2->next;
    }

    return dummyHead->next;
}


int main()
{
    // 构建链表 l1: 2 -> 4 -> 3 （表示数字342）注意顺序
    ListNode* l1 = new ListNode(2);
    l1->next = new ListNode(4);
    l1->next->next = new ListNode(3);

    // 构建链表 l2: 5 -> 6 -> 4 （表示数字465）
    ListNode* l2 = new ListNode(5);
    l2->next = new ListNode(6);
    l2->next->next = new ListNode(4);

    // 相加 
    //      3 <- 4 <- 2 
    // +    4 <- 6 <- 5
    // =    8 <- 0 <- 7
    ListNode* result = addTwoNumbers(l1, l2);

    // 输出
    while (result)
    {
        cout << result->val;
        if (result->next)   cout << "->";
        result = result->next;
    }

    cout << endl;


    return  0;
}
~~~

输出：

~~~C++
7->0->8
~~~





## 19 [删除链表的倒数第N个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250706102933531](pic/image-20250706102933531.png)

![image-20250908112442221](./pic/image-20250908112442221.png)

![image-20250908113223869](./pic/image-20250908113223869.png)

![image-20250908113105100](./pic/image-20250908113105100.png)



~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {

        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;

        ListNode* slow = dummyHead;
        ListNode* fast = dummyHead;

        // fast 先走 n 步，为了保证 fast 和 slow 之间隔着 n 
        while (n--)	fast = fast->next;
            

        // slow 和 fast 一起后移，fast->next 指向null，slow正好指向倒数【第n个节点的前一个】
        while (fast->next != nullptr)
        {
            slow = slow->next;
            fast = fast->next;
        }

        // 跳过原来的slow->next (即倒数第n个节点)
        ListNode* tmp = slow->next;
        slow->next = tmp->next;
        delete tmp;

        return dummyHead->next;
    }
};
~~~

时间复杂度：O(N) N为链表长度
空间复杂度：O(1)



ACM

~~~C++
#include <iostream>
using namespace std;

// 19 删除链表的倒数第n个节点
// 时间复杂度：O(N) N为链表长度
// 空间复杂度：O(1)

struct ListNode
{
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};


ListNode* removeNthFromEnd(ListNode* head, int n)
{
    ListNode* dummyHead = new ListNode(0);
    dummyHead->next = head;

    ListNode* slow = dummyHead;
    ListNode* fast = dummyHead;

    // fast 先走 n + 1 步
    while (n-- && fast)
    {
        fast = fast->next;
    }
    fast = fast->next;
    // for (int i = 0; i <= n; ++i) {
    //    fast = fast->next;
    // }

    // slow 和 fast 一起移动
    while (fast)
    {
        slow = slow->next;
        fast = fast->next;
    }

    // 删除 slow->next
    ListNode* tmp = slow->next;
    slow->next = tmp->next;
    delete tmp;

    return dummyHead->next;
}


int main()
{
    // 构建链表：1 -> 2 -> 3 -> 4 -> 5
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    int n = 2;// 删除倒数第2个

    ListNode* result = removeNthFromEnd(head, n);

    // 输出
    while (result)
    {
        cout << result->val;
        if (result->next)   cout << "->";
        result = result->next;
    }
    cout << endl;


    return 0;
}
~~~

输出：

~~~C++
1->2->3->5
~~~





## [24 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250706172342027](pic/image-20250706172342027.png)



![image-20250706172326114](pic/image-20250706172326114.png)



![image-20250706172407330](pic/image-20250706172407330.png)



~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {

        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;

        ListNode* cur = dummyHead; 

        while (cur->next && cur->next->next)
        {
            ListNode* tmp = cur->next; // 保存原 cur->next
            ListNode* tmp1 = cur->next->next->next; // 保存原cur->next->next->next

            // 交换cur后的两个节点
            cur->next = cur->next->next;
            cur->next->next = tmp;
            cur->next->next->next = tmp1;

            // cur 后移两位
            cur = cur->next->next;
        }

        return dummyHead->next;
        
    }
};
~~~

时间复杂度：O(N) N为链表长度
空间复杂度：O(1)



ACM

~~~C++
#include <iostream>
using namespace std;

// 24 两两交换链表中的节点
// 时间复杂度：O(N) N为链表长度
// 空间复杂度：O(1)

struct ListNode
{
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};


ListNode* swapPairs(ListNode* head)
{
    ListNode* dummyHead = new ListNode(0);
    dummyHead->next = head;

    ListNode* cur = dummyHead;

    while (cur->next && cur->next->next)
    {
        ListNode* tmp = cur->next;
        ListNode* tmp1 = cur->next->next->next;

        // 交换cur后的两个节点
        cur->next = cur->next->next;
        cur->next->next = tmp;
        cur->next->next->next = tmp1;

        // cur 后移两个位置
        cur = cur->next->next;
    }

    return dummyHead->next;
}


int main()
{
    // 构建链表: 1 -> 2 -> 3 -> 4
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);

    ListNode* newHead = swapPairs(head);

    while (newHead)
    {
        cout << newHead->val << " ";
        newHead = newHead->next;
    }
    cout << endl;

    return 0;
}
~~~

输出：
~~~
2 1 4 3 
~~~





## [25 K个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250707112416481](pic/image-20250707112416481.png)

[题解：灵茶山艾府](https://www.bilibili.com/video/BV1sd4y1x7KN/?vd_source=7369d5f08520f2fc3601caee93963ffa)

![image-20250816223459245](./pic/image-20250816223459245.png)

![image-20250816223530333](./pic/image-20250816223530333.png)

![image-20250707112411008](pic/image-20250707112411008.png)

~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {

        // 统计节点个数
        int n = 0;
        ListNode* node = head;
        while (node)
        {
            n++;
            node = node->next;
        }
        
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        
        ListNode* p0 = dummyHead; // p0 作为 [下一组要反转的k个节点的] 上一个节点
        ListNode* pre = nullptr;
        ListNode* cur = head;

        // 剩余节点足够 k 个
        while (n >= k)
        {
            // k 个一组处理
            for (int i = 0; i < k; i++) // 206 普通反转链表
            {
                ListNode* tmp = cur->next;
                cur->next = pre;
                pre = cur;
                cur = tmp;
            }

            // 连接头尾
            ListNode* nxt = p0->next;
            p0->next->next = cur;
            p0->next = pre;
            p0 = nxt; // 更新p0

            // n 更新
            n -= k;
            
            pre = nullptr; // 可以不重置，重置好理解一些
        }

        return dummyHead->next;

    }
};
~~~

- 时间复杂度：O(*n*)，其中 *n* 为链表节点个数。
- 空间复杂度：O(1)，仅用到若干额外变量。



ACM

~~~C++
#include <iostream>
using namespace std;

// 25 k个一组翻转链表
// 时间复杂度：O(n)，其中 n 为链表节点个数。
// 空间复杂度：O(1)，仅用到若干额外变量。

struct ListNode
{
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};


ListNode* reverseKGroup(ListNode* head, int k)
{
    // 统计链表长度
    int n = 0;
    ListNode* node = head;
    while (node)
    {
        n++;
        node = node->next;
    }

    ListNode* dummyHead = new ListNode(0);
    dummyHead->next = head;

    ListNode* p0 = dummyHead; // p0 作为 [下一组要反转的k个节点的] 上一个节点
    ListNode* pre = nullptr;
    ListNode* cur = head;

    while (n >= k)
    {
        // 反转当前这k个节点
        for (int i = 0; i < k; i++)
        {
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }

        // 连接前后
        ListNode* nxt = p0->next;
        p0->next->next = cur;
        p0->next = pre;
        p0 = nxt; // 更新p0

        // 更新 n
        n -= k;

        pre = nullptr; // 可以不重置，重置好理解一些
    
    }

    return dummyHead->next;
}


int main()
{
    // 构建链表: 1 -> 2 -> 3 -> 4 -> 5
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    int k = 2;

    // 执行K个一组翻转
    ListNode* newHead = reverseKGroup(head, k);

    // 输出结果链表
    while (newHead) {
        cout << newHead->val << " ";
        newHead = newHead->next;
    }
    cout << endl;


    return 0;
}
~~~

输出：

~~~C++
2 1 4 3 5 
~~~





## [138 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250708100725736](pic/image-20250708100725736.png)

[题解：Krahets](https://leetcode.cn/problems/copy-list-with-random-pointer/solutions/2361362/138-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-b-6jeo/?envType=study-plan-v2&envId=top-100-liked)

### 1、哈希 <原节点，新节点>

![image-20250708110857618](pic/image-20250708110857618.png)



<img src="pic/image-20250708110826487.png" alt="image-20250708110826487" style="zoom: 50%;" />

<img src="pic/image-20250708110844541.png" alt="image-20250708110844541" style="zoom:50%;" />

~~~C++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;  // random_index：随机指针指向的节点索引
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) {

        if (head == nullptr)    return nullptr;

        Node* cur = head;
        unordered_map<Node*, Node*> umap; // <原节点，新节点>

        // 复制各节点，并建立 “原节点 -> 新节点” 的 Map 映射
        while (cur)
        {
            umap[cur] = new Node(cur->val);
            cur = cur->next;
        }

        // 构建新链表的 next 和 random 指向
        cur = head;
        while (cur)
        {
            umap[cur]->next = umap[cur->next];
            umap[cur]->random = umap[cur->random];
            cur = cur->next;
        }

        // 新的头结点
        return umap[head];
    }
};
~~~

时间复杂度 O(N) ： 两轮遍历链表，使用 O(N) 时间。

空间复杂度 O(N) ： 哈希表 dic 使用线性大小的额外空间。



### 2、拼接 + 拆分

![image-20250708111135198](pic/image-20250708111135198.png)

<img src="pic/image-20250708111154694.png" alt="image-20250708111154694" style="zoom:50%;" />



~~~C++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;  // random_index：随机指针指向的节点索引
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) {

        if (head == nullptr)    return nullptr;

        // 拼接链表 原节点 1 -> 新节点 1 -> 原节点 2 -> 新节点 2 -> ……
        Node* cur = head;
        while (cur)
        {
            Node* tmp = new Node(cur->val);
            tmp->next = cur->next;
            cur->next = tmp;

            cur = tmp->next;
        }

        // 构建各新节点的 random 指向
        cur = head;
        while (cur)
        {
            if (cur->random)
            {
                // 新节点random = 原节点random->next
                cur->next->random = cur->random->next;
            }
            cur = cur->next->next; 
        }

        // 拆分
        Node* pre = head;
        Node* nhead = head->next;
        cur = nhead;
        while (cur->next)
        {
            pre->next = pre->next->next;
            cur->next = cur->next->next;
            pre = pre->next;
            cur = cur->next;
        }

        pre->next = nullptr; // 单独处理原链表尾节点
        return nhead;
    }
};
~~~

时间复杂度 O(N) ： 三轮遍历链表，使用 O(N) 时间。
空间复杂度 O(1) ： 节点引用变量使用常数大小的额外空间。



### ACM

~~~C++
#include <iostream>
#include <unordered_map>
using namespace std;

// 链表节点定义
struct Node {
    int val;
    Node* next;
    Node* random; // random_index：随机指针指向的节点索引

    Node(int _val) : val(_val), next(nullptr), random(nullptr) {}
};


Node* copyRandomList(Node* head)
{
    if (head == nullptr)    return nullptr;

    // umap <原节点，新节点>
    unordered_map<Node*, Node*> umap;
    Node* cur = head;
    while (cur)
    {
        umap[cur] = new Node(cur->val);
        cur = cur->next;
    }

    // 复制 next 和 random 指针
    cur = head;
    while (cur)
    {
        umap[cur]->next = umap[cur->next];
        umap[cur]->random = umap[cur->random];
        cur = cur->next;
    }

    return umap[head];
}


int main()
{
    // 构建链表: 1 -> 2 -> 3
    Node* node1 = new Node(1);
    Node* node2 = new Node(2);
    Node* node3 = new Node(3);
    node1->next = node2;
    node2->next = node3;

    // 设置 random 指针
    node1->random = node3; // 1->random->3
    node2->random = node1; // 2->random->1
    node3->random = node2; // 3->random->2

    Node* copiedHead = copyRandomList(node1);


    // 打印结果（val 和 random->val）
    Node* p = copiedHead;
    while (p) 
    {
        cout << "val: " << p->val;
        if (p->random)
        {
            cout << ", random: " << p->random->val << endl;
        }
        else
        {
            cout << ", random: NULL" << endl;
        }
        p = p->next;
    }

    return 0;
}
~~~

输出：

~~~C++
val: 1, random: 3
val: 2, random: 1
val: 3, random: 2
~~~





## 148 [排序链表](https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250709102737022](pic/image-20250709102737022.png)

灵神题解：[两种方法：分治/迭代，模块化设计，代码可读性高（Python/Java/C++/C/Go/JS/Rust）](https://leetcode.cn/problems/sort-list/solutions/2993518/liang-chong-fang-fa-fen-zhi-die-dai-mo-k-caei/?envType=study-plan-v2&envId=top-100-liked)



### 1、归并排序-分治递归

推荐

![image-20250709110109200](pic/image-20250709110109200.png)

~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 876. 找链表中间节点断开（快慢指针）
    ListNode* middleNode(ListNode* head)
    {
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next && fast->next->next)
        {
            slow = slow->next;// 中间节点的前一个
            fast = fast->next->next;
        }

        ListNode* mid = slow->next;
        slow->next = nullptr; // 断开
        return mid;
    }

    // 21 合并两个有序链表（快慢指针）
    ListNode* mergerTwoLists(ListNode* list1, ListNode* list2)
    {
        ListNode* dummy = new ListNode(0);
        ListNode* cur = dummy;
        while (list1 && list2)
        {
            if (list1->val < list2->val)
            {
                cur->next = list1;
                list1 = list1->next;
            }
            else
            {
                cur->next = list2;
                list2 = list2->next;
            }

            cur = cur->next;
        }

        cur->next = (list1 != nullptr) ? list1 : list2;
        return dummy->next;
    }



    ListNode* sortList(ListNode* head) {

        if (head == nullptr || head->next == nullptr)   return head;

        // 找中点断开
        // 比如 head=[4,2,1,3]，那么 middleNode 调用结束后 head=[4,2] head2=[1,3]
        ListNode* head2 = middleNode(head);

        // 分治 递归 分别排序 head和head2
        head = sortList(head);
        head2 = sortList(head2);
        
        // 合并
        return mergerTwoLists(head, head2);
       
    }
};
~~~

时间复杂度：O(nlogn)，其中 n 是链表长度。递归式 T(n)=2T(n/2)+O(n)，由主定理可得时间复杂度为 O(nlogn)。
空间复杂度：O(logn)。递归需要 O(logn) 的栈开销。





### 2、归并排序-迭代

![image-20250709113112996](pic/image-20250709113112996.png)

两两合并，四四合并，八八合并……

**画图吧**



~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 获取链表长度
    int getLength(ListNode* head)
    {
        int length = 0;
        while (head)
        {
            length++;
            head = head->next;
        }
        return length;
    }

    // 分割链表，分割前size个，返回剩余链表的头结点
    ListNode* splitList(ListNode* head, int size)
    {
        ListNode* cur = head;

        // cur走size步，停在前size个节点的最后一个
        for (int i = 0; i < size - 1 && cur; i++)   cur = cur->next;

        // 链表长度 <= size, 不操作，返回null
        if (cur == nullptr || cur->next == nullptr) return nullptr;

        // 链表长度 >  size，把链表的前size个节点分割出来（断开），返回剩余链表的头结点
        ListNode* next_head = cur->next;
        cur->next = nullptr; // 断开

        return next_head; 
    }

    
    // 21.合并两个有序链表，返回合并后的 <头结点，尾节点>
    pair<ListNode*, ListNode*> mergeTwoLists(ListNode* l1, ListNode* l2)
    {
        ListNode* dummy = new ListNode(0);
        ListNode* cur = dummy;
        while (l1 && l2)
        {
            if (l1->val < l2->val)
            {
                cur->next = l1;
                l1 = l1->next;
            }
            else 
            {
                cur->next = l2;
                l2 = l2->next;
            }
            cur = cur->next;
        }
        cur->next = l1 ? l1 : l2;

        while (cur->next)   cur = cur->next; // 移动cur到尾节点
        return {dummy->next, cur}; // 返回合并后的 <头结点，尾节点>
    }


    ListNode* sortList(ListNode* head) {

        int length = getLength(head);

        ListNode* dummy = new ListNode(0);
        dummy->next = head;

        // step 为步长，即参与合并的链表长度，step = 1, 2, 4, 8, ...
        for (int step = 1; step < length; step *= 2)
        {
            // 从 step = 1 开始：step = 1, 2, 4, 8, ...
            // 每2个【1节点】一组合并，到每2个【2节点】一组合并，再到每2个【4节点】...

            ListNode* new_list_tail = dummy; // 新链表的末尾
            ListNode* cur = dummy->next;

            // 链表每2个step长的部分，分别合并，再拼接，直到cur=null
            while (cur) 
            {
                // 从cur开始，分割出两段长为step的链表
                ListNode* head1 = cur;
                ListNode* head2 = splitList(head1, step);
                cur = splitList(head2, step); // 下一轮循环的起点，head2也断开了

                // 合并两段长为step的链表
                auto [merge_head, merge_tail] = mergeTwoLists(head1, head2);

                // 合并后的头结点head，接到new_list_tail的后面，更新末尾
                new_list_tail->next = merge_head; 
                new_list_tail = merge_tail;
            }

            // cur == nullptr，step = 2 * step，开始下一轮合并            
        }
        

        return dummy->next;
    }
};
~~~

- 时间复杂度：O(*n*log*n*)，其中 *n* 是链表长度。
- 空间复杂度：O(1)。



### ACM

~~~C++
#include <iostream>
using namespace std;

// 148 排序链表
// 时间复杂度：O(nlogn)
// 空间复杂度：O(logn)


struct ListNode 
{
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};



// 找链表的中间节点并断开，返回后一半的头节点
ListNode* middleNode(ListNode* head) 
{
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast->next && fast->next->next) 
    {
        slow = slow->next;
        fast = fast->next->next;
    }

    ListNode* mid = slow->next;
    slow->next = nullptr; // 断开前半部分
    return mid;
}

// 合并两个有序链表
ListNode* mergerTwoLists(ListNode* list1, ListNode* list2) 
{
    ListNode* dummy = new ListNode(0);
    ListNode* cur = dummy;
    while (list1 && list2) 
    {
        if (list1->val < list2->val) 
        {
            cur->next = list1;
            list1 = list1->next;
        } 
        else 
        {
            cur->next = list2;
            list2 = list2->next;
        }
        cur = cur->next;
    }

    cur->next = list1 ? list1 : list2;
    return dummy->next;
}


// 排序链表
ListNode* sortList(ListNode* head) 
{
    if (!head || !head->next) return head;

    ListNode* head2 = middleNode(head);
    head = sortList(head);
    head2 = sortList(head2);

    return mergerTwoLists(head, head2);
}


int main() 
{
    // 构建链表：4 -> 2 -> 1 -> 3
    ListNode* head = new ListNode(4);
    head->next = new ListNode(2);
    head->next->next = new ListNode(1);
    head->next->next->next = new ListNode(3);

    // 排序
    head = sortList(head);

    // 输出结果
    while (head) 
    {
        cout << head->val << " ";
        head = head->next;
    }
    cout << endl;

    return 0;
}

~~~

输出：

~~~C++
1 2 3 4 
~~~





## 23 [合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked)

@最小堆

![image-20250710124249246](pic/image-20250710124249246.png)

### 1、最小堆（推荐）

![image-20250710124255992](pic/image-20250710124255992.png)

![image-20250710124303307](pic/image-20250710124303307.png)

<img src="pic/image-20250710113320140.png" alt="image-20250710113320140" style="zoom:40%;" />

<img src="pic/image-20250710113342369.png" alt="image-20250710113342369" style="zoom:40%;" />



~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {

        auto cmp = [](const ListNode* a, const ListNode* b)
        {
            return a->val > b->val; // 最小堆
            
            // 如果 cmp(a, b) 为 true，则认为 a 的优先级低于 b，所以 a 会在 b 的后面。
            // return a->val > b->val; 即大的数排在后面，小的在前
        };

        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq;
        for (auto head : lists)
        {
            if (head)   pq.push(head); // 先把所有非空链表的头节点入堆
        }
        

        ListNode* dummy = new ListNode(0);// 哨兵节点，作为合并后链表头结点的前一个节点
        ListNode* cur = dummy;
        
        while (!pq.empty()) // 循环直到堆为空
        {
            auto node = pq.top(); // 弹出剩余节点中的最小节点
            pq.pop();
            
            if (node->next) // 如果下一个节点不为空，有可能是最小节点，入堆自动排序
            {
                pq.push(node->next); 
            }

            cur->next = node; // node添加到新链表的末尾
            cur = cur->next;  // 准备合并下一个节点
        }

        return dummy->next;
    }
};
~~~

- 时间复杂度：O(*L*log*m*)，其中 *m* 为 *lists* 的长度，*L* 为所有链表的长度之和。
- 空间复杂度：O(*m*)。堆中至多有 *m* 个元素。



##### 小顶堆

~~~C++
auto cmp = [](const ListNode* a, const ListNode* b) {
    return a->val > b->val;  // 小的优先
};
~~~

`cmp` 是一个 lambda表达式，它接受两个 `ListNode*` 类型的参数 `a` 和 `b`。

返回 `a->val > b->val`，意思是：

> 在 C++ STL 的 `priority_queue` 中，**比较函数 `cmp(a, b)` 的语义是**：
>
> ​	“ 如果 `cmp(a, b)` 为 `true`，则认为 `a` 的优先级**低于** `b`，所以 `a` 会在 `b` 的**后面**。”
>
> 所以 `return a > b;` 表示 `a > b`时，返回true，大的数在后面，小的数在前（top）。



对于自定义类型如 `ListNode*`，我们用 lambda 来定制比较逻辑：

~~~C++
priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);
~~~

当你向 `pq` 插入多个 `ListNode*` 时，它会根据 `cmp(a, b)` 的值来维护堆序：

- 若 `a->val > b->val` 返回 `true` → `a` 比 `b` 优先级低（ `a` 应该在后，即大的节点在后）
- 最终堆顶就是 **当前最小的节点**



##### dummy 节点的创建

~~~C++
ListNode dummy{};           // 哨兵节点，作为合并后链表头结点的前一个节点
auto cur = &dummy;        // 指针 cur 指向 dummy 
~~~

`{}`：这是 C++11 引入的值初始化语法，表示将指针初始化为 `nullptr`（空指针）。

| 写法              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| `ListNode dummy;` | 创建了一个实际的 **`ListNode` 实例**（默认值为0, nullptr） ✅<br />`dummy` 是一个实际存在于**栈上**的 `ListNode` 实例<br />访问：`dummy.next`  `dummy.val` |



和常见写法的区别：

~~~C++
ListNode* dummy = new ListNode(0); // 使用 new 在堆上创建了一个值为 0 的 ListNode 节点
ListNode* cur = dummy;
~~~

`ListNode* dummy`：声明一个**指针变量 `dummy`，类型是 `ListNode*`**，即指向 `ListNode` 类型的指针。

功能等价：**逻辑上等价**

- 两者最终目的完全一致：使用一个“哨兵节点”作为合并后链表的起点（占位头结点），便于构造和返回。
- 后续都是操作 `cur` 指针，无论它指向栈上的 `dummy` 还是堆上的 `*dummy`，逻辑无差别。

但**语义和内存管理上不完全等价**：

| 写法                                 | 存储位置 | 是否需要手动释放      | 是否更推荐   |
| ------------------------------------ | -------- | --------------------- | ------------ |
| `ListNode dummy;`                    | 栈内存   | ❌ 不需要              | ✅ 推荐       |
| `ListNode* dummy = new ListNode(0);` | 堆内存   | ✅ 需要 `delete dummy` | ⚠️ 易内存泄漏 |

如果你是在函数体内部构造链表，不跨作用域、不需要共享链表头，推荐使用 **栈上 dummy 节点写法**：

```
ListNode dummy;
ListNode* cur = &dummy;
```

更安全，不需要考虑 `delete`，不会造成内存泄漏，语义清晰。





### 2、分治递归

![image-20250711110632667](pic/image-20250711110632667.png)

~~~C++
class Solution {
public:

    // 21 合并两个有序链表(升序)
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2)
    {
        ListNode* dummy = new ListNode(0);
        ListNode* cur = dummy;
        while (list1 && list2)
        {
            if (list1->val < list2->val)  
            {
                cur->next = list1;
                list1 = list1->next;
            }
            else
            {
                cur->next = list2;
                list2 = list2->next;
            }

            cur = cur->next;
        }

        cur->next = list1 ? list1 :  list2;
        return dummy->next;
    }


    // 合并从 lists[i] 到 lists[j-1] 的链表，左闭右开
    ListNode* mergeRange(vector<ListNode*>& lists, int i, int j) 
    {
        int m = j - i; // [i, j)
        if (m == 0) return nullptr;  // 输入的 lists 可能是空的
        if (m == 1) return lists[i]; // 无需合并，直接返回
        
        auto left  = mergeRange(lists, i, i + m / 2); // 递归合并左半部分
        auto right = mergeRange(lists, i + m / 2, j); // 递归合并右半部分

        return mergeTwoLists(left, right); // 最后把左和右两半合并
    }



    ListNode* mergeKLists(vector<ListNode*>& lists) {

        return mergeRange(lists, 0, lists.size()); // 递归合并
    }
};
~~~

时间复杂度：O(Llogm)

- 其中 m 为 lists 的长度，L 为所有链表的长度之和。每个节点参与链表合并的次数为 O(logm) 次，一共有 L 个节点，所以总的时间复杂度为 O(Llogm)。

空间复杂度：O(logm)

- 递归深度为 O(logm)，需要 O(logm) 的栈空间。Python 忽略切片产生的额外空间。





### ACM

~~~C++
#include <iostream>
#include <vector>
using namespace std;

// 23 合并k个有序链表
// 最小堆：
//      时间复杂度：O(Llogm)，其中 m 为 lists 的长度，L 为所有链表的长度之和。
//      空间复杂度：O(m)。堆中至多有 m 个元素
// 分治递归：
//      时间复杂度：O(Llogm)，其中 m 为 lists 的长度，L 为所有链表的长度之和。
//      空间复杂度：O(logm)。递归深度为 O(logm)，需要 O(logm) 的栈空间。


struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// 21 合并两个有序链表(升序)
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2)
{
    ListNode* dummy = new ListNode(0);
    ListNode* cur = dummy;
    while (list1 && list2)
    {
        if (list1->val < list2->val)  
        {
            cur->next = list1;
            list1 = list1->next;
        }
        else
        {
            cur->next = list2;
            list2 = list2->next;
        }

        cur = cur->next;
    }

    cur->next = list1 ? list1 :  list2;
    return dummy->next;
}

// 合并从 lists[i] 到 lists[j-1] 的链表
ListNode* mergeRange(vector<ListNode*>& lists, int i, int j) 
{
    int m = j - i; // [i, j)
    if (m == 0) return nullptr;  // 输入的 lists 可能是空的
    if (m == 1) return lists[i]; // 无需合并，直接返回
    
    auto left  = mergeRange(lists, i, i + m / 2); // 合并左半部分
    auto right = mergeRange(lists, i + m / 2, j); // 合并右半部分

    return mergeTwoLists(left, right); // 最后把左半和右半合并
}


// 合并k个升序链表
ListNode* mergeKLists(vector<ListNode*>& lists) 
{
    return mergeRange(lists, 0, lists.size()); // 递归合并
}


int main() 
{
    // 构建三个有序链表
    ListNode* l1 = new ListNode(1); // 1->4->5
    l1->next = new ListNode(4);
    l1->next->next = new ListNode(5);

    ListNode* l2 = new ListNode(1); // 1->3->4
    l2->next = new ListNode(3);
    l2->next->next = new ListNode(4);

    ListNode* l3 = new ListNode(2); // 2->6
    l3->next = new ListNode(6);

    vector<ListNode*> lists = {l1, l2, l3};
    ListNode* merged = mergeKLists(lists); // 合并

    while (merged)
    {
        cout << merged->val;
        if (merged->next)   cout << "->";
        merged = merged->next;
    }
    cout << endl;

    return 0;
}
~~~

输出：

~~~C++
1->1->2->3->4->4->5->6
~~~





## [146 LRU缓存](https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250711161258116](pic/image-20250711161258116.png)

<img src="pic/image-20250711162032122.png" alt="image-20250711162032122" style="zoom:40%;" />

<img src="pic/image-20250711164304110.png" alt="image-20250711164304110" style="zoom:40%;" />



![image-20250711162359701](pic/image-20250711162359701.png)

~~~C++
// 构造双向链表（存key，value，前后向指针）
// 删除节点 remove() + 最上面添加节点 push_front() + 抽出key节点，移到头部 get_node()

class Node // 构造双向链表
{
public:
    int key;
    int value;
    Node* prev;
    Node* next;

    Node(int k = 0, int v = 0) : key(k), value(v) {}
};


class LRUCache {
private:
    int capacity;
    Node* dummy; 
    unordered_map<int, Node*> key_to_node; // <key, node>

    // 删除一个节点（抽出一本书）
    void remove(Node* x)
    {
        x->prev->next = x->next;
        x->next->prev = x->prev; 
    }


    // 插入节点到链表头部（dummy后面）（把一本书放在最上面）
    void push_front(Node* x)
    {
        x->prev = dummy;
        x->next = dummy->next;
        x->prev->next = x;
        x->next->prev = x;
    }


    // 获取 key 对应的节点返回，并移到链表头部（抽出一本书放在最上面）
    Node* get_node(int key)
    {
        auto it = key_to_node.find(key);

        // 没有这本书
        if (it == key_to_node.end())    return nullptr; 

        // 有这本书
        Node* node = it->second; 
        remove(node);     // 抽出这本书
        push_front(node); // 放在最上面

        return node;
    }



public:
    LRUCache(int capacity) 
        : capacity(capacity), dummy(new Node())
    {
        dummy->prev = dummy;
        dummy->next = dummy;// 初始都指向自己
    }
    

    int get(int key) {
        // 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 
        Node* node = get_node(key);
        return node ? node->value : -1;
    }
    
    
    void put(int key, int value) {
        // 如果关键字 key 已经存在，则变更其数据值 value 
        // 如果不存在，则向缓存中插入该组 key-value 
        // 如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字
        
        Node* node = get_node(key);// get_node 会把对应节点移到链表头部
        // 节点存在，更新value，移到头部（有这本书）
        if (node) 
        {
            node->value = value; 
            return;
        }

        // 节点不存在，创建新节点插入头部（新书）
        Node* newnode = new Node(key, value);
        key_to_node[key] = newnode;
        push_front(newnode); 

        // 节点插入后，容量爆了，移除最后节点（移除最下面的书）
        if (key_to_node.size() > capacity) 
        {
            Node* back_node = dummy->prev; // 环形双向链表，直接找到最下面节点
            
            key_to_node.erase(back_node->key); // map中删除 <key, back_node>
            remove(back_node); 				   // 链表删除节点
            
            delete back_node; // 释放内存
        }
    }
    
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
~~~

- 时间复杂度：所有操作均为 O(1)。
- 空间复杂度：O(min(*p*,*capacity*))，其中 *p* 为 put 的调用次数。



ACM

~~~C++
#include <iostream>
#include <unordered_map>
using namespace std;

// 146 LRU缓存
// 时间复杂度：所有操作均为 O(1)
// 空间复杂度：O(min(p,capacity))，其中 p 为 put 的调用次数


// 双向链表结构
class Node
{
public:
    int key;
    int value;
    Node* prev;
    Node* next;

    Node(int k = 0, int v = 0) : key(k), value(v), prev(nullptr), next(nullptr) {}
};


class LRUCache
{
private:
    int capacity; // 容量
    unordered_map<int, Node*> key_to_node; // <key, node>
    Node* dummy;


    // 删除一个节点（抽出一本书）
    void removeNode(Node* x)
    {
        x->prev->next = x->next;
        x->next->prev = x->prev;
    }

    // 插入节点到链表头部（dummy后面）（把一本书放在最上面）
    void push_front(Node* x)
    {
        x->prev = dummy;
        x->next = dummy->next;
        x->prev->next = x;
        x->next->prev = x;
    }

    // 获取 key 节点返回，并移动到头部（抽出一本书放在最上面）
    Node* get_node_push(int key)
    {
        auto it = key_to_node.find(key);

        if (it == key_to_node.end())   return nullptr;

        Node* node = it->second;
        removeNode(node);
        push_front(node);
        return node;
    }


public:
    LRUCache(int capacity) 
        : capacity(capacity), dummy(new Node()) // 初始化列表
    {
        dummy->prev = dummy;
        dummy->next = dummy;
    }


    // get() 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 
    int get(int key)
    {
        Node* node = get_node_push(key);
        return node ? node->value : -1;
    }


    // 如果关键字 key 已经存在，则变更其数据值 value 
    // 如果不存在，则向缓存中插入该组 key-value 
    // 如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字
    void put(int key, int value)
    {
        Node* node = get_node_push(key);

        // 节点存在
        if (node)
        {
            node->value = value;
            return;
        }

        // 节点不存在，创建新节点插入头部
        Node* new_node = new Node(key, value);
        push_front(new_node);
        key_to_node[key] = new_node;

        // 节点插入后，容量爆了，移除最后节点
        if (key_to_node.size() > capacity)
        {
            Node* back_node = dummy->prev;
            key_to_node.erase(back_node->key); // 在map删除
            removeNode(back_node);             // 在链表删除

            delete back_node; // 释放内存
        }
    }

};


int main()
{
    LRUCache lru(2); // capacity = 2

    lru.put(1, 1); // {1=1}
    lru.put(2, 2); // {1=1, 2=2}

    cout << "get(1)" << lru.get(1) << endl; // 输出1  {2=2，1=1}

    lru.put(3, 3); // 超出capacity，淘汰key=2  {1=1，3=3}

    cout << "get(2)" << lru.get(2) << endl; // 输出-1

    lru.put(4, 4); // 超出capacity，淘汰key=1  {3=3, 4=4}
    
    cout << "get(1)" << lru.get(1) << endl; // 输出-1
    cout << "get(3)" << lru.get(3) << endl; // 输出 3
    cout << "get(4)" << lru.get(4) << endl; // 输出 4


    return 0;
}
~~~





# 二叉树 ✅

## [94 中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250712105200783](pic/image-20250712105200783.png)



### 递归

~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // 递归
    void traversal(TreeNode* cur, vector<int>& vec)
    {
        if (cur == nullptr) return;

        traversal(cur->left, vec);  // 左
        vec.push_back(cur->val);    // 中
        traversal(cur->right, vec); // 右
    }


    vector<int> inorderTraversal(TreeNode* root) {
        
        vector<int> result;
        traversal(root, result);

        return result;
        
    }
};
~~~





### 迭代

![image-20250713111238309](pic/image-20250713111238309.png)

画图吧！！！

~~~C++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {

        vector<int> result;

        stack<TreeNode*> st;
        TreeNode* cur = root;

        while (cur || !st.empty())
        {
            if (cur)
            {
                // 指针来访问节点，节点放入栈，先左边，一直到左边最底层
                st.push(cur);
                cur = cur->left;
            }
            else // cur = nullptr 走到左边最低
            {
                cur = st.top(); // 要处理的节点
                st.pop();

                // 当前节点值放进result
                result.push_back(cur->val); // 中
                
                // 转向当前节点的右节点
                cur = cur->right;           // 右
            }
        }

        return result;        
    }
};
~~~





### ACM

~~~C++
#include <iostream>
#include <vector>
using namespace std;

// 93 二叉树中序遍历

// 结构树
struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 递归中序遍历 左-中-右
void inorderTraversal(TreeNode* cur, vector<int>& vec)
{
    if (!cur)   return;

    inorderTraversal(cur->left, vec);  // 左
    vec.push_back(cur->val);           // 中
    inorderTraversal(cur->right, vec); // 右
}



int main()
{
    // 构建如下二叉树：
    //           1
    //         /   \
    //        2     3
    //       / \     \
    //      4   5     8
    //         / \   /
    //        6   7 9

    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);

    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    root->left->right->left = new TreeNode(6);
    root->left->right->right = new TreeNode(7);

    root->right->right = new TreeNode(8);
    root->right->right->left = new TreeNode(9);

    vector<int> result;
    inorderTraversal(root, result); // 4 2 6 5 7 1 3 9 8

    // 输出
    for (int val : result)
    {
        cout << val << " ";
    }
    cout << endl;


    return 0;
}

~~~





## [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250714101413336](pic/image-20250714101413336.png)



### 自底向上（递归）

<img src="pic/image-20250717112431891.png" alt="image-20250717112431891" style="zoom:50%;" />

<img src="pic/image-20250717112517596.png" alt="image-20250717112517596" style="zoom:50%;" />

<img src="pic/image-20250717112627734.png" alt="image-20250717112627734" style="zoom:50%;" />



~~~C++
class Solution {
public:

    // 递归 
    int getdepth(TreeNode* node)
    {
        if (node == nullptr)    return 0;

        int leftdepth = getdepth(node->left); // 左
        int rightdepth = getdepth(node->right); // 右

        // 取左右子树深度的最大值 + 1
        int depth = max(leftdepth, rightdepth) + 1; // 加上自己
        return depth;
    }


    int maxDepth(TreeNode* root) {
        return getdepth(root);
    }
};
~~~

精简：

~~~C++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        // 自底向上
        if (!root)  return 0;
        return 1 + max(maxDepth(root->left), maxDepth(root->right));
    }
};
~~~



### 自顶向下（递归）

把经过的节点数传下去（也就是深度 depth），往下走，+1

~~~C++
class Solution {
public:
    int maxDepth(TreeNode* root) {

        // 自顶向下
        int ans = 0;

        auto dfs = [&](this auto&& dfs, TreeNode* node, int depth)->void 
        {
            if (node == nullptr)     return;

            depth++; // 从上往下带参数（节点数）
            
            ans = max(ans, depth); // 每往下走一层，更新深度

            dfs(node->left, depth);
            dfs(node->right, depth);  
        };

        dfs(root, 0);
        return ans;        
    }
};
~~~

> 这里 `auto dfs = [&](this auto&& dfs, TreeNode* node, int depth)->void {}`传的是 `int depth`，**值传递，而不是引用传递，为什么？**
>
> 值传递：
>
> - 每次 `dfs` 被调用时，`depth` 是**一份新的值**
>
> - `depth++` 是在当前路径中修改，不影响兄弟节点；
>
> - 例如 `left` 分支的递归 `depth++` 后，`right` 分支仍然是原来的 `depth+1`；
>
>   <img src="pic/image-20250723151754521.png" alt="image-20250723151754521" style="zoom:50%;" />
>
> 引用传递：
>
> - 如果改成引用传递，每次递归都是对同一个变量 `depth` 的引用，每次 `depth++`都会永久修改这个变量
>
>   <img src="pic/image-20250723152046755.png" alt="image-20250723152046755" style="zoom:50%;" />
>
> - 引用传递会让所有递归路径共享一个变量，一旦在某一支中被修改，后续所有路径都会“继承”这个值，无法反映每条路径本应有的独立深度。





### 层序

最大深度，就是最大层数，每走一层深度 + 1

~~~C++	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {

        if (root == nullptr)   return 0;
        int depth = 0;

        queue<TreeNode*> que;
        que.push(root);

        while (!que.empty())
        {
            int size = que.size();
            depth++; // 每走一层，深度+1

            for (int i = 0; i < size; i++)
            {
                TreeNode* node = que.front();
                que.pop(); // 求深度，不用收集节点值了

                if (node->left)     que.push(node->left);
                if (node->right)    que.push(node->right);
            }
        }

        return depth;        
    }
};
~~~



### ACM

~~~C++	
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

// 104 二叉树的最大深度
// 时间复杂度：O(n)
// 空间复杂度：O(n)


struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


int maxDepth(TreeNode* root)
{
    if (!root)  return 0;

    queue<TreeNode*> que;
    que.push(root);

    int depth = 0;

    while (!que.empty())
    {
        int size = que.size();
        depth++;

        for (int i = 0; i < size; i++)
        {
            TreeNode* node = que.front();
            que.pop();
            if (node->left)     que.push(node->left);
            if (node->right)    que.push(node->right);
        }
    }

    return depth;
}



int main()
{
    TreeNode* root = new TreeNode(3);
    root->left = new TreeNode(9);
    root->right = new TreeNode(20);

    root->right->left = new TreeNode(15);
    root->right->right = new TreeNode(7);


    int depth = maxDepth(root); // 3
    cout << depth << endl;


    return 0;
}
~~~





## [226 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250715104054759](pic/image-20250715104054759.png)

![image-20250715104114171](pic/image-20250715104114171.png)

**注意交换的是节点，不是值**



### 1、递归（前序）推荐

swap 直接交换当前节点的左右子树

~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {

        if (root == nullptr)    return root;

        // 直接交换当前节点的左右子树
        swap(root->left, root->right);  // 中
        invertTree(root->left);         // 左
        invertTree(root->right);        // 右

        // 交换左右语句的顺序，就是后序

        return root;
    }
};
~~~



### 2、迭代（前序）

~~~C++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {

        // 迭代 前序
        if (root == nullptr)    return root;

        stack<TreeNode*> st;
        st.push(root);
        while (!st.empty())
        {
            TreeNode* node = st.top();                // 中
            st.pop();
            swap(node->left, node->right);

            if (node->right)    st.push(node->right); // 右
            if (node->left)     st.push(node->left);  // 左
        }

        return root;
    }
};
~~~



### 3、层序

~~~C++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {

        // 层序
        queue<TreeNode*> que;
        if (root)  que.push(root);

        while (!que.empty())
        {
            int size = que.size();

            for (int i = 0; i < size; i++)
            {
                TreeNode* node = que.front();
                que.pop();
                swap(node->left, node->right); // 交换

                if (node->left)     que.push(node->left);
                if (node->right)    que.push(node->right);
            }
        }

        return root;
    }
};
~~~



### ACM 

~~~C++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

// 226 反转二叉树
// 时间复杂度： O(n)
// 空间复杂度： O(h)，最坏情况下递归栈深度为树高 h，最坏 O(n)，平均 O(log n)（平衡树）。

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


// 递归 前序
TreeNode* invertTree(TreeNode* root) 
{
    if (root == nullptr)    return root;

    swap(root->left, root->right);      // 中
    invertTree(root->left);             // 左
    invertTree(root->right);            // 右

    return root;
}



// 层序遍历（用于输出）
vector<int> levelOrder(TreeNode* root) 
{
    vector<int> result;
    if (!root) return result;

    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        TreeNode* node = q.front(); 
        q.pop();
        result.push_back(node->val);

        if (node->left)  q.push(node->left);
        if (node->right) q.push(node->right);
    }

    return result;
}



int main()
{
    // 构建测试树结构
    TreeNode* root = new TreeNode(4);
    root->left = new TreeNode(2);
    root->right = new TreeNode(7);

    root->left->left = new TreeNode(1);
    root->left->right = new TreeNode(3);

    root->right->left = new TreeNode(6);
    root->right->right = new TreeNode(9);

    invertTree(root); // 反转
    vector<int> output = levelOrder(root);

    // 输出
    for (auto val : output)
    {
        cout << val << " ";
    }

    cout << endl;


    return 0;
}
~~~



输出

~~~C++
4 7 2 9 6 3 1 
~~~







## 101 [对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250715105852244](pic/image-20250715105852244.png)

![image-20250715105954842](pic/image-20250715105954842.png)



<img src="pic/image-20250715110248345.png" alt="image-20250715110248345" style="zoom:50%;" />

![image-20250715110306408](pic/image-20250715110306408.png)



### 递归

<img src="pic/image-20250715112948526.png" alt="image-20250715112948526" style="zoom:50%;" />

<img src="pic/image-20250715113000842.png" alt="image-20250715113000842" style="zoom:50%;" />

![image-20250715113039827](pic/image-20250715113039827.png)



~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // 递归
    bool compare(TreeNode* left, TreeNode* right)
    {
        // 排除节点空的情况
        if      (left == nullptr && right == nullptr)       return true;
    	else if (left == nullptr || right == nullptr)       return false;
        // 排除节点不空，但值不同的情况
        else if (left->val != right->val)   return false;

        // 左右都不空，且值相同，再做递归下一层        
        // 内外层都相同，才对称
        return compare(left->left, right->right) && // 外层比较，左树->左，右树->右
               compare(left->right, right->left);	// 内层比较：左树->右，右树->左      
    }

    bool isSymmetric(TreeNode* root) {
        if (root == nullptr)    return true;
        return compare(root->left, root->right); // 左右节点传入compare，进行递归比较
    }
};
~~~



### ACM

~~~C++
#include <iostream>

using namespace std;


// 101 对称二叉树
// 时间复杂度： O(n)
// 空间复杂度：
// 		最坏情况下为递归栈深度 O(h)，h 为树高；
// 		平衡二叉树时 O(log n)，最坏退化为 O(n)。

struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


// 递归比较两棵子树是否镜像对称
bool compare(TreeNode* left, TreeNode* right)
{
    // 排除节点空
    if      (left == nullptr && right == nullptr)       return true;
    else if (left == nullptr || right == nullptr)       return false;
    // 排除节点不空，但值不同的情况
    else if (left->val != right->val)                   return false;

    // 比较外侧和内侧
    return compare(left->left, right->right) && compare(left->right, right->left);
}

// 判断整棵树是否对称
bool isSymmetric(TreeNode* root) 
{
    if (!root) return true;
    return compare(root->left, root->right);
}



int main()
{
    // 构建对称二叉树：
    //         1
    //       /   \
    //      2     2
    //     / \   / \
    //    3   4 4   3
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(2);

    root->left->left = new TreeNode(3);
    root->left->right = new TreeNode(4);

    root->right->left = new TreeNode(4);
    root->right->right = new TreeNode(3);

    bool result = isSymmetric(root);
    cout << (result ? "true" : "false") << endl;

    return 0;
}
~~~





## 543 [二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

@ 递归

![image-20250716101939880](pic/image-20250716101939880.png)

[树形 DP：树的直径【基础算法精讲 23】](https://www.bilibili.com/video/BV17o4y187h1/?vd_source=7369d5f08520f2fc3601caee93963ffa)

<img src="pic/image-20250716172648683.png" alt="image-20250716172648683" style="zoom:60%;" />

<img src="pic/image-20250716172734061.png" alt="image-20250716172734061" style="zoom:60%;" />

![image-20250716172800038](pic/image-20250716172800038.png)

~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) {

        int ans = 0;

        // 递归
        auto dfs = [&](this auto&& dfs, TreeNode* node) ->int {
            if (node == nullptr)    return -1; // 叶子节点，链长就是-1 + 1 = 0
            
            int l_len = dfs(node->left) + 1;  // 左子树最大链长 + 1 （加1连到自己）
            int r_len = dfs(node->right) + 1; // 右子树最大链长 + 1

            // 两条链拼成路径（直径）
            ans = max(ans, l_len + r_len); 
            
            return max(l_len, r_len); // 递归返回的是当前子树的最大链长
        };

        dfs(root);
        return ans;
    }
};
~~~

 `this auto&& dfs`

- **C++20 起支持**：lambda 参数中使用 `this auto&&` 允许 lambda **递归调用自身**。
- `this` 说明它是 **递归 lambda** 的特殊用法，编译器会在调用时把当前 lambda 自己传进来。
- `dfs` 是 lambda 的“自身引用”，相当于给自己起了个名字，可以在内部递归调用。

~~~C++
auto dfs = [&](this auto&& dfs, TreeNode* node) -> int{...};
~~~

定义了一个**可以递归调用自身的深度优先搜索函数**，在函数体中递归地访问左右子树，并计算“以该节点为中心的最长路径”。

等价于：

~~~C++
auto dfs = [&](auto&& dfs, TreeNode* node) -> int { ... };
~~~

调用时需要手动传入自己`dfs`

~~~C++
dfs(dfs, root);
~~~

而`this auto&&` 直接帮你把`dfs`传给自己了，调用时只用写：

~~~C++
dfs(root);
~~~





普通写法：

~~~C++
class Solution {
public:
    int maxDiameter = 0;

    int dfs(TreeNode* node) {
        if (node == nullptr) return -1;

        int left = dfs(node->left) + 1;
        int right = dfs(node->right) + 1;

        maxDiameter = max(maxDiameter, left + right); // 两条链拼成路径（直径）

        return max(left, right); // 递归返回的是当前子树的最大链长
    }


    int diameterOfBinaryTree(TreeNode* root) {

        dfs(root);
        return maxDiameter;
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <algorithm>
using namespace std;

// 543 二叉树的直径


struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


int diameterOfBinaryTree(TreeNode* root)
{
    int ans = 0;

    // 递归 lambda写法，this auto&& 允许递归调用自身 （需要 C++23 支持）
    auto dfs = [&](this auto&& dfs, TreeNode* node) ->int {
        if (node == nullptr)    return -1; // 叶子节点，链长就是 -1 + 1 = 0
        
        int l_len = dfs(node->left) + 1;  // 左树最大链长 + 1
        int r_len = dfs(node->right) + 1; // 右树最大链长 + 1

        // 最大左链 + 最大右链
        ans = max(ans, l_len + r_len);

        return max(l_len, r_len); // 递归返回的是当前子树的最大链长
    };

    dfs(root);
    return ans;
}


int main()
{
    // 构建如下二叉树：
    //           1
    //         /   \
    //        2     3
    //       / \     
    //      4   5     

    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);

    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    int ans = diameterOfBinaryTree(root); // 3
    cout << ans << endl;


    return 0;
}
~~~



普通写法：

~~~C++
#include <iostream>
#include <algorithm>
using namespace std;

// 543 二叉树的直径


struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


int dfs (TreeNode* node, int& maxDiameter)
{
    if (node == nullptr) return -1;
    int left = dfs(node->left, maxDiameter) + 1;
    int right = dfs(node->right, maxDiameter) + 1;

    maxDiameter = max(maxDiameter, left + right); // 两条链拼成路径（直径）

    return max(left, right); // 递归返回的是当前子树的最大链长
}


int main()
{
    // 构建如下二叉树：
    //           1
    //         /   \
    //        2     3
    //       / \     
    //      4   5     

    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);

    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    int maxDiameter = 0;
    dfs(root, maxDiameter);

    cout << maxDiameter << endl;

    return 0;
}
~~~





## 124 [二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked)

@ 递归

![image-20250717102900078](pic/image-20250717102900078.png)



在 【543 二叉树的直径】的基础上，改成求节点和

<img src="pic/image-20250717110338582.png" alt="image-20250717110338582" style="zoom:60%;" />

![image-20250717110355666](pic/image-20250717110355666.png)

![image-20250717110401891](pic/image-20250717110401891.png)



~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxPathSum(TreeNode* root) {

        int ans = INT_MIN;
        auto dfs = [&] (this auto&& dfs, TreeNode* node) ->int {
            if (node == nullptr)    return 0;// 没有节点，和为0

            int l_val = dfs(node->left); // 左树最大链和
            int r_val = dfs(node->right); // 右树最大链和

            ans = max(ans, l_val + r_val + node->val); // 两条链拼成路径（加上当前节点）
            
            return max( max(l_val, r_val) + node->val, 0 ); // 当前子树最大链和
                                                            // 和0比较，不取负数
        };

        dfs(root);
        return ans;
        
    }
};
~~~



不用lambda的写法

~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans = INT_MIN;

    int dfs(TreeNode* node) 
    {
        if (node == nullptr)    return 0;// 没有节点，和为0

        int l_val = dfs(node->left);  // 左树最大链和
        int r_val = dfs(node->right); // 右树最大链和

        ans = max(ans, l_val + r_val + node->val); // 两条链拼成路径（加上当前节点）
        
        return max( max(l_val, r_val) + node->val, 0 ); // 当前子树最大链和
                                                      // 和0比较，不取负数
    };

    int maxPathSum(TreeNode* root) {
        dfs(root);
        return ans; 
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <algorithm>
using namespace std;

// 124 二叉树中的最大路径和


struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


int maxPathSum(TreeNode* root) 
{
    int ans = INT_MIN;

    auto dfs = [&] (this auto&& dfs, TreeNode* node) ->int {

        if (node == nullptr)    return 0;// 没有节点，和为0

        int l_val = dfs(node->left); // 左树最大链和
        int r_val = dfs(node->right); // 右树最大链和

        ans = max(ans, l_val + r_val + node->val); // 两条链拼成路径（加上当前节点）
        return max(max(l_val, r_val) + node->val, 0); // 当前子树最大链和
                                                        // 和0比较，不取负数
    };

    dfs(root);
    return ans;
}


int main()
{
    /* 构建如下二叉树：  
        -10
        /   \
       9     20
             / \     
           15    7    
    */ 
    

    TreeNode* root = new TreeNode(-10);
    root->left = new TreeNode(9);
    root->right = new TreeNode(20);

    root->right->left = new TreeNode(15);
    root->right->right = new TreeNode(7);

    int ans = maxPathSum(root); // 42
    cout << ans << endl;


    return 0;
}
~~~





## [108 将有序数组转为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250718102019473](pic/image-20250718102019473.png)

![image-20250718103907990](pic/image-20250718103907990.png)

<img src="pic/image-20250718103913432.png" alt="image-20250718103913432" style="zoom:30%;" />

<img src="pic/image-20250718103925534.png" alt="image-20250718103925534" style="zoom: 70%;" />

<img src="pic/image-20250718103955950.png" alt="image-20250718103955950" style="zoom:50%;" />



<img src="pic/image-20250718104007279.png" alt="image-20250718104007279" style="zoom: 50%;" />

![image-20250718104033278](pic/image-20250718104033278.png)



~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // nums[left] 到 nums[right] 转成平衡二叉搜索树 (左闭右闭)
    TreeNode* traversal(vector<int>& nums, int left, int right)
    {
        if (left > right)   return nullptr;

        int mid = left + ((right - left) / 2); 
        TreeNode* root = new TreeNode(nums[mid]); // 取中间值作为root

        root->left = traversal(nums, left, mid - 1);  // root->left 接左区间构造的下一层root
        root->right = traversal(nums, mid + 1, right);// root->right 接右区间构造的下一层root
        
        return root;
    }


    TreeNode* sortedArrayToBST(vector<int>& nums) {

        TreeNode* root = traversal(nums, 0, nums.size() - 1);
        return root;
        
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <queue>
#include <iostream>

using namespace std;

// 108 将有序数组转换为二叉搜索树

struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

TreeNode* ArrayToBstTraversal(vector<int>& nums, int left, int right)
{
    if (left > right)   return nullptr;

    int mid = left + ((right - left) / 2);
    TreeNode* root = new TreeNode(nums[mid]);

    root->left = ArrayToBstTraversal(nums, left, mid - 1);
    root->right = ArrayToBstTraversal(nums, mid + 1, right);

    return root;
}


// 层序遍历（用于输出）
vector<int> levelOrder(TreeNode* root) 
{
    vector<int> result;
    if (!root)  return result;

    queue<TreeNode*> q;
    q.push(root);
    while (!q.empty())
    {
        TreeNode* node = q.front();
        q.pop();
        result.push_back(node->val);

        if (node->left)     q.push(node->left);
        if (node->right)    q.push(node->right);

    }

    return result;
}



int main()
{
    // nums = [-10,-3,0,5,9]
    vector<int> nums = {-10, -3, 0, 5, 9};

    TreeNode* root = ArrayToBstTraversal(nums, 0, nums.size() - 1);

    // 层序输出
    vector<int> output = levelOrder(root);
    for (auto val : output) 
    {
        cout << val << " "; // 0 -10 5 -3 9
    }
    cout << endl;


    return 0;
}
~~~





## 98 [验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250718111419031](pic/image-20250718111419031.png)

**注意：**

- 要比较的是 **左子树**所有节点小于中间节点，**右子树**所有节点大于中间节点

- 不能单纯的比较左节点小于中间节点，右节点大于中间节点



### 1、中序递归 + 数组

搜索树，左小右大，中序存下来的值应该是升序

~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:

    // 存储节点值 (递归中序)
    vector<int> vec; 
    void traversal(TreeNode* root)
    {
        if (root == nullptr)    return;
        traversal(root->left);      // 左
        vec.push_back(root->val);   // 中
        traversal(root->right);     // 右
    }

    // 搜索树，左小右大，中序存下来的值应该是升序

public:
    bool isValidBST(TreeNode* root) {
        vec.clear();
        traversal(root);

        // 判断vec是不是升序
        for (int i = 1; i < vec.size(); i++)
        {
            // 搜索树里不能有相等的元素，所以要 <=
            if (vec[i] <= vec[i - 1])   return false;
        }

        return true;
        
    }
};
~~~



### 2、中序递归 +  pre保存前一个节点，比较是否升序

~~~C++
class Solution {
public:

    TreeNode* pre = nullptr; // pre 记录前一个节点

    bool isValidBST(TreeNode* root) {

        if (root == nullptr)    return true;

        bool left = isValidBST(root->left);     // 左

        if (pre != nullptr && pre->val >= root->val)    return false;
        pre = root; // 记录前一个节点            // 中

        bool right = isValidBST(root->right);   // 右
        
        return left && right;
    }
};
~~~



### 3、前序 + 判断节点范围 

> [灵神](https://leetcode.cn/problems/validate-binary-search-tree/solutions/2020306/qian-xu-zhong-xu-hou-xu-san-chong-fang-f-yxvh/?envType=study-plan-v2&envId=top-100-liked)，这怎么能想出来的？

![image-20250718165259599](pic/image-20250718165259599.png)

<img src="pic/image-20250718165325010.png" alt="image-20250718165325010" style="zoom:60%;" />

**前序：先访问节点值，再递归子树**

**根据上一层来更新下一层的节点值应该在的范围，走到下一层判断是否合法**

**往左走，更新右边界，往右走，更新左边界**



~~~C++
class Solution {
public:
    bool isValidBST(TreeNode* root, long long left = LLONG_MIN, long long right = LLONG_MAX) {

        // 前序 + 边界 
        // 最开始root所处范围是 （-无穷，+无穷）

        if (root == nullptr)    return true;

        long long x = root->val; // 前序，先访问节点值，再递归子树

        return left < x && x < right && // 判断节点值要处于正确的边界范围内
               isValidBST(root->left, left, x) && // 更新右边界
               isValidBST(root->right, x, right); // 更新左边界
    }
};
~~~



### ACM

~~~C++
#include <iostream>
#include <algorithm>
using namespace std;

// 98 验证二叉搜索树

struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


// 判断是否为合法 BST
bool isValidBST(TreeNode* root, TreeNode* pre) 
{
    if (!root) return true;

    if (!isValidBST(root->left, pre)) return false;

    if (pre && pre->val >= root->val) return false;
    pre = root;

    if (!isValidBST(root->right, pre)) return false;

    return true;
}




int main()
{
    /* 构建如下二叉树：  
          5
        /   \
       1     4
            / \     
           3   6    
    */ 
    

    TreeNode* root = new TreeNode(5);
    root->left = new TreeNode(1);
    root->right = new TreeNode(4);

    root->right->left = new TreeNode(3);
    root->right->right = new TreeNode(6);

    TreeNode* pre = nullptr;
    cout << (isValidBST(root, pre) ? "true" : "false") << endl;

    return 0;
}
~~~



## [230 二叉搜索树种第k小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250719225021378](pic/image-20250719225021378.png)

![image-20250719225340770](pic/image-20250719225340770.png)

### 1、中序递归 + 数组

中序存下来 `vec` 正好是升序，第k小的数，就是 vec 第 [k-1] 个数 `vec[k-1]`

~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    // 存储节点值 (递归中序)
    vector<int> vec; 
    void traversal(TreeNode* root)
    {
        if (root == nullptr)    return;
        traversal(root->left);      // 左
        vec.push_back(root->val);   // 中
        traversal(root->right);     // 右
    }

    int kthSmallest(TreeNode* root, int k) {

        vec.clear();
        traversal(root); // 中序存下来正好是升序，第k小的数，就是 vec 第 [k-1] 个数

        return vec[k - 1];
        
    }
};
~~~



### 2、中序递归 + 直接找第k个

![image-20250719225310165](pic/image-20250719225310165.png)

~~~C++
class Solution {
public:

    int ans = 0;
    int k = 1; // 直接用 k 计数

    // 中序递归
    void dfs(TreeNode* root)
    {
        if (root == nullptr)    return;

        dfs(root->left);
        
        if (k == 0)     return; // 已经走过k个，后面不用遍历了，直接return
        if (--k == 0)   ans = root->val; // 记录递归到的第k个，且 k-- 计数

        dfs(root->right);
    }


    int kthSmallest(TreeNode* root, int k) {

        this->k = k;
        dfs(root);
        return ans;  
    }
};
~~~



### ACM

~~~C++
#include <iostream>
using namespace std;

// 230 二叉搜索树中第 K 小的元素

struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


// 中序递归
void dfs(TreeNode* root, int& k, int& ans)
{
    if (root == nullptr)    return;

    dfs(root->left, k, ans);
    
    if (k == 0)     return; // 已经走过k个，后面不用遍历了，直接return
    if (--k == 0)   ans = root->val; // 记录递归到的第k个，且 k-- 计数

    dfs(root->right, k, ans);
}


int main()
{
    /* 构建如下二叉树：  
                    5
                  /   \
                 3     6
                / \        
               2   4   
              /
             1   
    */ 
    

    TreeNode* root = new TreeNode(5);
    root->left = new TreeNode(3);
    root->right = new TreeNode(6);

    root->left->left = new TreeNode(2);
    root->left->right = new TreeNode(4);

    root->left->left->left = new TreeNode(1);

    int k = 3;
    int ans = 0;
    dfs(root, k, ans);

    cout << ans << endl; // 3

    return 0;
}
~~~



## 199 [二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/description/?envType=study-plan-v2&envId=top-100-liked)

@ 层序遍历收集每层最后一个元素

![image-20250720103837102](pic/image-20250720103837102.png)

![image-20250720103904112](pic/image-20250720103904112.png)

~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        
        vector<int> result;

        // 层序
        queue<TreeNode*> que;
        if (root != nullptr)    que.push(root);
        while (!que.empty())
        {
            int size = que.size();
            for (int i = 0; i < size; i++)
            {
                TreeNode* node = que.front();
                que.pop();

                // 将每层的最后一个元素放入result
                if (i == (size - 1))    result.push_back(node->val);

                if (node->left)     que.push(node->left);
                if (node->right)    que.push(node->right);

            }
        }

        return result;
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <queue>
#include <iostream>

using namespace std;


struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


vector<int> rightSideView(TreeNode* root)
{
    vector<int> result;

    queue<TreeNode*> que;
    if (root != nullptr)    que.push(root);
    while (!que.empty())
    {
        int size = que.size();
        for (int i = 0; i < size; i++)
        {
            TreeNode* node = que.front();
            que.pop();

            // 将每层最后一个元素放进result
            if (i == (size - 1))    result.push_back(node->val);

            if (node->left)     que.push(node->left);
            if (node->right)    que.push(node->right);
        }
    }

    return result;
}


int main()
{
    /* 构建如下二叉树：  
                1
              /   \
             2     3
            /        
           4      
          /
         5   
    */

    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);

    root->left->left = new TreeNode(4);
    root->left->left->left = new TreeNode(5);

    vector<int> result = rightSideView(root); // 1 3 4 5
    for (int val : result)
    {
        cout << val << " ";
    }

    cout << endl;


    return 0;
}
~~~







## 114 [二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250720170140684](pic/image-20250720170140684.png)



### 1、头插法

![image-20250720170153091](pic/image-20250720170153091.png)



~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    TreeNode* head;

    void flatten(TreeNode* root) {

        if (root == nullptr)    return;
        
        // 遍历顺序是 右 - 左 - 中
        flatten(root->right); 
        flatten(root->left);

        // 中：处理节点，左置空，右接上一个head
        root->left = nullptr;
        root->right = head; // 头插法，相当于链表的 root->next = head

        head = root; // 更新head，现在链表头节点是 root

        
    }
};
~~~



### 2、分治

![image-20250720173301994](pic/image-20250720173301994.png)

~~~C++
class Solution {
public:

    TreeNode* dfs(TreeNode* root)
    {
        if (root == nullptr)    return nullptr;

        TreeNode* left_tail = dfs(root->left);   // 左树链表尾节点
        TreeNode* right_tail = dfs(root->right); // 右树链表尾节点

        if (left_tail)
        {
            left_tail->right = root->right; // 左子树链表 -> 右子树链表
            root->right = root->left; // 当前节点 -> 左右合并后的链表

            root->left = nullptr; // root->left 置空
        }

        // 返回的是尾节点
        if (right_tail)     return right_tail;
        else if (left_tail) return left_tail;
        else                return root;
    }

    void flatten(TreeNode* root) {
        dfs(root);
    }
};
~~~



### ACM

~~~C++
#include <iostream>

using namespace std;

// 114 二叉树展开为链表

struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};



void flatten(TreeNode* root, TreeNode*& head) {

    if (root == nullptr)    return;
    
    // 遍历顺序是 右 - 左 - 中
    flatten(root->right, head); 
    flatten(root->left, head);

    // 中：处理节点，左置空，右接上一个head
    root->left = nullptr;
    root->right = head; // 头插法，相当于链表的 root->next = head

    head = root; // 更新head，现在链表头节点是 root
}

int main()
{
    /* 构建如下二叉树：  
                1
              /   \
             2     5
            / \     \   
           3   4     6
   
    */

    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(5);

    root->left->left = new TreeNode(3);
    root->left->right = new TreeNode(4);

    root->right->right = new TreeNode(6);


    TreeNode* head = nullptr;
    flatten(root, head); // 1 2 3 4 5 6
    while (root)
    {
        cout << root->val << " ";
        root = root->right;
    }
    cout << endl;


    return 0;
}

~~~





## [105 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked)

参考[106 从中序与后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)

![image-20250721105825086](pic/image-20250721105825086.png)

和106 从中序与后序遍历构造二叉树 一个意思

<img src="pic/image-20250721150320570.png" alt="image-20250721150320570" style="zoom:50%;" />

~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    TreeNode* traversal(vector<int>& inorder, int inorderBegin, int inorderEnd, 
                        vector<int>& preorder, int preorderBegin, int preorderEnd) {
        
        if (preorderBegin == preorderEnd)   return nullptr;

        // 根节点
        int rootValue = preorder[preorderBegin]; // 注意用preorderBegin，不要用0
        TreeNode* root = new TreeNode(rootValue);

        if (preorderEnd - preorderBegin == 1)   return root; // 叶子节点

        // 找中序的切割点
        int delimiterIndex = inorderBegin;
        for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++)
        {
            if (inorder[delimiterIndex] == rootValue)   break;
        }

        // 中序切割 左闭右开
        // 左中序 [inorderBegin, delimiterIndex)
        int leftInorderBegin = inorderBegin, leftInorderEnd = delimiterIndex;
        // 右中序 [delimiterIndex, inorderEnd]
        int rightInorderBegin = delimiterIndex + 1, rightInorderEnd = inorderEnd;

        // 前序切割 左闭右开
        // 左前序
        int leftPreorderBegin = preorderBegin + 1; // 分离出root
        int leftPreorderEnd = preorderBegin + 1 + (delimiterIndex - inorderBegin);
        // 右前序
        int rightPreorderBegin = preorderBegin + 1 + (delimiterIndex - inorderBegin);
        int rightPreorderEnd = preorderEnd;
        
        
        // 递归 更新区间索引
        root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,
                               preorder, leftPreorderBegin, leftPreorderEnd);
        root->right = traversal(inorder, rightInorderBegin, rightInorderEnd,
                                preorder, rightPreorderBegin, rightPreorderEnd);

        return root;
    }


public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if (inorder.size() == 0 || preorder.size() == 0)    return nullptr;
        // 左闭右开
        return traversal(inorder, 0, inorder.size(),  
                         preorder, 0, preorder.size());
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

// 105 从前序与中序遍历序列构造二叉树

struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


TreeNode* traversal(vector<int>& inorder, int inorderBegin, int inorderEnd, 
                    vector<int>& preorder, int preorderBegin, int preorderEnd) 
{
    
    if (preorderBegin == preorderEnd)   return nullptr;

    // 根节点
    int rootValue = preorder[preorderBegin]; // 注意用preorderBegin，不要用0
    TreeNode* root = new TreeNode(rootValue);

    if (preorderEnd - preorderBegin == 1)   return root; // 叶子节点

    // 找中序的切割点
    int delimiterIndex = inorderBegin;
    for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++)
    {
        if (inorder[delimiterIndex] == rootValue)   break;
    }

    // 中序切割 左闭右开
    // 左中序 [inorderBegin, delimiterIndex)
    int leftInorderBegin = inorderBegin, leftInorderEnd = delimiterIndex;
    // 右中序 [delimiterIndex, inorderEnd]
    int rightInorderBegin = delimiterIndex + 1, rightInorderEnd = inorderEnd;

    // 前序切割 左闭右开
    // 左前序
    int leftPreorderBegin = preorderBegin + 1; // 分离出root
    int leftPreorderEnd = preorderBegin + 1 + (delimiterIndex - inorderBegin);
    // 右前序
    int rightPreorderBegin = preorderBegin + 1 + (delimiterIndex - inorderBegin);
    int rightPreorderEnd = preorderEnd;
    
    
    // 递归 更新区间索引
    root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,
                            preorder, leftPreorderBegin, leftPreorderEnd);
    root->right = traversal(inorder, rightInorderBegin, rightInorderEnd,
                            preorder, rightPreorderBegin, rightPreorderEnd);

    return root;
}


TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) 
{
    if (inorder.size() == 0 || preorder.size() == 0)    return nullptr;
    // 左闭右开
    return traversal(inorder, 0, inorder.size(),  
                        preorder, 0, preorder.size());
}



// 层序遍历（用于输出）
vector<int> levelOrder(TreeNode* root) 
{
    vector<int> result;
    if (!root) return result;

    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        TreeNode* node = q.front(); 
        q.pop();
        result.push_back(node->val);

        if (node->left)  q.push(node->left);
        if (node->right) q.push(node->right);
    }

    return result;
}




int main()
{
    vector<int> preorder = {3, 9, 20, 15, 7};
    vector<int> inorder = {9, 3, 15, 20, 7};

    TreeNode* root = buildTree(preorder, inorder);

    // 输出打印
    vector<int> output = levelOrder(root); // 3 9 20 15 7
    for (auto val : output)
    {
        cout << val << " ";
    }


    return 0;
}

~~~





## [437 路径总和III](https://leetcode.cn/problems/path-sum-iii/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250722102114429](pic/image-20250722102114429.png)

![image-20250722103417959](pic/image-20250722103417959.png)

~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int pathSum(TreeNode* root, int targetSum) {

        int ans = 0;
        unordered_map<long long, int> cntmap{{0, 1}}; // <路径和，出现次数>

        auto dfs = [&](this auto&& dfs, TreeNode* node, long long s)
        {
            if (node == nullptr)    return;

            s += node->val; // 当前节点的路径和（前缀和）

            // 把node当做路径终点，统计有多少个起点 (560里的si = sj - k出现的次数)
            ans += cntmap[s - targetSum]; 

            cntmap[s]++; // 路径和s出现次数++
            dfs(node->left, s);
            dfs(node->right, s);

            // 回溯 恢复现场（去掉当前节点自身的信息）
            cntmap[s]--; 
            // 当前节点只能影响它下层的节点，这些情况在上面的递归中已经处理完毕
            // 在退出本层递归时，当前节点前缀和与其他分支无关，删除记录消除对其他分支的影响

            return;
        };

        dfs(root, 0);// 传入当前node = root, 前缀和 0
        return ans;
    }
};
~~~

关于最后的回溯： `cntmap[s]--; `

当前层递归是以当前node作为root的，退出本层递归的时候，当前节点及其以下的节点都在本层递归完成了。

接下来要转向的是node上一层的其他分支，自然要去除node的信息。

为什么要在递归完右子树后才能恢复现场？能否在递归完左子树后就恢复现场呢？

不可以，因为递归左右子树都是node作为root的部分，递归node右子树也需要node的信息。



ACM

~~~C++
#include <iostream>
#include <unordered_map>
using namespace std;

// 437 路径总和III

struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


// 路径和
int pathSum(TreeNode* root, int targetSum) {

    int ans = 0;
    unordered_map<long long, int> cntmap{{0, 1}}; // <路径和，出现次数>

    // 递归
    auto dfs = [&](this auto&& dfs, TreeNode* node, long long s)
    {
        if (node == nullptr)    return;

        s += node->val; // 当前节点的路径和（前缀和）

        // 把node当做路径终点，统计有多少个起点 (560里的si = sj - k出现的次数)
        ans += cntmap[s - targetSum]; 

        cntmap[s]++; // 路径和s出现次数++

        // 递归左右
        dfs(node->left, s);
        dfs(node->right, s);


        // 回溯 恢复现场（去掉当前节点自身的信息）
        cntmap[s]--; 
        // 当前节点只能影响它下层的节点，这些情况在上面的递归中已经处理完毕
        // 在退出本层递归时，当前节点前缀和与其他分支无关，删除记录消除对其他分支的影响

        return;
    };


    dfs(root, 0);// 传入当前node = root, 前缀和 0
    return ans;
}



int main()
{
    /* 构建如下二叉树：  
                 10
               /    \
              5      -3
            /   \      \   
           3     2      11
          / \     \
         3  -2     1   
    */

    TreeNode* root = new TreeNode(10);
    root->left = new TreeNode(5);
    root->right = new TreeNode(-3);

    root->left->left = new TreeNode(3);
    root->left->right = new TreeNode(2);
    root->right->right = new TreeNode(11);
 
    root->left->left->left = new TreeNode(3);
    root->left->left->right = new TreeNode(-2);
    root->left->right->right = new TreeNode(1);

    int targetSum = 8;
    int ans = pathSum(root, targetSum);
    cout << ans << endl;

    return 0;
}

~~~





## 236 [二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250723101851927](pic/image-20250723101851927.png)

![image-20250723102634720](pic/image-20250723102634720.png)

![image-20250723103635617](pic/image-20250723103635617.png)

<img src="pic/image-20250723102143025.png" alt="image-20250723102143025" style="zoom:40%;" />

两种情况：

1、找到一个节点，**其左树出现p，右树出现q**，或者反过来，那么这个节点就是q p 最近公共祖先，返回这个节点

- 递归遍历，如果子树遇到p，就返回p，遇到q，就返回q
- 正好左右树各自遇到q p，就返回当时的root，即最近公共祖先；

<img src="pic/image-20250723102451273.png" alt="image-20250723102451273" style="zoom:33%;" />

2、遍历的时候，**找到节点就是p 或 q 本身，遇到就直接返回这个节点**（其实也包含在情况1里面）

<img src="pic/image-20250723102547943.png" alt="image-20250723102547943" style="zoom:33%;" />



~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

        if (root == p || root == q || root == nullptr)  return root;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);   // 往左找
        TreeNode* right = lowestCommonAncestor(root->right, p, q); // 往右找

        // 返回
        if (left && right)  return root;          // 左右树都找到，返回当前的root
        else if (!left && right)    return right; // 只有右树找到
        else if (left && !right)    return left;  // 只有左树找到
        else                        return nullptr; // 都没找到
        // return left ? left : right;
        
    }
};
~~~



> **如果递归函数有返回值，如何区分要搜索一条边，还是整棵树？？**
>
> ![image-20250723105523587](pic/image-20250723105523587.png)
>
> ![image-20250723105530711](pic/image-20250723105530711.png)





ACM

~~~C++
#include <iostream>
#include <unordered_map>
using namespace std;

// 236 二叉树的最近公共祖先

struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) 
{
    if (root == p || root == q || root == nullptr)  return root;

    TreeNode* left = lowestCommonAncestor(root->left, p, q);   // 往左找
    TreeNode* right = lowestCommonAncestor(root->right, p, q); // 往右找

    // 返回
    if (left && right)  return root;          // 左右树都找到，返回当前的root
    else if (!left && right)    return right; // 只有右树找到
    else if (left && !right)    return left;  // 只有左树找到
    else                        return nullptr; // 都没找到
    // return left ? left : right;
}



int main()
{
    /* 构建如下二叉树：  
                  3
                /    \
              5        1
            /  \      /  \   
           6    2    0    8
               / \    
              7   4        
    */

    TreeNode* root = new TreeNode(3);
    root->left = new TreeNode(5);
    root->right = new TreeNode(1);

    root->left->left = new TreeNode(6);
    root->left->right = new TreeNode(2);
    root->right->left = new TreeNode(0);
    root->right->right = new TreeNode(8);
 
    root->left->right->left = new TreeNode(7);
    root->left->right->right = new TreeNode(4);


    TreeNode* p = root->left;  // 5
    TreeNode* q = root->right; // 1

    TreeNode* node = lowestCommonAncestor(root, p, q);
    cout << node->val << endl;

    return 0;
}

~~~





# 回溯 ✅



## 78 [子集](https://leetcode.cn/problems/subsets/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250730155814806](pic/image-20250730155814806.png)

数组的 **子集** 是从数组中选择一些元素（可能为空）。

如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么**组合问题和分割问题都是收集树的叶子节点**，而**子集问题是找树的所有节点**

路径上所有节点都是子集。

![image-20250730155923923](pic/image-20250730155923923.png)

~~~C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;

    void backtracking(vector<int>& nums, int startIndex)
    {
        if (startIndex > nums.size())  return;

        for (int i = startIndex; i < nums.size(); i++)
        {
            path.push_back(nums[i]);
            result.push_back(path); // 处理节点的时候直接放进result

            backtracking(nums, i + 1);

            path.pop_back();
        }
    }


    vector<vector<int>> subsets(vector<int>& nums) {

        result.push_back(path); // 提前放一个空path进去
        backtracking(nums, 0);
        return result; 
    }
};
~~~



或者在 backtracking 里先收集path再结束，不会漏掉结果，也不用提前放一个空path了（好像第一种好理解）

~~~C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;

    void backtracking(vector<int>& nums, int startIndex)
    {
        result.push_back(path); // 进下一层的时候，先收集path
        if (startIndex > nums.size())   return;

        for (int i = startIndex; i < nums.size(); i++)
        {
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }

    vector<vector<int>> subsets(vector<int>& nums) {

        backtracking(nums, 0);
        return result;     
    }
};
~~~







## 39 [组合总和](https://leetcode.cn/problems/combination-sum/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250730151124538](pic/image-20250730151124538.png)

数组中数字都不同，但是可以重复选，每一层树往下走，遍历的数组都是一样的

返回条件就是取到的和，达到target直接返回

![image-20250730151359149](pic/image-20250730151359149.png)

![image-20250730151453688](pic/image-20250730151453688.png)

~~~C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex)
    {
        if (sum > target)   return;
        if (sum == target)
        {
            result.push_back(path);
            return;
        }

        for (int i = startIndex; i < candidates.size(); i++)
        {
            sum += candidates[i];
            path.push_back(candidates[i]);

            backtracking(candidates, target, sum, i); // 注意可以重复取当前的数

            sum -= candidates[i];
            path.pop_back();
        }
    }

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        // candidates = [2,3,6,7], target = 7
        // [[2,2,3],[7]]

        backtracking(candidates, target, 0, 0);
        return result;  
    }
};
~~~



**剪枝：**

> **在求和问题中，排序之后加剪枝是常见的套路！**

![image-20250730152552090](pic/image-20250730152552090.png)

![image-20250730152607877](pic/image-20250730152607877.png)

~~~C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex)
    {
        if (sum > target)   return;
        if (sum == target)
        {
            result.push_back(path);
            return;
        }

        for (int i = startIndex; 
             i < candidates.size() && sum + candidates[i] <= target; // 剪枝
             i++)
        {
            sum += candidates[i];
            path.push_back(candidates[i]);

            backtracking(candidates, target, sum, i); // 注意可以重复取当前的数

            sum -= candidates[i];
            path.pop_back();
        }
    }

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {

        sort(candidates.begin(), candidates.end()); // 先排序

        backtracking(candidates, target, 0, 0);
        return result;
        
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 39 组合总和


vector<int> path;
vector<vector<int>> result;

void backtracking(vector<int>& candidates, int target, int sum, int startIndex)
{
    if (sum > target)   return;
    if (sum == target)
    {
        result.push_back(path);
        return;
    }

    for (int i = startIndex; i < candidates.size(); i++)
    {
        sum += candidates[i];
        path.push_back(candidates[i]);

        backtracking(candidates, target, sum, i); // 注意可以重复取当前的数

        sum -= candidates[i];
        path.pop_back();
    }
}


vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
    // candidates = [2,3,6,7], target = 7
    // [[2,2,3],[7]]

    backtracking(candidates, target, 0, 0);
    return result;  
}



int main()
{
    vector<int> candidates = {2, 3, 6, 7};
    int target = 7;
    vector<vector<int>> result = combinationSum(candidates, target);
    for (int i = 0; i < result.size(); i++)
    {
        for (int val : result[i])
        {
            cout << val << " ";
        }
        cout << endl;
    }


    return 0;
}
~~~





## 17 [电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250731101546604](pic/image-20250731101546604.png)

![image-20250731101617321](pic/image-20250731101617321.png)

![image-20250731101623180](pic/image-20250731101623180.png)



~~~C++
class Solution {
public:

    const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs",// 7
        "tuv", // 8
        "wxyz" // 9
    };


    string path;
    vector<string> result;

    void backtracking(const string& digits, int digitsIndex)
    {
        // digitsIndex 是digits的下标，这里往下走就是取digits的下一个数，下一个字符组合

        if (digitsIndex == digits.size()) // digits取到最后一个，终止
        {
            result.push_back(path);
            return;
        }

        int digit = digits[digitsIndex] - '0'; // 把index指向的数字（字符型）转为int
        string letters = letterMap[digit]; // 取出对应的字符集

        // 处理单层的字符组合
        for (int i = 0; i < letters.size(); i++)
        {
            path.push_back(letters[i]);
            backtracking(digits, digitsIndex + 1);
            path.pop_back();
        }
    }

    
    vector<string> letterCombinations(string digits) {

        if (digits.size() == 0)  return result; // 这里要写，不然digits = ""输出的不是[] 而是""

        backtracking(digits, 0);
        return result;        
    }
};
~~~



ACM

~~~C++
#include <string>
#include <vector>
#include <iostream>
using namespace std;

// 17 电话号码的字母组合

const string letterMap[10] = {
    "", // 0
    "", // 1
    "abc", // 2
    "def", // 3
    "ghi", // 4
    "jkl", // 5
    "mno", // 6
    "pqrs",// 7
    "tuv", // 8
    "wxyz" // 9
};


string path;
vector<string> result;


void backtracking(const string& digits, int digitsIndex)
{
    // digitsIndex 是digits的下标，这里往下走就是取digits的下一个数，下一个字符组合
    if (digitsIndex == digits.size()) // digits取到最后一个，终止
    {
        result.push_back(path);
        return;
    }
    int digit = digits[digitsIndex] - '0'; // 把index指向的数字（字符型）转为int
    string letters = letterMap[digit]; // 取出对应的字符集
    // 处理单层的字符组合
    for (int i = 0; i < letters.size(); i++)
    {
        path.push_back(letters[i]);
        backtracking(digits, digitsIndex + 1);
        path.pop_back();
    }
}

vector<string> letterCombinations(string digits) 
{
    if (digits.size() == 0)  return result;
    backtracking(digits, 0);
    return result;        
}


int main()
{
    string digits = "23";
    vector<string> result = letterCombinations(digits);
    for (string s : result)
    {
        cout << s << ",";
    }
    cout << endl;


    return 0;
}
~~~













## 46 [全排列](https://leetcode.cn/problems/permutations/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250730104329081](pic/image-20250730104329081.png)

![image-20250731105210473](pic/image-20250731105210473.png)



![image-20250731105252437](pic/image-20250731105252437.png)

~~~C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;

    // used[i]: 往下走，used 记录这条之路上nums[i]已经取过

    void backtracking(vector<int>& nums, vector<bool>& used) 
    {
        if (path.size() == nums.size()) // 全排列，所有数字都要取到
        {
            result.push_back(path);
            return;
        }

        for (int i = 0; i < nums.size(); i++) // 每次都从0开始取
        {
            // 先判断当前nums[i]是否已经取过了，取过了就跳过
            if (used[i] == true)    continue;

            path.push_back(nums[i]);
            used[i] = true; 

            backtracking(nums, used);

            path.pop_back();
            used[i] = false; // used也要回溯
        }
    }


    vector<vector<int>> permute(vector<int>& nums) {

        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return result;        
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;


vector<int> path;
vector<vector<int>> result;

void backtracking(vector<int>& nums, vector<bool>& used)
{
    if (path.size() == nums.size())
    {
        result.push_back(path);
        return;
    }

    for (int i = 0; i < nums.size(); i++)
    {
        if (used[i])    continue;

        path.push_back(nums[i]);
        used[i] = true;

        backtracking(nums, used);

        path.pop_back();
        used[i] = false;
    }
}


int main()
{
    vector<int> nums = {1, 2, 3};
    vector<bool> used(nums.size(), false);
    backtracking(nums, used);

    for (int i = 0; i < result.size(); i++)
    {
        for (int val : result[i])
        {
            cout << val << " ";
        }
        cout << endl;
    }

    return 0;
}
~~~





## 131 [分割回文串](https://leetcode.cn/problems/palindrome-partitioning/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250801224310817](pic/image-20250801224310817.png)

![image-20250801224424477](pic/image-20250801224424477.png)

![image-20250801224455357](pic/image-20250801224455357.png)

![image-20250801224459434](pic/image-20250801224459434.png)

![image-20250801224717358](pic/image-20250801224717358.png)

~~~C++
class Solution {
public:

    // 判断回文
    bool isPalindrome(const string& s, int start, int end)
    {
        for (int i = start, j = end; i < j; i++, j--)
        {
            if (s[i] != s[j])   return false;
        }

        return true;
    }


    vector<string> path;
    vector<vector<string>> result;

    void backtracking(const string& s, int startIndex) 
    {
        // startIndex 下一轮递归遍历的起始位置
        // 终止：如果起始位置已经超出s，说明已经找到一组分割方案
        if (startIndex >= s.size())
        {
            result.push_back(path);
            return;
        }

        for (int i = startIndex; i < s.size(); i++)
        {
            if (isPalindrome(s, startIndex, i)) // 判断[startIndex, i]部分是否回文
            {
                // 是回文，截取[startIndex, i]
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            }
            else    continue; // 不是回文，直接跳过这一分支

            backtracking(s, i + 1);
            path.pop_back();
        }

    }


    vector<vector<string>> partition(string s) {

        backtracking(s, 0);
        return result;        
    }
};
~~~





ACM

~~~C++
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// 131 分割回文串


// 判断回文
bool isPalindrome(const string& s, int start, int end)
{
    for (int i = start, j = end; i < j; i++, j--)
    {
        if (s[i] != s[j])   return false;
    }
    return true;
}


vector<string> path;
vector<vector<string>> result;

// 递归
void backtracking(const string& s, int startIndex) 
{
    // startIndex 下一轮递归遍历的起始位置
    // 终止：如果起始位置已经超出s，说明已经找到一组分割方案
    if (startIndex >= s.size())
    {
        result.push_back(path);
        return;
    }
    for (int i = startIndex; i < s.size(); i++)
    {
        if (isPalindrome(s, startIndex, i)) // 判断[startIndex, i]部分是否回文
        {
            // 是回文，截取[startIndex, i]
            string str = s.substr(startIndex, i - startIndex + 1);
            path.push_back(str);
        }
        else    continue; // 不是回文，直接跳过这一分支
        backtracking(s, i + 1);
        path.pop_back();
    }
}


vector<vector<string>> partition(string s) {
    backtracking(s, 0);
    return result;        
}


int main()
{
    string s = "aab";
    vector<vector<string>> ans = partition(s);
    for (int i = 0; i < ans.size(); i++)
    {
        for (string s : ans[i])     cout << s << " , ";
        cout << endl;
    }

    return 0;
}
~~~



## 51 [N皇后](https://leetcode.cn/problems/n-queens/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250801233719344](pic/image-20250801233719344.png)

![image-20250801233800763](pic/image-20250801233800763.png)

![image-20250801233827062](pic/image-20250801233827062.png)

![image-20250801233833459](pic/image-20250801233833459.png)



![image-20250801233913833](pic/image-20250801233913833.png)

![image-20250801234013613](pic/image-20250801234013613.png)



![image-20250802000256173](pic/image-20250802000256173.png)



~~~C++
class Solution {
public:

    // 验证棋盘是否合法
    // 不能同行 同列 同斜线（45度和135度角）
    bool isValid(int row, int col, vector<string>& chessboard, int n)
    {
        // chessboard - n * n 棋盘

        // 检查列
        for (int i = 0; i < row; i++)
        {
            if (chessboard[i][col] == 'Q')  return false;
        }
        // 检查 45度
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)
        {
            if (chessboard[i][j] == 'Q')    return false;
        }
        // 检查 135度
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++)
        {
            if (chessboard[i][j] == 'Q')    return false;
        }
        
        return true;
    }


    vector<vector<string>> result;
    
    void backtracking(int n, int row, vector<string>& chessboard)
    {
        // n - 棋盘大小
        // row - 当前遍历到棋盘第几层了
        // chessboard - n * n 棋盘

        if (row == n) // 终止：遍历到最后一行
        {
            result.push_back(chessboard);
            return;
        }

        for (int col = 0; col < n; col++) // col 遍历每一列 往右走
        {
            if (isValid(row, col, chessboard, n))// 当前棋盘合法，继续放 Q
            {
                chessboard[row][col] = 'Q';
                backtracking(n, row + 1, chessboard); // 递归 往下走 row + 1
                chessboard[row][col] = '.'; // 回溯
            }

            // 棋盘不合法，放弃当前分支，直接往右走
        }
    }


    vector<vector<string>> solveNQueens(int n) {

        vector<string> chessboard(n, string(n, '.')); // 初始棋盘
        backtracking(n, 0, chessboard);
        return result;        
    }
};
~~~



ACM 

~~~C++
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// 51 N皇后

// 验证棋盘是否合法
// 不能同行 同列 同斜线（45度和135度角）
bool isValid(int row, int col, vector<string>& chessboard, int n)
{
    // chessboard - n * n 棋盘
    // 检查列
    for (int i = 0; i < row; i++)
    {
        if (chessboard[i][col] == 'Q')  return false;
    }
    // 检查 45度
    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)
    {
        if (chessboard[i][j] == 'Q')    return false;
    }
    // 检查 135度
    for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++)
    {
        if (chessboard[i][j] == 'Q')    return false;
    }
    
    return true;
}



vector<vector<string>> result;
// 递归
void backtracking(int n, int row, vector<string>& chessboard)
{
    // n - 棋盘大小
    // row - 当前遍历到棋盘第几层了
    // chessboard - n * n 棋盘
    if (row == n) // 终止：遍历到最后一行
    {
        result.push_back(chessboard);
        return;
    }
    for (int col = 0; col < n; col++) // col 遍历每一列 往右走
    {
        if (isValid(row, col, chessboard, n))// 当前棋盘合法，继续放 Q
        {
            chessboard[row][col] = 'Q';
            backtracking(n, row + 1, chessboard); // 递归 往下走 row + 1
            chessboard[row][col] = '.'; // 回溯
        }

        // 棋盘不合法，放弃当前分支，直接往右走
    }
}


vector<vector<string>> solveNQueens(int n) {
    vector<string> chessboard(n, string(n, '.')); // 初始棋盘
    backtracking(n, 0, chessboard);
    return result;        
}

int main()
{
    int n = 4;
    vector<vector<string>> ans = solveNQueens(n);
    for (int i = 0; i < ans.size(); i++)
    {
        for (string s : ans[i])     cout << s << endl;
        cout << endl;
    }

    return 0;
}
~~~









## 22 [括号生成](https://leetcode.cn/problems/generate-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250731111344522](pic/image-20250731111344522.png)



==**重点：右括号个数 <= 左括号个数 ！！！！！！**==



### 1、选或不选

![image-20250801220213092](pic/image-20250801220213092.png)

![image-20250801223635506](pic/image-20250801223635506.png)

![image-20250801220030102](pic/image-20250801220030102.png)

这里是直接覆盖旧值的，相当于原来的【撤销 + 插入新值】了。



~~~C++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> ans;
        string path(n * 2, 0); // n对括号

        // left right 是左右括号的数量
        auto dfs = [&](this auto&& dfs, int left, int right) ->void
        {
            // 终止：右括号填了n个，左括号一定也填了n个，所以此时填完2n个括号
            if (right == n) 
            {
                ans.emplace_back(path);
                return;
            }
            
            if (left < n) // 左括号少于n个，可以填左括号
            {
                path[left + right] = '('; // 直接覆盖
                dfs(left + 1, right);
            }
            if (right < left) // 可以填右括号
            {
                path[left + right] = ')'; // 直接覆盖
                dfs(left, right + 1);
            }
        };

        dfs(0, 0);
        return ans;
    }
};
~~~





### 2、枚举右括号个数，确定下一个左括号位置

![image-20250731114014059](pic/image-20250731114014059.png)

**重点：右括号个数 <= 左括号个数 ！！！！！！**

balance =  已填的左括号的个数 - 右括号的个数，为了保证**【右括号个数 <= 左括号个数】**

![image-20250801215836724](pic/image-20250801215836724.png)

~~~C++
class Solution {
public:
    vector<string> generateParenthesis(int n) {

        vector<string> ans;
        vector<int> leftIndex; // 记录左括号的下标

        // i:       目前填了 i 个括号
        // balance: 这 i 个括号中, 左括号个数 - 右括号个数 = balance，为了保证左括号 > 右
        auto dfs = [&](this auto&& dfs, int i, int balance)
        {
            // 终止：左括号下标的个数 = n，左括号确定了 n 个位置，填充左括号
            if (leftIndex.size() == n) 
            {
                string s(n * 2, ')');
                for (int j : leftIndex)  s[j] = '('; // 左括号下标处改成 '('

                ans.emplace_back(s); // 收集
                return;
            }


            // 枚举填 right = 0,1,2,3...,balance 个右括号
            // balance 约束  右括号的个数，一定要 <= 左括号，
            // 在 balance 的约束下，枚举填 1 个 ')'，填 2 个 ')', ... 之后，左括号的下标
            for (int right = 0; right <= balance; right++)
            {
                // 先填 right 个右括号，然后填 1 个左括号，记录左括号的下标 i + right
                leftIndex.push_back(i + right);
                dfs(i + right + 1, balance + (1 - right));
                leftIndex.pop_back();
            }
        };

        dfs(0, 0);
        return ans;        
    }
};
~~~



### ACM

~~~C++
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// 22 括号生成


vector<string> generateParenthesis(int n) 
{
    vector<string> ans;
    string path(n * 2, 0);

    // 输入已填的 左右括号数量
    auto dfs = [&](this auto&& dfs, int left, int right) ->void 
    {
        // 终止
        if (right == n)
        {
            ans.emplace_back(path);
            return;
        }
        if (left < n)
        {
            path[left + right] = '(';
            dfs(left + 1, right);
        }
        if (right < left)
        {
            path[left + right] = ')';
            dfs(left, right + 1);
        }
    };

    dfs(0, 0);
    return ans;
}

int main()
{
    int n = 3;
    vector<string> ans = generateParenthesis(n);

    for (string s : ans)
    {
        cout << s  << " , ";
    }
    cout << endl;
    
    return 0;
}
~~~



## 79 [单词搜索](https://leetcode.cn/problems/word-search/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250803110156692](pic/image-20250803110156692.png)

![image-20250803110223074](pic/image-20250803110223074.png)



### dfs

![image-20250803165202409](pic/image-20250803165202409.png)



~~~C++	
class Solution {
public:
    // 方向数组 下 上 右 左
    static constexpr int DIRS[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    bool exist(vector<vector<char>>& board, string word) {
        int m = board.size();
        int n = board[0].size();
        
        auto dfs = [&](this auto&& dfs, int i, int j, int k)->bool{
            if (board[i][j] != word[k]) return false; // 匹配失败

            if (k + 1 == word.size())   return true;  // 匹配成功

            board[i][j] = 0; // 标记访问过
            for (auto& [dx, dy] : DIRS) // 四个方向的相邻格子
            {
                int x = i + dx, y = j + dy; 
                // 没超过边界，并且后序字母都成功匹配
                if (0 <= x && x < m && 0 <= y && y < n && dfs(x, y, k + 1))
                {
                    return true;
                }
            }

            board[i][j] = word[k]; // 恢复
            
            return false; // 没搜到
        };


        // 每个格子都可以作为起点
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (dfs(i, j, 0))   return true;// 搜到了
            }
        }

        return false; // 没搜到
        
    }
};
~~~



### 优化剪枝

![image-20250803171053612](pic/image-20250803171053612.png)



~~~C++	
class Solution {
public:
    static constexpr int DIRS[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    bool exist(vector<vector<char>>& board, string word) 
    {
        unordered_map<char, int> board_cnt; // 收集board中每个字符的个数
        for (int i = 0; i < board.size(); i++)
        {
            for (char c : board[i])  board_cnt[c]++;
        }

        // 优化一：word中某个字符c的个数，超过board中这个字符的个数，直接false
        unordered_map<char, int> word_cnt;
        for (char c : word)
        {
            if (++word_cnt[c] > board_cnt[c]) return false; 
        }

        // 优化二：如果word的最后一个字符，在board中的出现次数较少，反转word进行搜索
        if (board_cnt[word.back()] < board_cnt[word[0]])
        {
            ranges::reverse(word);
        }



        int m = board.size();
        int n = board[0].size();
        
        auto dfs = [&](this auto&& dfs, int i, int j, int k)->bool{
            if (board[i][j] != word[k]) return false; // 匹配失败

            if (k + 1 == word.size())   return true;  // 匹配成功

            board[i][j] = 0; // 标记访问过
            for (auto& [dx, dy] : DIRS) // 四个方向的相邻格子
            {
                int x = i + dx, y = j + dy; 
                // 没超过边界，并且后序字母都成功匹配
                if (0 <= x && x < m && 0 <= y && y < n && dfs(x, y, k + 1))
                {
                    return true;
                }
            }

            board[i][j] = word[k]; // 恢复
            
            return false; // 没搜到
        };


        // 每个格子都可以作为起点
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (dfs(i, j, 0))   return true;// 搜到了
            }
        }

        return false; // 没搜到
        
    }
};
~~~



### ACM

~~~C++	
#include <iostream>
#include <vector>
#include <string>
#include <unordered_map>
#include <algorithm>
using namespace std;


// 79 单词搜索

const int DIRS[4][2] = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}};

bool existWord(vector<vector<char>>& board, string word)
{
    unordered_map<char, int> board_cnt;
    for (int i = 0; i < board.size(); i++)
    {
        for (char c : board[i])     board_cnt[c]++;
    }

    unordered_map<char, int> word_cnt;
    for (char c : word)
    {
        word_cnt[c]++;
    }

    for (char c : word)
    {
        if (word_cnt[c] > board_cnt[c]) return false;
    }     

    if (board_cnt[word.back()] < board_cnt[word[0]])    reverse(word.begin(), word.end());


    int m = board.size();
    int n = board[0].size();

    auto dfs = [&](this auto&& dfs, int i, int j, int k)->bool
    {
        if (board[i][j] != word[k]) return false;
        if (k == word.size() - 1)   return true;

        board[i][j] = 0;
        for (auto& [dx, dy] : DIRS)
        {
            int x = i + dx, y = j + dy;
            if (0 <= x && x < m && 0 <= y && y < n && dfs(x, y, k + 1))     return true;
        }

        board[i][j] = word[k];
        
        return false;
    };

    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (dfs(i, j, 0))   return true;
        }
    }

    return false;
}


int main()
{
    vector<vector<char>> board = {
        {'A','B','C','E'},
        {'S','F','C','S'},
        {'A','D','E','E'}};
    
    string word = "ABCCED";
    bool ans = existWord(board, word);
    cout << (ans ? "true" : "false") << endl;

    return 0;
}
~~~





# 二分查找 ✅

## 35 [搜索插入位置](https://leetcode.cn/problems/search-insert-position/?envType=study-plan-v2&envId=top-100-liked)

![image-20250727231303073](pic/image-20250727231303073.png)

比704、二分查找多了一个返回插入位置

~~~C++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        
        int left = 0;
        int right = nums.size() - 1; // [left, right] 左闭右闭

        while (left <= right)
        {
            int mid = left + ((right - left) / 2); // 防溢出

            if      (nums[mid] > target)    right = mid - 1;
            else if (nums[mid] < target)    left = mid + 1;
            else    return mid;
        }

        return right + 1; // 返回插入位置   
        
        // return left; 也可以

        // 二分查找退出while时的状态是 left > right
        // left  指向插入位置
        // right 指向比target小的最大值
        // right + 1 等价与 left  
    }
};
~~~



## 74 [搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/?envType=study-plan-v2&envId=top-100-liked)

![image-20250727233530173](pic/image-20250727233530173.png)

![image-20250727233543858](pic/image-20250727233543858.png)

[灵神](https://leetcode.cn/problems/search-a-2d-matrix/solutions/2783931/liang-chong-fang-fa-er-fen-cha-zhao-pai-39d74)

### 1、二分

矩阵每一行拼在一起，拼成一个递增数组，再二分。

但是不用真拼成一个数组，而是用坐标连起来

![image-20250728102218323](pic/image-20250728102218323.png)

<img src="pic/image-20250728103240713.png" alt="image-20250728103240713" style="zoom:50%;" />

~~~C++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {

        int m = matrix.size();
        int n = matrix[0].size();

        int left = 0;
        int right = m * n - 1; // 相当于遍历拼接成的 a[i] 从 0 到 m*n 
        while (left <= right)
        {
            int mid = left + ((right - left) / 2);

            int midNum = matrix[mid / n][mid % n];//取出a[mid] = matrix[mid/n][mid%n]
            
            if (midNum < target)    left = mid + 1;
            else if (midNum > target)   right = mid - 1;
            else    return true;
        }

        return false;
    }
};
~~~

- 时间复杂度：O(log(*mn*))，其中 *m* 和 *n* 分别为 *matrix* 的行数和列数。
- 空间复杂度：O(1)。





### 2、右上角排除

这里主要是为了接 240、搜索二维矩阵II，还是推荐二分法

<img src="pic/image-20250728104152041.png" alt="image-20250728104152041" style="zoom: 33%;" />

~~~C++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {

        int m = matrix.size();
        int n = matrix[0].size();

        int i = 0;      // 第i行
        int j = n - 1;  // 第j列
        while (i < m && j >= 0)
        {
            
            if      (matrix[i][j] < target)     i++; // 说明这一行都小于target
            else if (matrix[i][j] > target)     j--; // 往前走一列
            else    return true; // matrix[i][j] == target
        }
        
        return false;
    }
};
~~~

- 时间复杂度：O(*m*+*n*)，其中 *m* 和 *n* 分别为 *matrix* 的行数和列数。
- 空间复杂度：O(1)。



## 34 [在排序数组中查找第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/?envType=study-plan-v2&envId=top-100-liked)

![image-20250728114911125](pic/image-20250728114911125.png)

![image-20250728114928976](pic/image-20250728114928976.png)

![image-20250728114936668](pic/image-20250728114936668.png)

![image-20250728114942560](pic/image-20250728114942560.png)

~~~C++
class Solution {
public:

    // nums = [5,  7,  7,  8,  8,  10], target = 8
    //                 |            |
    //            leftBorder     rightBorder


    // 找第一个比 target 大的位置
    int getRightBorder(vector<int>& nums, int target)
    {
        int left = 0;
        int right = nums.size() - 1;
        
        // 当前第一个大于 target 的位置
        int rightBorder = -2; // -2 记录rightBorder没有被赋值的情况
        while (left <= right)
        {
            int mid = left + ((right - left) / 2);
            if (nums[mid] <= target) // 向右缩小范围
            {
                left = mid + 1;
                rightBorder = left;// 新的left就是下一个可能大于target的位置
            }
            else 
            {
                right = mid - 1; 
            }
        }
        return rightBorder;
    }

    // 找最后一个比 target 小的位置
    int getLeftBorder(vector<int>& nums, int target)
    {
        int left = 0;
        int right = nums.size() - 1;
        
        // 最后一个比 target 小的位置
        int leftBorder = -2; 
        while (left <= right)
        {
            int mid = left + ((right - left) / 2); 
            if (target <= nums[mid]) // 向左缩小范围
            {
                right = mid - 1;
                leftBorder = right; // 新right 就是下一个可能小于 target 的位置
            }
            else 
            {
                left = mid + 1;
            }
        }
        return leftBorder;
    }


    vector<int> searchRange(vector<int>& nums, int target) {

        int leftBorder = getLeftBorder(nums, target);
        int rightBorder = getRightBorder(nums, target);


        // 情况一：target 在数组范围的右边或者左边，不再数组范围中
        if (leftBorder == -2 || rightBorder== -2)   return {-1, -1};

        
        // 情况三：target 在数组范围中，且数组中存在target
        if (rightBorder - leftBorder > 1)   return {leftBorder + 1, rightBorder - 1};
        
        
        // 情况二：target 在数组范围中，且数组中不存在target
        return {-1, -1};

        
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <vector>
using namespace std;


// 34. 在排序数组中查找元素的第一个和最后一个位置


// nums = [5,  7,  7,  8,  8,  10], target = 8
//                 |            |
//            leftBorder     rightBorder


// 找第一个比 target 大的位置 rightBorder
int getRightBorder(vector<int>& nums, int target)
{
    int left = 0;
    int right = nums.size() - 1;
    
    // 当前第一个大于 target 的位置
    int rightBorder = -2; // -2 记录rightBorder没有被赋值的情况
    while (left <= right)
    {
        int mid = left + ((right - left) / 2);
        if (nums[mid] <= target) // 向右缩小范围
        {
            left = mid + 1;
            rightBorder = left;// 新的left就是下一个可能大于target的位置
        }
        else 
        {
            right = mid - 1; 
        }
    }
    return rightBorder;
}


// 找最后一个比 target 小的位置 leftBorder
int getLeftBorder(vector<int>& nums, int target)
{
    int left = 0;
    int right = nums.size() - 1;
    
    // 最后一个比 target 小的位置
    int leftBorder = -2; 
    while (left <= right)
    {
        int mid = left + ((right - left) / 2); 
        if (target <= nums[mid]) // 向左缩小范围
        {
            right = mid - 1;
            leftBorder = right; // 新right 就是下一个可能小于 target 的位置
        }
        else 
        {
            left = mid + 1;
        }
    }
    return leftBorder;
}


vector<int> searchRange(vector<int>& nums, int target) 
{
    int leftBorder = getLeftBorder(nums, target);
    int rightBorder = getRightBorder(nums, target);

    // 情况一：target 在数组范围的右边或者左边，不再数组范围中
    if (leftBorder == -2 || rightBorder== -2)   return {-1, -1};
    
    // 情况三：target 在数组范围中，且数组中存在target
    if (rightBorder - leftBorder > 1)   return {leftBorder + 1, rightBorder - 1};
    
    
    // 情况二：target 在数组范围中，且数组中不存在target
    return {-1, -1};
    
}

int main()
{
    vector<int> nums = {5, 7, 7, 8, 8, 10};
    int target = 8;
    vector<int> ans = searchRange(nums, target); // [3, 4]
    for (int val : ans)
    {
        cout << val << " ";
    }
    cout << endl;

    return 0;
}
~~~



## 153 [寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250729145936680](pic/image-20250729145936680.png)

可以先看 [162 峰值](#162 [寻找峰值](https://leetcode.cn/problems/find-peak-element/description/))



**主要思路：比较 nums[mid] 和最后一个数，判断 mid 和 最小值 的位置，二分收缩**

- nums[mid] > 最后一个数：
  - nums 一定是两个上升段，第一段  >  第二段
  - **mid 在第一段，min 在第二段**，min 一定在 mid 的**右边**  –>  向右收缩
- nums[mid] <= 最后一个数：
  - mid 在第二段（或者 nums 只有一段，一样的），或者说 **mid 和 min 在同一段**
  - **min 一定在mid 左侧**，或者就是mid –> 向左收缩



![image-20250729152923722](pic/image-20250729152923722.png)

~~~C++
class Solution {
public:
    int findMin(vector<int>& nums) {

        int n = nums.size();
        int left = 0;
        int right = n - 1;

        while (left <= right)
        {
            int mid = left + ((right - left) / 2);

            if (nums[mid] > nums[n - 1])    left = mid + 1;// mid在第一段，min在第二段
            else    right = mid - 1; // mid 和 min 在同一段，且 min 在左

        }

        return nums[left]; 
    }
};
~~~



ACM 

~~~C++
#include <iostream>
#include <vector>
using namespace std;

// 153 寻找旋转排序数组中的最小值


int findMin(vector<int>& nums) {

    int n = nums.size();
    int left = 0;
    int right = n - 1;

    while (left <= right)
    {
        int mid = left + ((right - left) / 2);

        if (nums[mid] > nums[n - 1])    left = mid + 1;// mid在第一段，min在第二段
        else    right = mid - 1; // mid 和 min 在同一段，且 min 在左

    }

    return nums[left]; 
}


int main()
{
    vector<int> nums = {3, 4, 5, 1, 2};
    int ans = findMin(nums);
    cout << ans << endl;

    return 0;
}
~~~







## 33 [搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250729102714988](pic/image-20250729102714988.png)

> 前提题目：可以先看 162 峰值，153 寻找旋转排序数组的最小值

### 1、两次二分

![image-20250729154124632](pic/image-20250729154124632.png)

~~~C++
class Solution {
public:
    // 找旋转排序数组的最小值下标（153）
    int findMin(vector<int>& nums) {
        int n = nums.size();
        int left = 0;
        int right = n - 1;
        while (left <= right)
        {
            int mid = left + ((right - left) / 2);
            if (nums[mid] > nums[n - 1])    left = mid + 1;// mid在第一段，min在第二段
            else    right = mid - 1; // mid 和 min 在同一段，且 min 在左
        }
        return left; 
    }

    // [left, right]二分，找target下标
    int searchTarget(vector<int>& nums, int target, int left, int right) {
        while (left <= right)
        {
            int mid = left + ((right - left) / 2); 
            if      (nums[mid] > target)    right = mid - 1;
            else if (nums[mid] < target)    left = mid + 1;
            else    return mid;
        }
        return -1; // 没找到返回-1  
    }

    
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        int ans = 0;
        int left = 0;
        int right = n - 1;

        int min_index = findMin(nums); // 找到最小值，区分第一段第二段

        if (target > nums[n - 1])  // target 在第一段，[0, min_index-1], 向左收缩 
        { 
            right = min_index - 1;
            ans = searchTarget(nums, target, left, right);         
        }
        else // target <= nums[n - 1] target 在第二段，[min_index, n-1]，向右收缩  
        {
            left = min_index;
            ans = searchTarget(nums, target, left, right);

            // 注意这里要带着min判断, target有可能就是min
        }

        return ans;        
    }
};
~~~



### 2、一次二分(推荐)

直接判断 target 和 mid 的左右关系，分成target和mid在不在同一段两种情况

- 不在同一段，分 mid 在 target 左还是右
- 在同一段，就是普通二分查找了

~~~C++
class Solution {
public:
    int search(vector<int>& nums, int target) {

        int n = nums.size();
        int end = nums[n - 1];
        int left = 0;
        int right = n - 1;

        while (left <= right)
        {
            int mid = left + (right - left) / 2;

            // target 和 mid 不在同一段
            if (target <= end && nums[mid] > end) // target在右半部分，mid在左
            {
                left = mid + 1;
            }
            else if (target > end && nums[mid] <= end) // target在左半部分，mid在右
            {
                right = mid - 1;
            }
            else // target 和 mid 在同一段（也包括了只有一段的情况）
            {
                if (target < nums[mid])         right = mid - 1;
                else if (target > nums[mid])    left = mid + 1;
                else    return mid;
            }
        }
        
        return -1;        
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <vector>
using namespace std;

// 33 搜索旋转排序数组


int searchTarget(vector<int>& nums, int target) 
{
    int n = nums.size();
    int end = nums[n - 1];
    int left = 0;
    int right = n - 1;

    while (left <= right)
    {
        int mid = left + (right - left) / 2;

        // target 和 mid 不在同一段
        if (target <= end && nums[mid] > end) // target在右半部分，mid在左
        {
            left = mid + 1;
        }
        else if (target > end && nums[mid] <= end) // target在左半部分，mid在右
        {
            right = mid - 1;
        }
        else // target 和 mid 在同一段（也包括了只有一段的情况）
        {
            if (target < nums[mid])         right = mid - 1;
            else if (target > nums[mid])    left = mid + 1;
            else    return mid;
        }
    }
    
    return -1;        
}




int main()
{
    vector<int> nums = {4,5,6,7,0,1,2};
    int target = 0;

    int ans = searchTarget(nums, target);
    cout << ans << endl;

    return 0;
}
~~~





## 4 [寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250729163051465](pic/image-20250729163051465.png)

[背吧](https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/2950686/tu-jie-xun-xu-jian-jin-cong-shuang-zhi-z-p2gd)

好像看懂了



### 1、双指针

**中位数 —— 均分数组，能把一组数平均划分为大小相等的两部分。**

假设有**两个新数组**，就是均分完的那两个数组，现在分别从题目给定的nums1 和 nums2 中取数（下面用a和b）。

找中位数，要保证**第一个新数组的最大值 <  第二个新数组的最小值**，接缝处就是要找的中位数。

左右都插入 −∞ 和 ∞ ，保证无论 a 和 b 是什么样的，一定存在一个 i，满足 a i ≤ b j+1  且 a i+1 >b j 。

<img src="pic/image-20250729175844683.png" alt="image-20250729175844683" style="zoom:50%;" />

![image-20250729180032142](pic/image-20250729180032142.png)

![image-20250729180056845](pic/image-20250729180056845.png)

![image-20250729173653971](pic/image-20250729173653971.png)

![image-20250729180241532](pic/image-20250729180241532.png)

~~~C++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {

        if (nums1.size() > nums2.size())    swap(nums1, nums2); // 保证nums1是少的那个

        // m < n 
        int m = nums1.size(), n = nums2.size(); 

        // 左右插上负无穷，和正无穷
        nums1.insert(nums1.begin(), INT_MIN);
        nums1.push_back(INT_MAX);
        nums2.insert(nums2.begin(), INT_MIN);
        nums2.push_back(INT_MAX);

        // 枚举 nums1 有 i 个数在第一组
        // 那么 nums2 有 j = (m + n + 1) / 2 - i 个数在第一组 
        int i = 0;
        int j = (m + n + 1) / 2;
        while (true)
        {
            // 找到第一组都小于第二组的情况
            if (nums1[i] <= nums2[j + 1] && nums1[i + 1] > nums2[j])// 写 >= 也可以
            {
                int max1 = max(nums1[i], nums2[j]);         // 第一组的最大值
                int min2 = min(nums1[i + 1], nums2[j + 1]); // 第二组的最小值

                if ( (m + n) % 2) // 奇数个，第一组多一个，max1就是中位数
                {
                    return max1; 
                }
                else // 偶数个，接缝处区均值
                {
                    return (max1 + min2) / 2.0;
                }
            }

            // 继续枚举
            i++;
            j--;
        }        
    }
};
~~~





### 2、二分

明天再看，缓缓脑子，太炸裂了





### ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 4 寻找两个正序数组中的中位数

double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {

    if (nums1.size() > nums2.size())    swap(nums1, nums2); // 保证nums1是少的那个

    // m < n 
    int m = nums1.size(), n = nums2.size(); 

    // 左右插上负无穷，和正无穷
    nums1.insert(nums1.begin(), INT_MIN);
    nums1.push_back(INT_MAX);
    nums2.insert(nums2.begin(), INT_MIN);
    nums2.push_back(INT_MAX);

    // 枚举 nums1 有 i 个数在第一组
    // 那么 nums2 有 j = (m + n + 1) / 2 - i 个数在第一组 
    int i = 0;
    int j = (m + n + 1) / 2;
    while (true)
    {
        // 找到第一组都小于第二组的情况
        if (nums1[i] <= nums2[j + 1] && nums1[i + 1] > nums2[j])// 写 >= 也可以
        {
            int max1 = max(nums1[i], nums2[j]);         // 第一组的最大值
            int min2 = min(nums1[i + 1], nums2[j + 1]); // 第二组的最小值

            if ( (m + n) % 2) // 奇数个，第一组多一个，max1就是中位数
            {
                return max1; 
            }
            else // 偶数个，接缝处区均值
            {
                return (max1 + min2) / 2.0;
            }
        }

        // 继续枚举
        i++;
        j--;
    }        
}


int main()
{
    vector<int> nums1 = {1, 2};
    vector<int> nums2 = {3, 4};
    double result = findMedianSortedArrays(nums1, nums2);
    cout << result << endl;
}
~~~









## 69 [x的平方根](https://leetcode.cn/problems/sqrtx/description/)

![image-20250911175903043](./pic/image-20250911175903043.png)

### 1、二分

![image-20250911180546118](./pic/image-20250911180546118.png)

~~~C++
class Solution {
public:
    int mySqrt(int x) {
        
        // 在中间过程计算平方的时候可能出现溢出，所以用long long
        
        // x 平方根的整数部分 ans 是满足 k^2 ≤x 的最大 k 值

        // 二分 0 ~ x，找到最大的 k
        int l = 0, r = x;
        int ans = -1;

        while (l <= r)
        {
            int mid = l + (r - l) / 2;
            if ((long long)mid * mid <= x)
            {
                ans = mid;
                l = mid + 1;
            }
            else 
            {
                r = mid - 1;
            }
        }

        return ans;        
    }
};
~~~



### 2、牛顿迭代法

利用切线逼近曲线的方程的解   [题解 仗剑骑士](https://leetcode.cn/problems/sqrtx/solutions/1408932/by-zhang-jian-qi-shi-kaxt)

![image-20250911184031634](./pic/image-20250911184031634.png)



~~~C++
class Solution {
public:
    int mySqrt(int x) {

        int a = x;
        long long ans = x;

        while (ans * ans > x) // 推出来的 x_n+1 的递推公式，递推直到ans*ans<=x
        {
            ans = (ans + a / ans) / 2; 
        }

        return ans;
    }
};
~~~







# 栈 ✅

## 20 [有效的括号](https://leetcode.cn/problems/valid-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250725112258499](pic/image-20250725112258499.png)

> **注意看给的示例，题目描述不清楚**
>
> **必须是 “ ( [ { } ] )  [ ] ” 这种成对的顺序，不能交叉放不同类型的括号  “ [ ( ] ) ”**

**栈来存储字符串s里的括号：**

遍历s

- 根据s里的左括号，往栈里放对应的右括号；

- 遇到s里的右括号，能对应上栈顶元素，就弹出栈顶

<img src="pic/image-20250725110437842.png" alt="image-20250725110437842" style="zoom:33%;" />

不匹配的情况：

- 左括号多余 —— 遍历完字符串，但是栈不为空
- 括号不匹配 —— 发现栈里没有要匹配的字符
- 右括号多余 —— 遍历字符串匹配的过程中，栈已经为空了

匹配的表现：

- **字符串遍历完，栈也是空的**



~~~C++
class Solution {
public:
    bool isValid(string s) {

        if (s.size() % 2 != 0)  return false; // 如果 s 的长度是奇数，一定不匹配

        stack<char> st; // 根据 s 的左括号，放入相应的右括号
        
        // 三种情况：
        // 1 左括号多余 -- s遍历完，栈不为空
        // 2 括号不匹配 -- s遍历过程中，栈顶括号不匹配
        // 3 右括号多余 -- s遍历过程中，栈已经空

        for (int i = 0; i < s.size(); i++)
        {
            // 根据 s 里的左括号，往栈里加入对应的右括号
            if (s[i] == '(')        st.push(')');
            else if (s[i] == '[')   st.push(']');
            else if (s[i] == '{')   st.push('}');

            // 第3种 和 第2种 情况，直接false （注意if里顺序不能换）
            else if (st.empty() || st.top() != s[i])    return false; 

            // st.top() == s[i] 遍历到对应的右括号就弹出栈顶
            else    st.pop();
        }

        // 第1种 情况，遍历完s，但栈不为空，这里就返回false
        // 如果为空，说明符合要求，返回的是true
        return st.empty();
        
    }
};
~~~





ACM 

~~~C++
#include <string>
#include <iostream>
#include <stack>
using namespace std;

// 20 有效的括号


bool isValid(string s) 
{
    if (s.size() % 2 != 0)  return false; // 如果 s 的长度是奇数，一定不匹配

    stack<char> st; // 根据 s 的左括号，放入相应的右括号
    
    // 三种情况：
    // 1 左括号多余 -- s遍历完，栈不为空
    // 2 括号不匹配 -- s遍历过程中，栈顶括号不匹配
    // 3 右括号多余 -- s遍历过程中，栈已经空

    for (int i = 0; i < s.size(); i++)
    {
        // 根据 s 里的左括号，往栈里加入对应的右括号
        if (s[i] == '(')        st.push(')');
        else if (s[i] == '[')   st.push(']');
        else if (s[i] == '{')   st.push('}');

        // 第3种 和 第2种 情况，直接false （注意if里顺序不能换）
        else if (st.empty() || st.top() != s[i])    return false; 

        // st.top() == s[i] 遍历到对应的右括号就弹出栈顶
        else    st.pop();
    }

    // 第1种 情况，遍历完s，但栈不为空，这里就返回false
    // 如果为空，说明符合要求，返回的是true
    return st.empty();
}


int main()
{
    string s = "()[]{(}";
    bool result = isValid(s);
    cout << (result ? "true" : "false") << endl;

    return 0;
}
~~~





## [155 最小栈](https://leetcode.cn/problems/min-stack/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250726105802631](pic/image-20250726105802631.png)

![image-20250726110007671](pic/image-20250726110007671.png)



~~~C++
class MinStack {

    stack<pair<int, int>> st;

public:
    // 初始化
    MinStack() {
        // 添加栈底哨兵 INT_MAX
        // 这里的 0 写成任意数都可以，反正用不到
        st.emplace(0, INT_MAX); 
    }
    
    void push(int val) {
        st.emplace(val, min(getMin(), val)); // <val, 前缀最小值>       
    }
    
    void pop() {
        st.pop();
    }
    
    int top() {
        return st.top().first;
    }
    
    // 最小值
    int getMin() {
        return st.top().second;        
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
~~~



时间复杂度：所有操作均为 O(1)。
空间复杂度：O(q)。其中 q 是 push 调用的次数。最坏情况下，只有 push 操作，需要 O(q) 的空间保存元素。



ACM

~~~C++
#include <iostream>
#include <stack>

using namespace std;

// 155 最小栈

class MinStack 
{

    stack<pair<int, int>> st;

public:
    // 初始化
    MinStack() {
        // 添加栈底哨兵 INT_MAX
        // 这里的 0 写成任意数都可以，反正用不到
        st.emplace(0, INT_MAX); 
    }
    
    void push(int val) {
        st.emplace(val, min(getMin(), val)); // <val, 前缀最小值>       
    }
    
    void pop() {
        st.pop();
    }
    
    int top() {
        return st.top().first; // val
    }
    
    // 最小值
    int getMin() {
        return st.top().second; // 前缀最小值  
    }
};


int main()
{
    MinStack mt;
    mt.push(-2);
    mt.push(0);
    mt.push(-3);
    cout << "min: " << mt.getMin() << endl;
    mt.pop();
    cout << "st_top: " << mt.top() << endl;

    return 0;

}
~~~





## [394 字符串解码](https://leetcode.cn/problems/decode-string/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250727104739027](pic/image-20250727104739027.png)

### 1、[两个栈](https://leetcode.cn/problems/decode-string/solutions/6274/ti-jie-czhan-by-youlookdeliciousc)

**主要思路：两个栈存左括号前的数字，字符，遇到右括号的时候取出来拼接**

举个例子看吧	

~~~C++
class Solution {
public:
    string decodeString(string s) {
        
        int num = 0;
        stack<int> numStack;    // 存数字

        string res = "";
        stack<string> strStack; // 存字母

        for (int i = 0; i < s.size(); i++)
        {
            // 遇到数字，存在num
            if (s[i] >= '0' && s[i] <= '9') 
            {
                num = num * 10 + s[i] - '0';// 考虑数字可能不只是个位数，比如150[a]
            }
            // 字母直接拼到res
            else if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z'))
            {
                res = res + s[i]; 
            }
            // 遇到'['，将 '[' 前的数字放进numStack，字母字符放入strStack
            else if (s[i] == '[') 
            {
                numStack.push(num);
                num = 0;
                strStack.push(res);
                res = "";
            }
            // 遇到 ']' 开始处理这一组 [] 拼接
            else 
            {
                int times = numStack.top(); // 拼接几次res
                numStack.pop();

                for (int j = 0; j < times; j++)
                {
                    strStack.top() += res; // strStack顶的字符，拼接res
                }

                res = strStack.top(); // 这里res就是暂时拼接完的这一组字符了
                strStack.pop();
            }
        }

        return res; 
    }
};
~~~



### 2、[递归](https://leetcode.cn/problems/decode-string/solutions/19447/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd)

将 `[` 和 `]` 分别作为递归的开启与终止条件

-  `s[i] == '['` 时，进入新一层递归，res拼接新内层子串

-  `s[i] == ']'` 时，结束本层递归，返回res
- 普通字符直接拼接res
- 遍历完毕后返回 `res`



~~~C++
class Solution {
public:
    // 负责解码从当前 index 开始的子字符串
    string dfs(const string& s, int& index)
    {
        string res; 	// 当前层解码后的字符串
        int multi = 0;  // 记录数字，[]中的内容的重复次数

        while (index < s.size())
        {
			// 当前字符是数字，累计multi
            if (s[index] >= '0' && s[index] <= '9')
            {
                multi = multi * 10 + (s[index] - '0');
            }
            // 遇到 [ 就进入递归，开始一个新的被重复的子串
            else if (s[index] == '[') 
            {
                index++; // 跳过 [
                string tmp = dfs(s, index); // 递归解析 '[' 之后的内容
                while (multi--) res += tmp; // 拼接解析出的子串，重复拼接multi次
                multi = 0;
            }
            else if (s[index] == ']') // 遇到 ]，表示本次递归结束，返回当前拼接结果
            {
                return res;
            }
            else // s[i] == 普通字符
            {
                res += s[index]; // 直接加入结果
            }

            index++;            
        }

        return res;
    }


    string decodeString(string s) {
        int index = 0;
        return dfs(s, index);
        
    }
};
~~~



用 lambda

~~~C++
class Solution {
public:
    string decodeString(string s) {

        auto dfs = [&](this auto&& dfs, const string& s, int& index) ->string
        {
            string res;
            int multi = 0;
            while (index < s.size())
            {
                if (s[index] >= '0' && s[index] <= '9')
                {
                    multi = multi * 10 + (s[index] - '0');
                }
                else if (s[index] == '[')
                {
                    index++;
                    string tmp = dfs(s, index); // 递归解析 新'['之后的内容
                    while (multi--) res += tmp; // 拼接解析出的子串
                    multi = 0;
                }
                else if (s[index] == ']')
                {
                    return res;
                }
                else // 普通字符，直接拼接res
                {
                    res += s[index];
                }

                index++;
            }
            return res;
        };

        int index = 0;
        return dfs(s, index);
    }
};
~~~







### ACM

~~~C++
#include <iostream>
#include <vector>
#include <string>
#include <stack>
using namespace std;

// 394 字符串解码
// 输入：s = "3[a2[c]]"
// 输出："accaccacc"

string decodeString(string s) {
    
    int num = 0;
    stack<int> nums;    // 存数字
    string res = "";
    stack<string> strs; // 存字母

    for (int i = 0; i < s.size(); i++)
    {
        // 遇到数字，存在num
        if (s[i] >= '0' && s[i] <= '9') 
        {
            num = num * 10 + s[i] - '0';// 考虑数字可能不只是个位数，比如150[a]
        }
        // 字母直接拼到res
        else if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z'))
        {
            res = res + s[i]; 
        }
        // 遇到'['，将 '[' 前的数字放进nums栈，字母字符放入strs栈
        else if (s[i] == '[') 
        {
            nums.push(num);
            num = 0;
            strs.push(res);
            res = "";
        }
        // 遇到 ']' 开始处理这一组 [] 拼接
        else 
        {
            int times = nums.top(); // 拼接几次res
            nums.pop();
            for (int j = 0; j < times; j++)
            {
                strs.top() += res; // strs顶的字符，拼接res
            }
            res = strs.top(); // 这里res就是暂时拼接完的这一组字符了
            strs.pop();
        }
    }
    return res; 
}

int main()
{
    string s = "3[a2[c]]";
    string ans = decodeString(s);
    cout << ans << endl;

    return 0;
}
~~~



## [739 每日温度](https://leetcode.cn/problems/daily-temperatures/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250727165610930](pic/image-20250727165610930.png)

[灵神 单调栈](https://www.bilibili.com/video/BV1VN411J7S7/?vd_source=7369d5f08520f2fc3601caee93963ffa)



### 1、从右到左

栈中记录下一个更大元素的「候选项」的下标。

<img src="pic/image-20250727172548794.png" alt="image-20250727172548794" style="zoom:50%;" />

<img src="pic/image-20250727172559655.png" alt="image-20250727172559655" style="zoom:50%;" />

~~~C++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        // temperatures = [73,74,75,71,69,72,76,73]

        int n = temperatures.size();
        vector<int> ans(n);
        stack<int> st; // 存的是下标

        // 从左到右算，栈顶到栈底递增
        for (int i = n - 1; i >= 0; i--)
        {
            int t = temperatures[i];

            // pop出栈里 小于当前温度 t 的元素
            while (!st.empty() && t >= temperatures[st.top()]) 
            {
                st.pop();
            } 

            // 如果此时 st 不空，st.top()就是第一个大于 t 的元素，收集下标差
            if (!st.empty()) 
            {
                ans[i] = st.top() - i;
            } // else 如果此时 st 空，说明 t 后面没有大于它的元素，保持原始的 0

            // 栈收集当前 t 的坐标
            st.push(i);
        }

        return ans;       
    }
};
~~~

时间复杂度：O(n)，其中 n 为 temperatures 的长度。虽然我们写了个二重循环，但站在每个元素的视角看，这个元素在二重循环中最多入栈出栈各一次，因此循环次数之和是 O(n)，所以时间复杂度是 O(n)。
空间复杂度：O(min(n,U))，其中 U=max(temperatures)−min(temperatures)+1。返回值不计入，仅考虑栈的最大空间消耗。



### 2、从左到右

栈中记录还没算出下一个更大元素的那些数的下标。

<img src="pic/image-20250727173215630.png" alt="image-20250727173215630" style="zoom:50%;" />

~~~C++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        // temperatures = [73,74,75,71,69,72,76,73]

        int n = temperatures.size();
        vector<int> ans(n);
        stack<int> st; // 存的是下标 （没找到下一个最大值的数）

        // 从左往右，栈顶到栈底递增
        for (int i = 0; i < n; i++)
        {
            int t = temperatures[i];

            // 当前 t 大于栈顶，那 t 就是栈顶的下一个更大值
            while (!st.empty() && t > temperatures[st.top()])
            {
                int j = st.top();
                st.pop();
                ans[j] = i - j; // 注意这里收集的是栈顶那个元素对应的 ans[j]
            } 
            
            // t 入栈
            st.push(i);
        }

        return ans;       
    }
};
~~~

时间复杂度：O(*n*)，其中 *n* 为 *temperatures* 的长度。虽然我们写了个二重循环，但站在每个元素的视角看，这个元素在二重循环中最多入栈出栈各一次，因此循环次数**之和**是 O(*n*)，所以时间复杂度是 O(*n*)。

空间复杂度：O(*n*)。注意这种写法栈中可以有重复元素。



### ACM

~~~C++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

// 739 每日温度

vector<int> dailyTemperatures(vector<int>& temperatures) 
{
    // temperatures = [73,74,75,71,69,72,76,73]  找对于第 i 天，下一个更高温度出现在几天后

    int n = temperatures.size();
    vector<int> ans(n);
    stack<int> st; // 存的是下标 （没找到下一个最大值的数）

    // 从左往右，栈顶到栈底递增
    for (int i = 0; i < n; i++)
    {
        int t = temperatures[i];

        // 当前 t 大于栈顶，那 t 就是栈顶的下一个更大值
        while (!st.empty() && t > temperatures[st.top()])
        {
            int j = st.top();
            st.pop();
            ans[j] = i - j; // 注意这里收集的是栈顶那个元素对应的 ans[j]
        } 
        
        // t 入栈
        st.push(i);
    }

    return ans;       
}


int main()
{
    vector<int> temperatures = {73, 74, 75, 71, 69, 72, 76, 73};
    vector<int> ans = dailyTemperatures(temperatures); // 1 1 4 2 1 1 0 0 
    for (int val : ans)
    {
        cout << val << " ";
    }
    cout << endl;

    return 0;
}
~~~







## [84 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250727175437601](pic/image-20250727175437601.png)

太乱了，想不到，举例子看吧



![image-20250727184702493](pic/image-20250727184702493.png)

![image-20250727184713757](pic/image-20250727184713757.png)

![image-20250727184749648](pic/image-20250727184749648.png)

![image-20250727184754379](pic/image-20250727184754379.png)

~~~C++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        
        // 找当前柱子左右第一个比它小的柱子下标
        // 计算当前柱子能扩展的宽度，再计算能扩展的面积，遍历找最大值

        int result = 0;

        stack<int> st; // 栈里存遍历过的待计算面积的柱子
        st.push(0);

        // heights 首尾都插入0，为了不空栈，如果当前柱子只有自己一个宽度的话，也要能走到计算面积那里
        heights.insert(heights.begin(), 0);
        heights.insert(heights.end(), 0);

        for (int i = 1; i < heights.size(); i++)
        {
            // heights[i] > 栈顶
            if (heights[i] > heights[st.top()]) 
            {
                st.push(i);
            }
            else if (heights[i] == heights[st.top()])   
            {
                st.pop(); // 也可以不pop，多算一次0
                st.push(i);
            }
            else 
            {
                // heights[i] < 栈顶 遇到比自己（栈顶）小的，就说明栈顶这个元素不能向右扩展了
                while (!st.empty() && heights[i] < heights[st.top()])
                {
                    int cur = st.top(); // 栈顶，下面算得是【栈顶元素的面积】
                    st.pop();

                    if (!st.empty())
                    {
                        int left = st.top();
                        int right = i;
                        int w = right - left - 1; // 当前柱子能扩展的宽度
                        int h = heights[cur];     // 当前柱子的高度

                        result = max(result, h * w); // 更新为所有柱子中能扩展的面积最大值
                    }
                }

                st.push(i);
            }
        }

        return result;
        
    }
};
~~~





# 堆 ✅

## 215 [数组中的第 K 个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/submissions/649625107/?envType=study-plan-v2&envId=top-100-liked)

![image-20250804110511580](pic/image-20250804110511580.png)

![image-20250804110517010](pic/image-20250804110517010.png)

![image-20250804110524721](pic/image-20250804110524721.png)



~~~C++
class Solution {
public:
    // 基于快排的快速选择
    int quickSelect(vector<int>& nums, int k)
    {        
        // 随机选择基准数字
        int p = nums[rand() % nums.size()];

        // 将大于等于小于基准的元素，分别放入三个数组
        vector<int> big, equal, small;
        for (int a : nums)
        {
            if (a < p)      small.push_back(a);
            else if (a > p) big.push_back(a);
            else            equal.push_back(a);
        }

        // 第 k 大元素在big 中，按递归划分
        if (k <= big.size())    
        {
            return quickSelect(big, k);
        }

        // 第 k 大元素在 small 中，递归划分
        if (k > big.size() + equal.size())
        {
            return quickSelect(small, k - (big.size() + equal.size()));
            // 在small里面就是第 [k - (big.size() + equal.size())] 个大的元素
        }

        // 第 k 大元素在 equal 中，找到，返回p
        return p;
    }


    int findKthLargest(vector<int>& nums, int k) {

        return quickSelect(nums, k);        
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 215 数组中的第K个最大元素


// 基于快排的快速选择
int quickSelect(vector<int>& nums, int k)
{        
    // 随机选择基准数字
    int p = nums[rand() % nums.size()];

    // 将大于等于小于基准的元素，分别放入三个数组
    vector<int> big, equal, small;
    for (int a : nums)
    {
        if (a < p)      small.push_back(a);
        else if (a > p) big.push_back(a);
        else            equal.push_back(a);
    }

    // 第 k 大元素在big 中，按递归划分
    if (k <= big.size())    
    {
        return quickSelect(big, k);
    }
    // 第 k 大元素在 small 中，递归划分
    if (k > big.size() + equal.size())
    {
        return quickSelect(small, k - (big.size() + equal.size()));
        // 在small里面就是第 [k - (big.size() + equal.size())] 个大的元素
    }

    // 第 k 大元素在 equal 中，找到，返回p
    return p;
}


int main()
{
    vector<int> nums = {3,2,1,5,6,4};
    int k = 2;
    int ans = quickSelect(nums, k);
    cout << ans << endl;

    return 0;
}
~~~







## 347 [前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250803222511849](pic/image-20250803222511849.png)



### 小顶堆

![image-20250803225312630](pic/image-20250803225312630.png)

![image-20250803225319322](pic/image-20250803225319322.png)

~~~C++	
class Solution {
public:
    // 三块内容：
    // 1 统计元素出现的频率  - map
    // 2 对频率排序         - 优先级队列（小顶堆）
    // 3 找出前 k 个高频元素 

    
    // 小顶堆：仿函数改变 priority_queue 排序
    class mycomparison{
    public:
        bool operator() (const pair<int, int>& lhs, const pair<int, int>& rhs)
        {
            return lhs.second > rhs.second; // 次序，较小的在top
        }
    };


    vector<int> topKFrequent(vector<int>& nums, int k) {

        // 1 统计元素出现频率 <nums[i], 出现次数>
        unordered_map<int, int> cnt_map;
        for (int val : nums)
        {
            cnt_map[val]++;
        }

        // 2 对出现次数排序：小顶堆 大小为k
        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;

        for (unordered_map<int, int>::iterator it = cnt_map.begin(); it != cnt_map.end(); it++)
        {
            pri_que.push(*it);
            // 如果堆里的元素超过了k，弹出最小元素，始终保持堆里是前k个最大次数
            if (pri_que.size() > k) pri_que.pop(); 
        }

        // 3 找出前 k 个高频元素，就是留在pri_que中的k个
        vector<int> result(k);
        for (int i = k - 1; i >= 0; i--) // 小顶堆先弹出的是最小的，所以倒着放入result
        {
            result[i] = pri_que.top().first; // 取元素
            pri_que.pop();
        }


        return result;    
        
    }
};
~~~



### 桶排序

![image-20250803231056312](pic/image-20250803231056312.png)

![image-20250803233402555](pic/image-20250803233402555.png)

~~~C++	
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 1 统计每个元素的出现次数 map
        unordered_map<int, int> cnt;
        int max_cnt = 0;
        for (int x : nums)
        {
            cnt[x]++;
            max_cnt = max(max_cnt, cnt[x]); // 记录最大次数
        }
        
        // 2 把出现次数相同的元素，放进一个桶里
        vector<vector<int>> buckets(max_cnt + 1); 
        for (auto& [x, c] : cnt)
        {
            buckets[c].push_back(x); // 出现次数为 c 的元素集合

            // 这里用二维数组buckets 是为了比如：nums = [1,2] k = 2 这种
        }


        // 3 倒序遍历buckets，把出现次数前k的元素加入答案
        vector<int> ans;
        for (int i = max_cnt; i >= 0 && ans.size() < k; i--)
        {
            ans.insert(ans.end(), buckets[i].begin(), buckets[i].end());
        }

        return ans;
    }
};
~~~

![image-20250803233434960](pic/image-20250803233434960.png)

这里 `buckets` 需要用二维数组，收集**次数相同的元素集合**，比如 `nums = [1, 2]`  ，`k = 2` 这种情况：

![image-20250803234139410](pic/image-20250803234139410.png)





## 295 [数据流中的中位数](https://leetcode.cn/problems/find-median-from-data-stream/?envType=study-plan-v2&envId=top-100-liked)

@ 中位数 @ 小顶堆

删除操作可以看 480 滑动窗口中位数

![image-20250804144902822](pic/image-20250804144902822.png)

![image-20250804144853926](pic/image-20250804144853926.png)

![image-20250804145420002](pic/image-20250804145420002.png)

![image-20250804145425012](pic/image-20250804145425012.png)

![image-20250804145431394](pic/image-20250804145431394.png)

~~~C++
class MedianFinder {
    priority_queue<int> left; // 大顶堆（默认），存较小的一半
    priority_queue<int, vector<int>, greater<int>> right; // 小顶堆，存较大的一半
    
public:
    MedianFinder() {
        
    }
    
    void addNum(int num) {

        if (left.size() == right.size()) // 两边数量相等，直接加入右边
        {
            right.push(num);
            left.push(right.top()); // 右边弹出来最小的一个，加入left
            right.pop();
        }
        else // 左边数量多，直接加入左边，左边弹出来再给右边
        {
            left.push(num);
            right.push(left.top()); // 左边弹出来最大的一个，加入right
            left.pop();
        }        
    }
    
    double findMedian() {
        if (left.size() > right.size()) return left.top();
        else                            return (left.top() + right.top()) / 2.0;

    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
~~~



ACM

~~~C++
#include <vector>
#include <queue>
#include <iostream>
using namespace std;

// 295 数据流的中位数


class MedianFinder {
    priority_queue<int> left; // 大顶堆（默认），存较小的一半
    priority_queue<int, vector<int>, greater<int>> right; // 小顶堆，存较大的一半
    
public:
    MedianFinder() {}
    
    void addNum(int num) {

        if (left.size() == right.size()) // 两边数量相等，直接加入右边
        {
            right.push(num);
            left.push(right.top()); // 右边弹出来最小的一个，加入left
            right.pop();
        }
        else // 左边数量多，直接加入左边，左边弹出来再给右边
        {
            left.push(num);
            right.push(left.top()); // 左边弹出来最大的一个，加入right
            left.pop();
        }        
    }
    
    double findMedian() {
        if (left.size() > right.size()) return left.top();
        else                            return (left.top() + right.top()) / 2.0;

    }
};


int main()
{
    MedianFinder mymid;
    mymid.addNum(1);
    mymid.addNum(2);
    cout << mymid.findMedian() << endl;
    mymid.addNum(3);
    cout << mymid.findMedian() << endl;

    return 0;
}
~~~















# 贪心 ✅

## 121 [买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250724104534791](pic/image-20250724104534791.png)

### 贪心

![image-20250724105610766](pic/image-20250724105610766.png)

~~~C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {

        // prices[i] 股票第 i 天的价格
        int low = prices[0];
        int result = 0;
        for (int i = 0; i < prices.size(); i++)
        {
            low = min(low, prices[i]); // 取最左最小价格
            result = max(result, prices[i] - low); // 直接取最大差
        }

        return result;
    }
};
~~~



ACM 

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 121 买卖股票的最佳时机


int maxProfit(vector<int>& prices)  // prices[i] 股票第 i 天的价格
{ 
    int result = 0;
    int low = prices[0];
    
    for (int i = 0; i < prices.size(); i++)
    {
        low = min(low, prices[i]); // 取最左最小价格
        result = max(result, prices[i] - low); // 直接取最大差
    }
    return result;
    
}


int main()
{
    vector<int> prices = {7, 1, 5, 3, 6, 4};
    int result = maxProfit(prices);
    cout << result << endl;

    return 0;
}
~~~



### 动规

![image-20250821220151456](./pic/image-20250821220151456.png)

![image-20250821220158195](./pic/image-20250821220158195.png)

![image-20250821220210050](./pic/image-20250821220210050.png)

![image-20250821220221734](./pic/image-20250821220221734.png)

![image-20250821220226735](./pic/image-20250821220226735.png)

![image-20250821220237410](./pic/image-20250821220237410.png)

~~~C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {

        int len = prices.size();

        // dp[i][0] - 第i天持有股票所得最多现金   
        // dp[i][1] - 第i天不持有股票所得最多现金
        vector<vector<int>> dp(len, vector<int>(2, 0));

        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for (int i = 1; i < prices.size(); i++)
        {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }

        return dp[len - 1][1]; // 一定是最后不持有，钱多   
    }
};
~~~

时间复杂度：O(n)

空间复杂度：O(n)



**优化空间复杂度**

![image-20250821220409600](./pic/image-20250821220409600.png)









## [55 跳跃游戏](https://leetcode.cn/problems/jump-game/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250724143937308](pic/image-20250724143937308.png)

![image-20250724144024745](pic/image-20250724144024745.png)

![image-20250724144038419](pic/image-20250724144038419.png)

~~~C++
class Solution {
public:
    bool canJump(vector<int>& nums) {

        // 转换为跳跃范围能否覆盖到终点
        
        if (nums.size() == 1)   return true;

        int cover = 0; // 最右边界
        for (int i = 0; i <= cover; i++)  // 注意是在cover里往后取
        {
            cover = max(i + nums[i], cover); // 更新最大覆盖范围（最大右边界）
            if (cover >= nums.size() - 1) // 覆盖到终点了，返回true
            {
                return true; 
            }  
        }

        return false;       
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 55 跳跃游戏

bool canJump(vector<int>& nums)
{
    if (nums.size() == 1) return true;

    int cover = 0;
    for (int i = 0; i <= cover; i++)
    {
        cover = max(cover, i + nums[i]); // 更新最大覆盖范围
        if (cover >= nums.size() - 1)   return true;
    }

    return false;
}



int main()
{
    vector<int> nums = {2, 3, 1, 1, 4};
    bool ans = canJump(nums);
    cout << (ans ? "true" : "false") << endl;

    return 0;
}
~~~





## 45 跳跃游戏II

![image-20250724145332038](pic/image-20250724145332038.png)

在 55 的基础上求最小跳跃次数

题目保证可以跳到最后，也就是以最小的步数，增加覆盖范围，直到终点。

![image-20250724145732868](pic/image-20250724145732868.png)

<img src="pic/image-20250724145830910.png" alt="image-20250724145830910" style="zoom:33%;" />

覆盖范围已经能到终点了，最多两步肯定能跳到终点，**不用求具体怎么跳**。

移动下标达到了当前覆盖的最远距离下标时，**如果没覆盖终点，步数就要加一**，来增加覆盖距离，再走下一个的最大覆盖范围。

所以就是求**更新了几次覆盖范围**。

~~~C++
class Solution {
public:
    int jump(vector<int>& nums) {

        // 求更新几次覆盖范围

        if (nums.size() == 1)   return 0;

        int ans = 0; // 记录跳跃次数（更新几次覆盖范围）

        int curDistance = 0;  // 当前最远覆盖的下标
        int nextDistance = 0; // 下一步最远覆盖的下标

        for (int i = 0; i < nums.size(); i++)
        {
            nextDistance = max(nextDistance, i + nums[i]);

            // i 已经走到了当前能走的最远位置，必须要再走一步了
            if (i == curDistance) 
            {
                ans++; // 跳跃次数 + 1 (更新覆盖范围次数 + 1)
                curDistance = nextDistance; // 更新当前覆盖

                // 更新完cur已经能覆盖了，这次的步数也加上了，不用再跳下一次，直接结束
                if (curDistance >= nums.size() - 1) break; 
            }
        }

        return ans;        
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 45 跳跃游戏 II (最小跳跃次数)

int jumpCount(vector<int>& nums)
{
    if (nums.size() == 1)   return 0;

    int ans = 0;
    int curDistance = 0;
    int nextDistance = 0;

    for (int i = 0; i < nums.size(); i++)
    {
        nextDistance = max(nextDistance, i + nums[i]);

        if (i == curDistance)
        {
            ans++;
            curDistance = nextDistance;

            if (curDistance >= nums.size() - 1) break;
        }
    }

    return ans;
}



int main()
{
    vector<int> nums = {2, 3, 1, 1, 4};
    int ans = jumpCount(nums);
    cout << ans << endl;

    return 0;
}
~~~





## [763 划分字母区间](https://leetcode.cn/problems/partition-labels/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250724152147317](pic/image-20250724152147317.png)

**找每个字母的最远出现的下标，分割**

![image-20250724152234956](pic/image-20250724152234956.png)



![image-20250724154041841](pic/image-20250724154041841.png)

~~~C++
class Solution {
public:
    vector<int> partitionLabels(string s) {

        // 统计每个字母的下标

        // hash[i] - 每个字母最后出现的位置
        int hash[27] = {0};
        for (int i = 0; i < s.size(); i++) // 遍历s，i 是 s 中的下标
        {
            hash[s[i] - 'a'] = i; // 存的内容是 s 中的下标
        }

        //  直接用ASCII码, 
        //  hash[s[0] - 'a'] = hash['a' - 'a'] = hash[0] 最后更新为 8，即a最远下标是8 

        //  hash[0] = 8 --- a  
        //  hash[1] = 5 --- b
        //  hash[2] = 7 --- c
        //  hash[3] = 14 -- d
        //  ...
        
        //          a, b, c, d,  e,  f,  g,  h,  i,  j,  k,  l,  m, n, o, ...
        //  hash = {8, 5, 7, 14, 15, 11, 13, 19, 22, 23, 20, 21, 0, 0, 0, ...}

        vector<int> result;
        int left = 0;
        int right = 0;
        for (int i = 0; i < s.size(); i++) // 遍历的还是 s
        {
            right = max(right, hash[s[i] - 'a']); // 始终是i之前字母最远边界中的最大值

            if (i == right) // i 正好走到了 i 之前所有字母中的最远下标
            {
                result.push_back(right - left + 1); // 收集该距离
                left = i + 1; // 更新left，开始下一组
            }
        }

        return result;

    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
#include <string>
using namespace std;


vector<int> partitionLabels(string s) {
    // 统计每个字母的下标
    // hash[i] - 每个字母最后出现的位置
    int hash[27] = {0};
    for (int i = 0; i < s.size(); i++) // 遍历s，i 是 s 中的下标
    {
        hash[s[i] - 'a'] = i; // 存的内容是 s 中的下标
    }
    //  直接用ASCII码, 
    //  hash[s[0] - 'a'] = hash['a' - 'a'] = hash[0] 最后更新为 8，即a最远下标是8 
    //  hash[0] = 8 --- a  
    //  hash[1] = 5 --- b
    //  hash[2] = 7 --- c
    //  hash[3] = 14 -- d
    //  ...
    
    //          a, b, c, d,  e,  f,  g,  h,  i,  j,  k,  l,  m, n, o, ...
    //  hash = {8, 5, 7, 14, 15, 11, 13, 19, 22, 23, 20, 21, 0, 0, 0, ...}


    vector<int> result;

    int left = 0;
    int right = 0;
    for (int i = 0; i < s.size(); i++) // 遍历的还是 s
    {
        right = max(right, hash[s[i] - 'a']); // 始终是i之前字母最远边界中的最大值

        if (i == right) // i 正好走到了 i 之前所有字母中的最远下标
        {
            result.push_back(right - left + 1); // 收集该距离
            left = i + 1; // 更新left，开始下一组
        }
    }
 

    return result;
}


int main()
{
    string s = "ababcbacadefegdehijhklij";
    vector<int> result = partitionLabels(s);

    for (int val : result)
    {
        cout << val << " "; // 9 7 8
    }
    cout << endl;

    return 0;
}
~~~









# 动态规划 ✅

@ 背包   @ 打家劫舍   @ 股票  @ 子序列子数组 

## 70 [爬楼梯](https://leetcode.cn/problems/climbing-stairs/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250805105907383](pic/image-20250805105907383.png)



![image-20250805112253766](pic/image-20250805112253766.png)

<img src="pic/image-20250805105956681.png" alt="image-20250805105956681" style="zoom:50%;" />



![image-20250805112405157](pic/image-20250805112405157.png)

~~~C++
class Solution {
public:
    int climbStairs(int n) {
        
        if (n <= 1) return n;
        
        vector<int> dp(n + 1); // dp[i] 爬到第i个台阶，有多少种方法

        dp[1] = 1;
        dp[2] = 2;

        for (int i = 3; i <= n; i++)
        {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
        
    }
};
~~~

时间复杂度 O(n)



优化：dp[3]

~~~C++
class Solution {
public:
    int climbStairs(int n) {
        
        if (n <= 1) return n;
        
        int dp[3]; // 只维护3个

        dp[1] = 1;
        dp[2] = 2;

        for (int i = 3; i <= n; i++)
        {
            int sum = dp[1] + dp[2];
            dp[1] = dp[2];
            dp[2] = sum;
        }

        return dp[2];
        
    }
};
~~~

时间复杂度 O(n) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。
空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。



ACM

~~~C++
#include <iostream>
#include <vector>
using namespace std;


// 70 爬楼梯

int climbStairs(int n) {
    
    if (n <= 1) return n;
    
    vector<int> dp(n + 1); // dp[i] 爬到第i个台阶，有多少种方法

    dp[1] = 1;
    dp[2] = 2;

    for (int i = 3; i <= n; i++)
    {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
    
}

int main()
{
    int n = 3;
    int ans = climbStairs(n);
    cout << ans << endl;

    return 0;
}
~~~



## 118 [杨辉三角](https://leetcode.cn/problems/pascals-triangle/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250805171443075](pic/image-20250805171443075.png)

![image-20250805171551496](pic/image-20250805171551496.png)

![image-20250805171710790](pic/image-20250805171710790.png)

~~~C++
class Solution {
public:
    vector<vector<int>> generate(int numRows) {    
        // [1]
        // [1, 1]
        // [1, 2, 1]
        // [1, 3, 3, 1]
        // [1, 4, 6, 4, 1]

        vector<vector<int>> c(numRows);
        for (int i = 0; i < numRows; i++)
        {
            c[i].resize(i + 1, 1); // 第i行有i+1个数，每一行起始都是1
            for (int j = 1; j < i; j++) 
            {
                // 左上方的数 + 右上方的数
                c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
            }
        }

        return c;        
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 118 杨辉三角

// [1]
// [1, 1]
// [1, 2, 1]
// [1, 3, 3, 1]
// [1, 4, 6, 4, 1]

vector<vector<int>> generate(int numRows)
{
    vector<vector<int>> c(numRows);
    
    for (int i = 0; i < numRows; i++)
    {
        c[i].resize(i + 1, 1);

        for (int j = 1; j < i; j++)
        {
            c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
        }
    }

    return c;
}


int main()
{
    int numRows = 5;
    vector<vector<int>> ans = generate(numRows);
    for (int i = 0; i < ans.size(); i++)
    {
        for (int val : ans[i])  cout << val << " ";
        cout << endl;
    }
    
    return 0;
}
~~~





## 198 [打家劫舍](https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250805173413637](pic/image-20250805173413637.png)

![image-20250805174048718](pic/image-20250805174048718.png)

<img src="pic/image-20250805174206969.png" alt="image-20250805174206969" style="zoom: 33%;" />

~~~C++
class Solution {
public:
    int rob(vector<int>& nums) {

        if (nums.size() == 0)   return 0;
        if (nums.size() == 1)   return nums[0];

        // dp[i]: 考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]
        vector<int> dp(nums.size());

        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);

        for (int i = 2; i < nums.size(); i++)
        {
            // 决定dp[i]的因素 -- 第i间偷还是不偷
            dp[i] = max(dp[i - 2] + nums[i], // 偷第i间
                        dp[i - 1]); // 不偷第i间
        }

        return dp[nums.size() - 1];        
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 198 打家劫舍

int rob(vector<int>& nums)
{
    if (nums.size() == 0)   return 0;
    if (nums.size() == 1)   return nums[0];

    // dp[i]: 考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]
    vector<int> dp(nums.size());

    dp[0] = nums[0];
    dp[1] = max(nums[0], nums[1]);

    for (int i = 2; i < nums.size(); i++)
    {
        // 决定dp[i]的因素 -- 第i间偷还是不偷
        dp[i] = max(dp[i - 2] + nums[i], // 偷第i间
                    dp[i - 1]); // 不偷第i间
    }

    return dp[nums.size() - 1];        
}


int main()
{
    vector<int> nums = {1, 2, 3, 1};
    int ans = rob(nums);
    cout << ans << endl;

    return 0;
}
~~~







## 279 [完全平方数](https://leetcode.cn/problems/perfect-squares/description/?envType=study-plan-v2&envId=top-100-liked)

@完全背包

![image-20250807104244859](pic/image-20250807104244859.png)

![image-20250807104702282](pic/image-20250807104702282.png)

![image-20250807104710144](pic/image-20250807104710144.png)

![image-20250807111337944](pic/image-20250807111337944.png)

~~~C++
class Solution {
public:
    int numSquares(int n) {

        // dp[j] 和为j的完全平方数的最少数量为dp[j]
        vector<uint64_t>  dp(n + 1, INT_MAX);

        dp[0] = 0;

        for (int i = 0; i * i <= n; i++) // 先物品（完全平方数 1,4,9,...）
        {
            for (int j = i * i; j <= n; j++) // 后背包
            {
                dp[j] = min(dp[j], dp[j - i * i] + 1); 
            }
        }

        return dp[n];        
    }
};
~~~



`uint64_t` 是 C++ 标准库中定义的 **无符号 64 位整数类型**，定义在头文件 `<cstdint>` 或 `<stdint.h>` 中。其取值范围为：

~~~C++
0 ~ 2^64 - 1 （即 0 ~ 18,446,744,073,709,551,615）
~~~

为什么 `dp` 要使用 `uint64_t`？**防止整型溢出**。

~~~C++
vector<uint64_t>  dp(n + 1, INT_MAX);
~~~

 `dp` 数组初始化时，每个元素都被设为 `INT_MAX`，而 `INT_MAX` 是一个 `int` 类型的最大值，即：

~~~C++
INT_MAX = 2,147,483,647
~~~

后续这行代码可能导致溢出:

~~~C++
dp[j] = min(dp[j], dp[j - i * i] + 1);
~~~

这里 `dp[j - i * i]` 的初始值可能是 `INT_MAX`，如果你再加上 `1`，就可能发生溢出：

~~~C++
INT_MAX + 1 ==> 溢出为负数（int 类型）
~~~

如果 `dp` 数组是 `int` 类型，`dp[j - i*i] + 1` 这一步可能变成负值，从而使 `dp[j]` 得到错误的最小值（变成负数的结果参与 `min()` 比较），导致最终答案错误。

而使用 `uint64_t`（更大范围的无符号整型）能有效避免这个溢出问题。



如果直接用`int`类型，需要加判断：

~~~C++
vector<int> dp(n + 1, INT_MAX);
// .......
if (dp[j - i * i] != INT_MAX)
    dp[j] = min(dp[j], dp[j - i * i] + 1);
~~~

使用 `uint64_t` 就相当于规避了这个判断逻辑，程序更简洁，**以空间换时间/逻辑复杂度**。



ACM 

~~~C++
#include <iostream>
#include <vector>
using namespace std;

// 279 完全平方数


int numSquares(int n) {
    // dp[j] 和为j的完全平方数的最少数量为dp[j]
    vector<uint64_t>  dp(n + 1, INT_MAX);
    dp[0] = 0;

    for (int i = 0; i * i <= n; i++) // 先物品（完全平方数 1,4,9,...）
    {
        for (int j = i * i; j <= n; j++) // 后背包
        {
            dp[j] = min(dp[j], dp[j - i * i] + 1); 
        }
    }

    return dp[n];        
}

int main()
{
    int n = 13;
    int ans = numSquares(n);
    cout << ans << endl;

}
~~~





## 322 零钱兑换 

@ 完全背包

![image-20250807165942305](pic/image-20250807165942305.png)

**物品——硬币；背包重量——总金额；完全背包——硬币无限**

![image-20250807170201412](pic/image-20250807170201412.png)

![image-20250807170450636](pic/image-20250807170450636.png)

![image-20250818183330608](./pic/image-20250818183330608.png)



~~~C++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {

        // dp[j] 凑足总额为 j，所需最少硬币个数为 dp[j]
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;

        // 先物品，后背包（可调换）
        for (int i = 0; i < coins.size(); i++)
        {
            for (int j = coins[i]; j <= amount; j++) // 完全背包，正序
            {
                if (dp[j - coins[i]] != INT_MAX)// 如果dp[j - coins[i]是初始值，跳过
                {
                    dp[j] = min(dp[j], dp[j - coins[i]] + 1);
                }
            }
        }

        if (dp[amount] == INT_MAX)  return -1; // 没有组合

        return dp[amount];
        
    }
};
~~~



## 139 单词拆分

@完全背包

![image-20250819201626880](./pic/image-20250819201626880.png)

![image-20250819204556082](./pic/image-20250819204556082.png)

![image-20250819204607334](./pic/image-20250819204607334.png)

![image-20250819204618384](./pic/image-20250819204618384.png)


~~~C++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {

        // 字典wordDict 转为set
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());

        // dp[j] - 字符串长度为j ( s的[0, j-1]部分 )，dp[j]为true
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true; // 无意义，纯为了递推


        // 排列(组成s的字符串是有顺序的) - 先背包，后物品
        for (int j = 1; j <= s.size(); j++)
        {
            for (int i = 0; i < j; i++)
            {
                string word = s.substr(i, j - i); // 截取s[i, j-1] 

                // [i, j-1]在字典里，且dp[i]，也就是[0, i-1]部分是true => [0, j-1] true
                if (wordSet.find(word) != wordSet.end() && dp[i])   dp[j] = true;
            }
        }

        return dp[s.size()];      
    }
};
~~~





## 300 [最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

@ 子序列 dp

![image-20250824204332038](./pic/image-20250824204332038.png)

![](./pic/image-20250824211810584.png)

![image-20250824211912319](./pic/image-20250824211912319.png)



~~~C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {

        if (nums.size() <= 1)   return nums.size();

        // dp[i] - 以nums[i]结尾的最长递增子序列的长度
        vector<int> dp(nums.size(), 1);

        int result = 0;
        for (int i = 1; i < nums.size(); i++) // 以nums[i]结尾
        {
            for (int j = 0; j < i; j++) // j 从 0 到 i-1
            {
                if(nums[i] > nums[j])   dp[i] = max(dp[i], dp[j] + 1);
            }

            if (dp[i] > result) result = dp[i]; // 取dp最大值
                                                // 注意最大值不一定是dp[最后一个]
        }

        return result;
    }
};
~~~





## 152 [乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250827001334450](./pic/image-20250827001334450.png)

依旧是灵神

![image-20250827001327763](./pic/image-20250827001327763.png)

~~~C++
class Solution {
public:
    int maxProduct(vector<int>& nums) {

        int n = nums.size();

        // 以nums[i]结尾的子数组的最大乘积，最小乘积
        vector<int> f_max(n), f_min(n);

        f_max[0] = nums[0];
        f_min[0] = nums[0];

        for (int i = 1; i < n; i++)
        {
            int x = nums[i];
            // 【x单独】  【以nums[i-1]结尾的最大乘积 * x】  【最小乘积 * x】
            f_max[i] = max({x, f_max[i - 1] * x, f_min[i - 1] * x});
            f_min[i] = min({x, f_max[i - 1] * x, f_min[i - 1] * x});
        }

        return ranges::max(f_max); // ranges 里的max函数，直接取容器最大值
        
    }
};
~~~

- 时间复杂度：O(n)，其中 n 是 nums 的长度。
- 空间复杂度：O(n)。



**空间优化（看看）**

![image-20250827001616821](./pic/image-20250827001616821.png)

~~~C++
class Solution {
public:
    int maxProduct(vector<int>& nums) {

        int ans = INT_MIN; // 注意可能有负数

        int f_max = 1, f_min = 1; // 只用两个变量，滚动计算
        for (int x : nums)
        {
            int mx = f_max; // 记一下原来的f_max，要不然下一步就被赋值新的数了
            f_max = max({f_max * x, f_min * x, x});
            f_min = min({mx * x, f_min * x, x});
            
            ans = max(ans, f_max); // 更新最大乘积
        }

        return ans;
    }
};
~~~

- 时间复杂度：O(*n*)，其中 *n* 是 *nums* 的长度。
- 空间复杂度：O(1)。



## 416 [分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/?envType=study-plan-v2&envId=top-100-liked)

@ 01背包

![image-20250806104850992](pic/image-20250806104850992.png)

![image-20250806105231010](pic/image-20250806105231010.png)

![image-20250806105443328](pic/image-20250806105443328.png)

![image-20250806105512513](pic/image-20250806105512513.png)

![image-20250806105515615](pic/image-20250806105515615.png)

![image-20250806105541083](pic/image-20250806105541083.png)

![image-20250806105550288](pic/image-20250806105550288.png)

![image-20250806105616587](pic/image-20250806105616587.png)



**注意：物品的重量和价值都是【元素数值】**

![image-20250806110918772](pic/image-20250806110918772.png)

~~~C++
class Solution {
public:
    bool canPartition(vector<int>& nums) {

        int sum = 0;

        // 注意：物品的重量和价值都是【元素数值】

        // 背包的体积为 sum/2  -- 对应物品的重量是 元素数值
        // 物品的价值也是 元素数值

        // dp[j] 背包容量(能装的总重量)是j，放进物品后背包的最大重量为dp[j]
        vector<int> dp(10001, 0);

        for (int i = 0; i < nums.size(); i++)
        {
            sum += nums[i];
        }
        if (sum % 2 == 1)   return false;
        int target = sum / 2; // 找dp[target] == target

        // 递推填补dp
        for (int i = 0; i < nums.size(); i++) // 先物品
        {
            for (int j = target; j >= nums[i]; j--) // 后背包，从大到小
            {
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }

        // sum/2体积的背包，正好装了sum/2重量
        if (dp[target] == target)   return true; 
        
        return false;
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 416 分割等和子集（01背包）


bool canPartition(vector<int>& nums) {
    int sum = 0;
    // 注意：物品的重量和价值都是【元素数值】

    // 背包的体积为 sum/2  -- 对应物品的重量是 元素数值
    // 物品的价值也是 元素数值

    // dp[j] 背包容量(能装的总重量)是j，放进物品后背包的最大重量为dp[j]
    vector<int> dp(10001, 0);

    for (int i = 0; i < nums.size(); i++)
    {
        sum += nums[i];
    }
    if (sum % 2 == 1)   return false;
    int target = sum / 2; // 找dp[target] == target


    // 递推填补dp
    for (int i = 0; i < nums.size(); i++) // 先物品
    {
        for (int j = target; j >= nums[i]; j--) // 后背包，从大到小
        {
            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
        }
    }

    // sum/2体积的背包，正好装了sum/2重量
    if (dp[target] == target)   return true; 
    
    return false;
}

int main()
{
    vector<int> nums = {1, 5, 11, 5};
    bool ans = canPartition(nums);
    cout << (ans ? "true" : "false") << endl;

    return 0;
}
~~~





## 32 [最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250827102722400](./pic/image-20250827102722400.png)

### 动规

[原题解](https://leetcode.cn/problems/longest-valid-parentheses/solutions/206995/dong-tai-gui-hua-si-lu-xiang-jie-c-by-zhanganan042)  大神 。。。

![image-20250827110131685](./pic/image-20250827110131685.png)

![image-20250827113230386](./pic/image-20250827113230386.png)

![image-20250827113048629](./pic/image-20250827113048629.png)

![image-20250827113305760](./pic/image-20250827113305760.png)

![image-20250827113314497](./pic/image-20250827113314497.png)



~~~C++
class Solution {
public:
    int longestValidParentheses(string s) {

        // dp[i] - 以s[i]结尾的最长有效括号的长度
        vector<int> dp(s.size(), 0);

        int maxLength = 0;
        for (int i = 1; i < s.size(); i++)
        {
            // 以'('结尾，组不成有效括号 (可以不特意写出来)
            if (s[i] == '(')  dp[i] = 0; 

            // 以')'结尾，考虑前一个括号 s[i-1]
            else if (s[i] == ')') 
            {
                if (s[i - 1] == '(') // 最后两个就能组成一对括号 ____ ()
                {
                    if (i - 2 >= 0) dp[i] = dp[i - 2] + 2; // _____ ()
                    else            dp[i] = 2;             // ()
                }
                else // s[i - 1】 == ')'   ____ )) 往前找和i位置的')'对应的
                {
                    // 以s[i-1]结尾的必须是有效括号对，___(__))  才能再往前找和i对应的
                    if (dp[i - 1] > 0)   
                    {
                        // 和 i 的')'对应的位置s[i - dp[i-1] - 1] 必须是'('   ___((_))
                        if ((i - dp[i-1]-1) >= 0 && s[i - dp[i-1] - 1] == '(')
                        {
                            if (i - dp[i - 1] - 2 >= 0) // 新片段前面还有(______)((_))
                            {
                                dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2];
                            }
                            else // 新片段前面没有了 ((_))
                            {
                                dp[i] = dp[i - 1] + 2;
                            } 
                        }
                    }
                }
            }

            maxLength = max(maxLength, dp[i]); // 取最大长度
        }

        return maxLength;  
    }
};
~~~



### 栈

> 参考 ： [林小鹿](https://leetcode.cn/u/lin-shen-shi-jian-lu-k/)     [我要出去乱说](https://leetcode.cn/u/wo-yao-chu-qu-luan-shuo/)

可以举例子看一下

![image-20250827162537472](./pic/image-20250827162537472.png)

![image-20250827161019054](./pic/image-20250827161019054.png)

![image-20250827162355548](./pic/image-20250827162355548.png)







# 多维动态规划 ✅

## 62 [不同路径](https://leetcode.cn/problems/unique-paths/description/)

![image-20250808105457283](pic/image-20250808105457283.png)

![image-20250808105641427](pic/image-20250808105641427.png)

![image-20250808105658157](pic/image-20250808105658157.png)

~~~C++
class Solution {
public:
    int uniquePaths(int m, int n) {

        // dp[i][j]: 从(0,0)到(i,j)一共有dp[i][j]条路径
        vector<vector<int>> dp(m, vector<int>(n, 0));

        // 初始化  第一行和第一列需要初始化，都只有一条路径
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
        
        // 递推
        for (int i = 1; i < m; i++)
        {
            for (int j = 1; j < n; j++)
            {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; // 两个方向的路径数相加
            }
        }

        return dp[m - 1][n - 1];
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <vector>
using namespace std;


int uniquePaths(int m, int n) 
{
    // dp[i][j]: 从(0,0)到(i,j)一共有dp[i][j]条路径
    vector<vector<int>> dp(m, vector<int>(n, 0));

    // 初始化  第一行和第一列需要初始化，都只有一条路径
    for (int i = 0; i < m; i++) dp[i][0] = 1;
    for (int j = 0; j < n; j++) dp[0][j] = 1;
    
    // 递推
    for (int i = 1; i < m; i++)
    {
        for (int j = 1; j < n; j++)
        {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; // 两个方向的路径数相加
        }
    }

    return dp[m - 1][n - 1];
}


int main()
{
    int m = 3, n = 7;
    int ans = uniquePaths(m, n);
    cout << ans << endl;
    
    return 0;
}
~~~





## 64 [最小路径和](https://leetcode.cn/problems/minimum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked)

@递归  @ 动规

![image-20250827175235751](./pic/image-20250827175235751.png)

![image-20250827175006970](./pic/image-20250827175006970.png)

![image-20250827175017970](./pic/image-20250827175017970.png)

![image-20250827175025965](./pic/image-20250827175025965.png)

![image-20250827175032010](./pic/image-20250827175032010.png)

![image-20250827175105067](./pic/image-20250827175105067.png)



### 递归（推荐）

![image-20250827175119100](./pic/image-20250827175119100.png)

![image-20250827175124359](./pic/image-20250827175124359.png)

~~~C++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {

        int m = grid.size();
        int n = grid[0].size();

        // 记录当前dfs是不是调用过，初始 -1 表示未调用
        vector<vector<int>> memo(m, vector<int>(n, -1)); 

        // dfs(i, j) 左上角(0,0) ——> 当前点(i,j)的最小价值
        auto dfs = [&](this auto&& dfs, int i, int j) -> int {
            if (i < 0 || j < 0)     return INT_MAX;   
            if (i == 0 && j == 0)   return grid[i][j];  

            // int& res = memo[i][j];
            if (memo[i][j] != -1)  return memo[i][j]; // 之前计算过，直接返回结果

            return memo[i][j] = min(dfs(i, j - 1), dfs(i - 1, j)) + grid[i][j]; // 未计算过
        };

        return dfs(grid.size() - 1, grid[0].size() - 1);  
    }
};
~~~



### 动规

![image-20250827175404374](./pic/image-20250827175404374.png)

![image-20250827175409508](./pic/image-20250827175409508.png)



~~~C++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {

        int m = grid.size();
        int n = grid[0].size();

        // dp[i+1][j+1] - 从左上角到(i,j)的最小和
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX));

        // +1 相当于 dp 在原grid范围上最左和最上加了一层，把越界的无穷情况直接加进来了
        // 但是 +1，只是在dp上加的，不影响原grid，加的还是遍历到的原(i,j)位置的值

        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (i == 0 && j == 0)   dp[1][1] = grid[i][j];
                else 
                {
                    dp[i + 1][j + 1] = min(dp[i+1][j], dp[i][j+1]) + grid[i][j];
                }
            }
        }

        return dp[m][n];
    }
};
~~~



把 `dp[0][1]`或者  `dp[1][0]` 初始化成0，这样 `dp[1][1]` 可以用递推式计算了，无需特判。

只能初始化一个，因为要取 min，取`0 + grid[0][0] = dp[1][1]`

**最终版**

~~~C++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {

        int m = grid.size();
        int n = grid[0].size();

        // dp[i+1][j+1] - 从左上角到(i,j)的最小和
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX));
        dp[0][1] = 0;

        // +1 相当于 dp 在原grid范围上最左和最上加了一层，把越界的无穷情况直接加进来了
        // 但是 +1，只是在dp上加的，不影响原grid，加的还是遍历到的原(i,j)位置的值

        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                dp[i + 1][j + 1] = min(dp[i+1][j], dp[i][j+1]) + grid[i][j];
            }
        }

        return dp[m][n];
    }
};
~~~





## 5 [最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250829113653761](./pic/image-20250829113653761.png)

### 动态规划

> 647 回文子串是求个数，5 是求最长长度

`dp[i][j]` —【i, j】范围的s是否为回文子串 +  记录最长回文子串范围 

~~~C++
class Solution {
public:
    string longestPalindrome(string s) {

        // dp[i][j] - 范围[i, j]的s子串是否是回文子串
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));

        int maxLength = 0; // 记录最长回文子串长度
        int left = 0;
        int right = 0;

        for (int i = s.size(); i >= 0; i--)
        {
            for (int j = i; j < s.size(); j++)
            {
                if (s[i] == s[j])
                {
                    if (j - i <= 1)             dp[i][j] = true; // 'a' 或 'aa'
                    else if (dp[i + 1][j - 1])  dp[i][j] = true; // 'a _ _ _ a'
                }


                if (dp[i][j] && j - i + 1 > maxLength) // 更新最长长度
                {
                    maxLength = j - i + 1;
                    left = i;
                    right = j;
                }
            }
        }

        return s.substr(left, maxLength); // 截取子串        
    }
};
~~~

时间复杂度：$O(N^2)$ 

空间复杂度：$O(N^2)$ 



### 双指针

以 s 的每个字符为中心，向两边进行扩展 extend()，得到最长回文范围

但是要注意在遍历中心点的两种情况：一个元素可以作为中心点，两个元素也可以作为中心点。

比如 ：`___b a b___`  `___b a a b___`

~~~C++
class Solution {
public:

    int left = 0;
    int right = 0;
    int maxLength = 0;

    // 回文扩展：从给定的中心 [i, j] 向两边扩展，直到遇到不同的字符为止，记录最长扩展长度
    void extend(const string& s, int i, int j, int n)
    {
        while (i >= 0 && j < n && s[i] == s[j])
        {
            if (j - i + 1 > maxLength)
            {
                left = i;
                right = j;
                maxLength = j - i + 1;
            }

            i--;
            j++; // 向两边扩展
        }
    }


    string longestPalindrome(string s) {
        
        int result = 0;

        // 将s的每个字符，作为回文中心，向两边扩展，记录每个s[i]能扩展的长度
        for (int i = 0; i < s.size(); i++)
        {
            // 注意中心点的两种情况
            extend(s, i, i, s.size());     // 以 i 为中心          '__ b a b __'
            extend(s, i, i + 1, s.size()); // 以 i 和 i + 1 为中心 '__ b a a b __'
        }

        return s.substr(left, maxLength);        
    }
};
~~~

时间复杂度：$O(N^2)$ 

空间复杂度：O(1)





## 1143 [最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/description/?envType=study-plan-v2&envId=top-100-liked)

@ dp 最左最上扩充

![image-20250829180433869](./pic/image-20250829180433869.png)

**dp 最左和最上扩充，避免单独处理首行首列，和 718 类似**

![image-20250829205843184](./pic/image-20250829205843184.png)

![image-20250829205849035](./pic/image-20250829205849035.png)

![image-20250829205855349](./pic/image-20250829205855349.png)

![image-20250829205900609](./pic/image-20250829205900609.png)

![image-20250829205907143](./pic/image-20250829205907143.png)

~~~C++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {

        // dp[i][j] - text1的[0, i-1]范围 和 text2的[0, j-1]范围 的最长公共子序列
        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));

        for (int i = 1; i <= text1.size(); i++)
        {
            for (int j = 1; j <= text2.size(); j++)
            {
                if (text1[i - 1] == text2[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else // text1[i] != text2[j]
                {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[text1.size()][text2.size()];
    }
};
~~~



如果定义dp数组：

`dp[i][j] ` 表示 **text1[0, i] 和 text2[0, j]** 范围的最长公共子序列，**dp大小为（text1.size(), test2.size()）**

**如果不初始化，需要单独处理首行首列**

![image-20250829180255751](./pic/image-20250829180255751.png)

**对第一行第一列初始化**

![image-20250829180344020](./pic/image-20250829180344020.png)

![image-20250829180357791](./pic/image-20250829180357791.png)





## 72 [编辑距离](https://leetcode.cn/problems/edit-distance/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250830195946489](./pic/image-20250830195946489.png)

![image-20250830203024915](./pic/image-20250830203024915.png)

![image-20250830202916922](./pic/image-20250830202916922.png)

![image-20250830203112530](./pic/image-20250830203112530.png)



~~~C++
class Solution {
public:
    int minDistance(string word1, string word2) {

        // word1 = "horse", word2 = "ros"

        // dp[i][j] - 以word1[i-1]结尾，和以word2[j-1]结尾的部分，最近编辑距离为dp[i][j]
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));

        // 初始化
        for (int i = 0; i <= word1.size(); i++)  dp[i][0] = i; // word1 和 空word2
        for (int j = 0; j <= word2.size(); j++)  dp[0][j] = j; // 空word1 和 word1


        for (int i = 1; i <= word1.size(); i++)
        {
            for (int j = 1; j <= word2.size(); j++)
            {
                // 相同，不需要操作，延续上一个结果 
                if (word1[i - 1] == word2[j - 1])  
                {
                    dp[i][j] = dp[i - 1][j - 1]; 
                }
                else // word1[i - 1] != word2[j - 1]  固定对 word1 增 删 改
                {
                    dp[i][j] = min({dp[i - 1][j] + 1,  // word1删一个
                                    dp[i][j - 1] + 1,  // word2删一个 <==> word1增加
                                    dp[i - 1][j - 1] + 1}); // 替换word1[i-1]
                }
            }
        }

        return dp[word1.size()][word2.size()];
    }
};
~~~

















# 图论 ✅

## 200 [岛屿数量](https://leetcode.cn/problems/number-of-islands/description/)

![image-20250825232030133](./pic/image-20250825232030133.png)

<img src="./pic/image-20250825233129525.png" alt="image-20250825233129525" style="zoom:50%;" />

本题思路：**遇到一个没有遍历过的陆地，计数器就加一**，然后把**该节点陆地所能遍历到的陆地都标记**上。

在遇到标记过的陆地节点和海洋节点的时候直接跳过。 这样**计数器就是最终岛屿的数量**。



### 深搜dfs

**`result` 作为岛屿计数器。遍历`grid`每个节点：每个未标记新陆地都是新岛屿起点**

- 遇到新的未标记陆地，先标记`visited`，然后计数`result + 1`，表示遇到了新岛屿的起始点

- dfs 主要用来标记这块新岛屿能连接上的所有陆地 `visited[][]`，走完这一层dfs，也就标记完了这块岛屿

- 这样在下一轮，再遇到新的未标记陆地，又可以作为新岛屿的起始，`result + 1`

~~~C++
class Solution {
public:
    int dir[4][2] = {0,1, 1,0, -1,0, 0,-1}; // 四个方向

    void dfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y)
    {
        // {x, y} 当前节点的坐标，第x行，第y列
        
        // 遍历当前节点{x, y}的四个方向
        for (int i = 0; i < 4; i++)
        {
            int nextx = x + dir[i][0];
            int nexty = y + dir[i][1];

            if (nextx < 0 || nextx >= grid.size() ||
                nexty < 0 || nexty >= grid[0].size())
            {
                continue; // 超出界限，直接跳过
            }

            // 是陆地且没被访问过
            if (!visited[nextx][nexty] && grid[nextx][nexty] == '1') 
            {
                visited[nextx][nexty] = true;
                dfs(grid, visited, nextx, nexty); // 递归
            }

        }
    }

    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size();   // n行
        int m = grid[0].size();// m列

        vector<vector<bool>> visited(n, vector<bool>(m, false)); // 标记是否访问过

        int result = 0;
        // result记录遇到的符合的新岛屿的个数，dfs用来标记这块岛屿能连接上的所有陆地
        
        // 遍历grid每个节点，每个未标记陆地都是新岛屿起始点
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (!visited[i][j] && grid[i][j] == '1')
                {
                    visited[i][j] = true;
                    result++; // 遇到新岛屿起始点[i, j]，岛屿数量+1

                    dfs(grid, visited, i, j); // 将与 [i, j] 连接上的陆地都标记上
                }
            }
        }

        return result;
    }
    
};
~~~

上面的终止条件就写在了 调用dfs的地方，如果遇到不合法的方向，直接不会去调用dfs。

也可以明确在dfs开头写上终止条件

~~~C++
void dfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y)
{
    // 终止：节点访问过，或者是海水
    if (visited[x][y] || grid[x][y] == '0') return; 

    visited[x][y] = true; // 标记     

    for (int i = 0; i < 4; i++)
    {
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];

        if (nextx < 0 || nextx >= grid.size() ||
            nexty < 0 || nexty >= grid[0].size())
        {
            continue; 
        }

        dfs(grid, visited, nextx, nexty); // 判断条件放到前面去了，这里直接递归
    }
}
~~~

版本一中 调用dfs 的条件，放在了 版本二 的 终止条件位置上。

版本一的写法是 ：下一个节点是否能合法已经判断完了，只要调用dfs就是可以合法的节点。

版本二的写法是：不管节点是否合法，上来就dfs，然后在终止条件的地方进行判断，不合法再return。

理论上来讲，版本一的效率更高一些，因为避免了 没有意义的递归调用，在调用dfs之前，就做合法性判断。 但从写法来说，可能版本二 更利于理解一些。（不过其实都差不太多）







**ACM（kama 99）**

![image-20250825233041504](./pic/image-20250825233041504.png)

~~~C++
#include <iostream>
#include <vector>
using namespace std;

int dir[4][2] = {0, 1, 0, -1, 1, 0, -1, 0};
void dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y)
{
    for (int i = 0; i < 4; i++)
    {
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        if (nextx < 0 || nextx >= grid.size() ||
            nexty < 0 || nexty >= grid[0].size())
        {
            continue;
        }

        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1)
        {
            visited[nextx][nexty] = true;
            dfs(grid, visited, nextx, nexty);
        }
    }
}




int main()
{
    int n = 0, m = 0; // n行  m列
    cin >> n >> m;

    vector<vector<int>> grid(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin >> grid[i][j];
        }
    }

    vector<vector<bool>> visited(n, vector<bool>(m, false));
    int result = 0;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if (!visited[i][j] && grid[i][j] == 1)
            {
                visited[i][j] = true;
                result++;
                dfs(grid, visited, i, j);
            }
        }
    }

    cout << result << endl;


    return 0;
}
~~~





### 广搜bfs

**dfs 换成 bfs，queue存放走过的节点坐标**

- 遇到新的未标记陆地，就是新的岛屿，直接计数`result + 1`

- 进入 bfs 标记这块新岛屿能连接上的所有陆地 `visited[][]`
  - 取出que中节点，标记4个方向，符合的陆地节点**加入队列，代表走过，需要标记**（而不是从队列拿出来的时候再去标记走过），循环这个过程，直到que中没有节点（当前这块岛屿标记完成）
- 再遍历遇到新的未标记陆地，再 `result + 1`，再bfs标记这块新岛屿



~~~C++
class Solution {
public:
    int dir[4][2] = {0,1, 1,0, -1,0, 0,-1}; // 四个方向

    void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y)
    {
        queue<pair<int, int>> que; // 存放已经走过的坐标 {x, y}
        que.push({x, y});

        visited[x][y] = true; // 只要加入队列，就标记

        while (!que.empty())
        {
            pair<int, int> cur = que.front();
            que.pop();

            int curx = cur.first;
            int cury = cur.second;

            // 处理cur的4个方向
            for (int i = 0; i < 4; i++)
            {
                int nextx = curx + dir[i][0];
                int nexty = cury + dir[i][1];
                if (nextx < 0 || nextx >= grid.size() ||
                    nexty < 0 || nexty >= grid[0].size())
                {
                    continue;
                }

                if (!visited[nextx][nexty] && grid[nextx][nexty] == '1')
                {
                    que.push({nextx, nexty});     // 加入队列
                    visited[nextx][nexty] = true; // 标记
                }
            }
        }
    }

    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size();   // n行
        int m = grid[0].size();// m列

        vector<vector<bool>> visited(n, vector<bool>(m, false)); // 标记是否访问过

        int result = 0; // result记录遇到的符合的新岛屿的个数
        
        // 换成 bfs 来标记这块岛屿能连接上的所有陆地
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (!visited[i][j] && grid[i][j] == '1')
                {
                    result++; // 遇到新岛屿起始点[i, j]，岛屿数量+1
                    bfs(grid, visited, i, j); // 将与 [i, j] 连接上的陆地都标记上
                }
            }
        }

        return result;       
    }
};
~~~



**注意：标记的时机**

如果从队列拿出节点，再去标记这个节点走过，就会发生下图所示的结果，会导致很多节点重复加入队列。

![image-20250826160550820](./pic/image-20250826160550820.png)



ACM

~~~C++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int dir[4][2] = {0, 1, 0, -1, 1, 0, -1, 0};

void bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y)
{
    queue<pair<int, int>> que;
    que.push({x, y});
    visited[x][y] = true;

    while (!que.empty())
    {
        pair<int, int> cur = que.front();
        que.pop();

        int curx = cur.first;
        int cury = cur.second;

        for (int i = 0; i < 4; i++)
        {
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1];
            if (nextx < 0 || nextx >= grid.size() || 
                nexty < 0 || nexty >= grid[0].size())
            {
                continue;
            }

            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1)
            {
                que.push({nextx, nexty});
                visited[nextx][nexty] = true;
            }

        }
    }
}




int main()
{
    int n = 0, m = 0; // n行  m列
    cin >> n >> m;

    vector<vector<int>> grid(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin >> grid[i][j];
        }
    }

    vector<vector<bool>> visited(n, vector<bool>(m, false));
    int result = 0;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if (!visited[i][j] && grid[i][j] == 1)
            {
                result++;
                bfs(grid, visited, i, j);
            }
        }
    }

    cout << result << endl;

    return 0;
}
~~~







## 994 [腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/description/?envType=study-plan-v2&envId=top-100-liked)

@ bfs

![image-20250829153837263](./pic/image-20250829153837263.png)

![image-20250829154739226](./pic/image-20250829154739226.png)



**注意：**

`while (fresh && !que.empty()) ` 里，要记录每层que的大小，要把当前que中的【所有的腐烂橘子】的四个方向都污染了，才算这层结束；

如果不加这个 `int sz = que.size();  for (int k = 0; k < sz; k++) {}` ，这样处理的只是一个腐烂橘子

~~~C++
class Solution {
public:
    // bfs

    int dir[4][2] = {0, 1, 0, -1, 1, 0, -1, 0};
    
    int orangesRotting(vector<vector<int>>& grid) {

        int m = grid.size();
        int n = grid[0].size();

        int ans = 0; 	// 全部腐烂的分钟数
        int fresh = 0; 	// 新鲜橘子个数
        
        queue<pair<int, int>> que; // 存放已经腐烂的橘子坐标
        
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (grid[i][j] == 1)        fresh++; // 收集初始的新鲜橘子个数
                else if (grid[i][j] == 2)   que.push({i, j}); //一开始就腐烂的橘子
            }
        }


        while (fresh && !que.empty()) 
        {
            ans++; // 经过一分钟
            
            // 这一分钟腐烂，要去污染当前que中【所有的腐烂橘子】的周围四个方向 ！！！

            int sz = que.size(); // 当前层的腐烂橘子数量，每个都要去污染4个方向 ！！！
            for (int k = 0; k < sz; k++) 
            {
                auto [curx, cury] = que.front(); // 取出腐烂橘子 cur
                que.pop();

                for (int i = 0; i < 4; i++) // 去污染 cur 的四个方向上的新鲜橘子
                {
                    int nextx = curx + dir[i][0];
                    int nexty = cury + dir[i][1];

                    // 越界，跳过
                    if (nextx < 0 || nextx >= m || nexty < 0 || nexty >= n) continue;

                    // 遇到新鲜橘子
                    if (grid[nextx][nexty] == 1) 
                    {
                        fresh--;                  // 新鲜橘子计数-1
                        grid[nextx][nexty] = 2;   // 变成腐烂橘子，避免重复处理
                        que.push({nextx, nexty}); // 加入腐烂队列
                    }
                }
            
            }
        }


        // 如果最后 fresh = 0 才说明没有新鲜橘子了
        return fresh ? -1 : ans;
    }
};
~~~



## 207 [课程表](https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250829215719156](./pic/image-20250829215719156.png)

每门课程相当于是节点，依赖关系是边，二者构成了一个有向图。

本题转化为**判断有向图中是否存在环**。

举例子看吧



### 1、拓扑排序 （推荐）

思路更清晰

![image-20250829233127663](./pic/image-20250829233127663.png)



canLearn 收集自由课程

模拟学习过程，从自由课程开始学习，不断减少其他课程的先修带来的入度，直到变成自由课程

最后比较 已学课程数 == 所有课程数？相等则能完成学习任务

~~~C++
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {

        int n = prerequisites.size();

        if (n == 0) return true; // 没有依赖关系，直接返回true

        vector<int> indegree(numCourses);          // 每个节点的入度
        vector<vector<int>> adjacency(numCourses); // 邻接矩阵：先修课程-->后续课程集合

        // 统计所有节点的入度，构建邻接矩阵
        for (int i = 0; i < n; i++)
        {
            indegree[prerequisites[i][0]]++; 
            adjacency[prerequisites[i][1]].push_back(prerequisites[i][0]);
        }

        
        // canLearn 收集入度为 0 的节点（入度 = 0表示这门课现在是自由课程，不受先修限制）
        queue<int> canLearn; 
        for (int i = 0; i < numCourses; i++)
        {
            if (indegree[i] == 0)   canLearn.push(i);
        }


        // 模拟学习过程，从自由课程开始学习：
        // 从canLearn中取出课程 A 学习，并减少以A作为先序的其他课程的入度
        // 当一门课的入度减少为0，那么它也可以加入canLearn

        int learned_count = 0; // 记录已学的课程数
        while (!canLearn.empty())
        {
            int learned = canLearn.front(); // 取出可学习课程
            canLearn.pop();
            learned_count++;

            // 这门课学完了，那么以这门课为先修的其他课程节点，可以减少一个入度
            for (int i = 0; i < adjacency[learned].size(); i++)
            {
                indegree[adjacency[learned][i]]--;

                // 有后续课程的入度减为零了，则其变为了自由课程，加入canLearn
                if (indegree[adjacency[learned][i]] == 0)
                {
                    canLearn.push(adjacency[learned][i]);
                }
            }

        }

        // 最后，如果已学的课程数 = 课程总数，说明学习完成
        return learned_count == numCourses;        
    }
};
~~~





### 2、标记 + dfs

![image-20250829224719809](./pic/image-20250829224719809.png)

![image-20250829224906239](./pic/image-20250829224906239.png)

![image-20250829224912204](./pic/image-20250829224912204.png)

~~~C++
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {

        // 根据prerequisites创建有向图grid，pre[a, b] 方向是 b-->a
        vector<vector<int>> grid(numCourses);
        for (auto& p : prerequisites)
        {
            grid[p[1]].push_back(p[0]); // p[1]-->p[0]  p[1]是grid坐标
        }

        // colors 记录节点状态：
        // 0 - 未访问
        // 1 - 节点的邻居正在访问
        // 2 - 节点的所有邻居访问完
        vector<int> colors(numCourses); 
        
        // dfs返回true，表示在节点 x 的关系里，找到了环
        auto dfs = [&](this auto&& dfs, int x)->bool {

            colors[x] = 1; // 节点 x 的邻居正在访问

            // 遍历 x 的邻居，也就是grid[x]里存的数组元素
            for (int y : grid[x]) 
            {
                if (colors[y] == 1 || // 作为x邻居之前，y已经正在处理自己的关系，撞链条了
                    colors[y] == 0 && dfs(y)) // y未访问，递归进入dfs(y)
                {
                    return true;
                }
            }

            colors[x] = 2; // x及x的邻居访问完毕
            
            return false; // 未找到环
        };


        // 遍历节点，每个i都走一遍dfs，i的所有关系里存不存在环
        for (int i = 0; i < numCourses; i++)
        {
            if (colors[i] == 0 && dfs(i))   return false ;
        }

        return true;     // 题目中无环是返回true   
    }
};
~~~







## 208 [实现Trie （前缀树）](https://leetcode.cn/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250830111846192](./pic/image-20250830111846192.png)

题解来自 [@负雪明烛](https://leetcode.cn/problems/implement-trie-prefix-tree/solutions/721050/fu-xue-ming-zhu-cong-er-cha-shu-shuo-qi-628gs)  [@路漫漫我不畏](https://leetcode.cn/problems/implement-trie-prefix-tree/solutions/98390/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt)



![image-20250830175329709](./pic/image-20250830175329709.png)

![image-20250830175603172](./pic/image-20250830175603172.png)



![image-20250830175450601](./pic/image-20250830175450601.png)

![image-20250830175458503](./pic/image-20250830175458503.png)



![image-20250830175405944](./pic/image-20250830175405944.png)



~~~C++
class TrieNode
{
public:
    vector<TrieNode*> children;
    bool isWord;

    TrieNode() : isWord(false), children(26, nullptr) {}

    ~TrieNode() {
        for (auto& c : children)    delete c;
    }
};



class Trie {
private:
    TrieNode* root;

public:
    Trie() {
        root = new TrieNode();
    }
    ~Trie() {
        delete root;  // 会递归释放整棵树
    }
    
    void insert(string word) {
        TrieNode* cur = root; // 从根节点开始匹配word的每个字符
        for (char c : word)
        {
            if (cur->children[c - 'a'] == nullptr) // 不在树上，插入
            {
                cur->children[c - 'a'] = new TrieNode;
            } 
            cur = cur->children[c - 'a'];
        }

        cur->isWord = true; // 结尾
    }


    
    bool search(string word) {

        TrieNode* cur = root; // 从根节点开始匹配word的每个字符
        for (char c : word)
        {
            if (cur->children[c - 'a'] == nullptr) // word某个字符不在树上
            {
                return false;
            }  
            cur = cur->children[c - 'a'];
        }

        return cur->isWord; // cur走到结尾，才算整个word匹配    
    }
    


    bool startsWith(string prefix) { // 类似serch(word)，cur最后可以不是结尾
        TrieNode* cur = root;
        for (char c : prefix)
        {
            if (cur->children[c - 'a'] == nullptr)  return false;
            cur = cur->children[c - 'a'];
        }

        return true;        
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
~~~



资源释放问题，改用智能指针

~~~C++
class TrieNode
{
public:
    vector<unique_ptr<TrieNode>> children;
    bool isWord;

    TrieNode() : isWord(false), children(26) {}
    // 不需要手写析构函数，unique_ptr 会自动递归释放
};


class Trie {
private:
    unique_ptr<TrieNode> root;

public:
    Trie() {
        root = make_unique<TrieNode>();
    }
    
    void insert(string word) {
        TrieNode* cur = root.get(); // 取裸指针操作
        for (char c : word)
        {
            if (!cur->children[c - 'a']) // 不在树上，插入
            {
                cur->children[c - 'a'] = make_unique<TrieNode>();
            }
            cur = cur->children[c - 'a'].get();
        }

        cur->isWord = true;
    }

    bool search(string word) {
        TrieNode* cur = root.get();
        for (char c : word)
        {
            if (!cur->children[c - 'a']) // 不存在
            {
                return false;
            }  
            cur = cur->children[c - 'a'].get();
        }

        return cur->isWord;  
    }
    
    bool startsWith(string prefix) {
        TrieNode* cur = root.get();
        for (char c : prefix)
        {
            if (!cur->children[c - 'a']) return false;
            cur = cur->children[c - 'a'].get();
        }

        return true;        
    }
};
~~~









# 技巧 ✅

## 136 只出现一次的数字

![image-20250808155940561](./pic/image-20250808155940561.png)

![image-20250808155925812](./pic/image-20250808155925812.png)

![image-20250808155947166](./pic/image-20250808155947166.png)

异或运算满足**交换律** a⊕b=b⊕a ，即以上运算结果与 nums 的元素顺序无关。

~~~C++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        
        // 异或 消除相同的数字

        int ans = 0;
        for (int val : nums)
        {
            ans ^= val; // 遍历nums 执行异或，最后留下的就是出现一次的数字
        }

        return ans;
    }
};
~~~



ACM 

~~~C++
#include <vector>
#include <iostream>

using namespace std;

// 136 只出现一次的数字

int singleNumber(vector<int>& nums) {
    
    // 异或 消除相同的数字

    int ans = 0;
    for (int val : nums)
    {
        ans ^= val; // 遍历nums 执行异或，最后留下的就是出现一次的数字
    }

    return ans;
}

int main()
{
    vector<int> nums = {2, 2, 3, 3, 4};
    int ans = singleNumber(nums);
    cout << ans << endl;
    
    return 0;
}
~~~





## 169 [多数元素](https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250809093934885](./pic/image-20250809093934885.png)



### 1、哈希表

~~~C++
class Solution {
public:
    int majorityElement(vector<int>& nums) {


        unordered_map<int, int> counts;// 存储每个元素出现的次数
        
        int majority = 0; // 出现最多的元素
        int cnt = 0;      // 出现最多的次数

        for (int num : nums)
        {
            counts[num]++; // 计数
            if (counts[num] > cnt)
            {
                majority = num;
                cnt = counts[num];
            }
        }

        return majority;        
    }
};
~~~

时间复杂度：O(n)

空间复杂度：O(n)



### 2、排序

![image-20250809094939242](./pic/image-20250809094939242.png)

~~~C++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        
        // 排序
        sort(nums.begin(), nums.end());
        return nums[nums.size() / 2]; // 下标[n/2]处是众数
    }
};
~~~

时间复杂度：O(nlogn)。

空间复杂度：O(logn)。如果使用语言自带的排序算法，需要使用 O(logn) 的栈空间。如果自己编写堆排序，则只需要使用 O(1) 的额外空间。



### 3、摩尔投票

记住结论就好

![image-20250809161651460](./pic/image-20250809161651460.png)

![image-20250809161635757](./pic/image-20250809161635757.png)

![image-20250809163640100](./pic/image-20250809163640100.png)



~~~C++
class Solution {
public:
    int majorityElement(vector<int>& nums) {

        // 摩尔投票（直接记住方法）

        int candidate = 0; // 候选众数
        int votes = 0; // 投票

        for (int num : nums)
        {
            if (votes == 0) candidate = num; // 每当votes=0，更新候选众数
            votes += (num == candidate ? 1 : -1); // num = candidate 投票+1，否则-1
        }

        return candidate;    
    }
};
~~~



### ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 169 多数元素

int majorityElement(vector<int>& nums) {

    // 摩尔投票

    int candidate = 0; // 候选众数
    int votes = 0; // 投票

    for (int num : nums)
    {
        if (votes == 0) candidate = num; // 每当votes=0，更新候选众数
        votes += (num == candidate ? 1 : -1); // num = candidate 投票+1，否则-1
    }

    return candidate;
}


int main()
{
    vector<int> nums = {2,2,1,1,1,2,2};
    int ans = majorityElement(nums);

    cout << ans << endl;

    return 0;
}
~~~





## 75 [颜色分类](https://leetcode.cn/problems/sort-colors/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250809231326771](./pic/image-20250809231326771.png)

![image-20250809231522678](./pic/image-20250809231522678.png)

![image-20250809231806307](./pic/image-20250809231806307.png)

![image-20250809231815853](./pic/image-20250809231815853.png)

复杂度分析

- 时间复杂度：O(*n*)，其中 *n* 是 *nums* 的长度。
- 空间复杂度：O(1)。



![image-20250809235538404](./pic/image-20250809235538404.png)

**模拟向 nums 有序的 [0, i-1] 范围，插入nums[i]，然后变成有序的 [0, i] 范围**，向后遍历，直到nums最后。

**三个位置：**

- p0 ：维护 0 的个数，表示下一个要插入0 的位置
- p1：维护 1 的个数，表示下一个要插入1的位置
- i ： 遍历下标，插入nums[i]后的有序范围就是 [0, i]，也就是目前有序数组的最后一个位置，表示要改成2的位置

**1、插入值，直接改最后一个值为2**——  `nums[i] = 2`

> 因为 2 位置前是包括0 和 1 和 2 的，所以插0插1插2都要动这个位置

- 如果插入的是2，那正好 2 应该放在最后
- 如果插入的不是2，下面的 `if 0 or 1` 会覆盖前面应该是 0 or 1的位置，也相当于把2挪到了最后

**2、如果插入的是 0 或 1 —— 修改 p1 位置为1，并后移 p1**  `nums[p1++] = 1`

> 因为 p1 位置前是包括0 和 1 的，所以插0插1都要动这个位置

- 如果插的是1，改完这个位置，结束
- 如果插的是0，下面的`if 0` 会覆盖前面应该是 0 的位置，也相当于把 1 后移了

**3、如果插入的是0 —— 修改 p0 位置为0，并后移 p0** `nums[p0++] = 0`

- 直接改 p0 位置，需要后移的 1 和 2 都在上面处理了



~~~C++
class Solution {
public:
    void sortColors(vector<int>& nums) {

        int p0 = 0; // 维护0的个数（下标）
        int p1 = 0; // 维护1的个数（下标）

        
        for (int i = 0; i < nums.size(); i++)
        {
            int x = nums[i]; // 不断向nums的[0, i-1] 中插入当前 nums[i]

            nums[i] = 2;                // 直接最后一个位置改为2，2始终在最后
            if (x <= 1) nums[p1++] = 1; // 插入的是 0 或 1 
            if (x == 0) nums[p0++] = 0; // 插入的是 0
        }
        
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 75 颜色分类

void sortColors(vector<int>& nums) {

    int p0 = 0; // 维护0的个数（下标）
    int p1 = 0; // 维护1的个数（下标）

    
    for (int i = 0; i < nums.size(); i++)
    {
        int x = nums[i]; // 不断向nums的[0, i-1] 中插入当前 nums[i]

        nums[i] = 2;                // 直接最后一个位置改为2，2始终在最后
        if (x <= 1) nums[p1++] = 1; // 插入的是 0 或 1 
        if (x == 0) nums[p0++] = 0; // 插入的是 0
    }
    
}


int main()
{
    vector<int> nums = {2, 0, 2, 1, 1, 0};
    sortColors(nums);
    for (int val : nums)
    {
        cout << val << " ";
    }
    cout << endl;

    return 0;
}

~~~



## 31 [下一个排列](https://leetcode.cn/problems/next-permutation/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250810212702731](./pic/image-20250810212702731.png)

垃圾题目描述

评论区给的示例：[1, 2, 3] 排列组合，从小到大

[1, 2, 3] 123
[1, 3, 2] 132
[2, 1, 3] 213
[2, 3, 1] 231
[3, 1, 2] 312
[3, 2, 1] 321

[1,2,3]下一个就是[1, 3, 2]
[2, 3, 1]的下一个就是[3, 1, 2]
[3, 2, 1]的下一个是[1, 2, 3] 回到起点

![image-20250810213112725](./pic/image-20250810213112725.png)![image-20250810220059066](./pic/image-20250810220059066.png)![image-20250810213956893](./pic/image-20250810213956893.png)

![image-20250810214306326](./pic/image-20250810214306326.png)



~~~C++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {

        int n = nums.size();

        // [1, 3, 5, 4, 2] 排列组合里面的数字，找下一个比13542大的组合

        // 1. 从右向左找到第一个小于右侧相邻数字的数 nums[i] (3)
        int i = n - 2;
        while (i >=0 && nums[i] >= nums[i + 1]) i--;


        // 找到，进入第2步；否则(i < 0)跳过第2步，说明现在排列递减，是最大数        
        if (i >= 0) 
        {
            // 2. 从右向左，找到 i 右侧第一个大于 nums[i](3) 的数 nums[j](4)，交换
            int j = n - 1;
            while (j > i && nums[i] >= nums[j])  j--;
  
            swap(nums[i], nums[j]); // [1, 4, 5, 3, 2]
        }


        // 3 反转 新nums[i] 后面的数 -  [1, 4, 2, 3, 5]
        reverse(nums.begin() + i + 1, nums.end());
        
    }
};
~~~

复杂度分析

- 时间复杂度：O(*n*)，其中 *n* 是 *nums* 的长度。最坏情况下需要遍历整个 *nums* 数组。
- 空间复杂度：O(1)。





ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 31 下一个排列


void nextPermutation(vector<int>& nums) {

    int n = nums.size();

    // [1, 3, 5, 4, 2] 排列组合里面的数字，找下一个比13542大的组合

    // 1. 从右向左找到第一个小于右侧相邻数字的数 nums[i] (3)
    int i = n - 2;
    while (i >=0 && nums[i] >= nums[i + 1]) i--;


    // 找到，进入第2步；否则(i < 0)跳过第2步，说明现在排列递减，是最大数        
    if (i >= 0) 
    {
        // 2. 从右向左，找到 i 右侧第一个大于 nums[i](3) 的数 nums[j](4)，交换
        int j = n - 1;
        while (j > i && nums[i] >= nums[j])  j--;

        swap(nums[i], nums[j]); // [1, 4, 5, 3, 2]
    }


    // 3 反转 新nums[i] 后面的数 -  [1, 4, 2, 3, 5]
    reverse(nums.begin() + i + 1, nums.end());
    
}


int main()
{
    vector<int> nums = {1, 2, 3};
    nextPermutation(nums);
    for (int val : nums)    cout << val << " ";
    cout << endl;

    return 0;
}
~~~





## 287 [寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250810225618176](./pic/image-20250810225618176.png)



自己写的，但是不让修改原数组，不能排序，算了

二分比较真正的中间值，和实际的中间值，举个例子看

时间复杂度：O(nlogn)

空间复杂度：O(1)

~~~C++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
    
        sort(nums.begin(), nums.end());

        // [1, 2, 2, 3, 4] 对应的没有重复的数组：
        // [1, 2, 3, 4, 5]
        
        // 比较中间值，二分

        int left = 0;
        int right = nums.size() - 1; // 坐标

        while (left <= right)
        {
            int midnum = ((left + 1) + (right + 1)) / 2; // 真正的中间值[3] 
            int midIndex = left + ((right - left) / 2); 
            
            if (nums[midIndex] >= midnum) // 往右找 
            {
                left = midIndex + 1;
            }
            else // 往左找 [2] < [3]
            {
                right = midIndex - 1;
            }
        }

        return nums[right];
        
    }
};
~~~



### 1、二分

![image-20250811105312019](./pic/image-20250811105312019.png)



~~~C++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        // [1, 3, 4, 2, 2]

        // 数值范围 min，max 是 1 到 n  [1,4]
        int min = 1; 
        int max = nums.size(); 

        while (min < max)
        {
            int mid = (min + max) / 2; // 数值的中间值 (1 + 4)/2 = 2

            // 统计[1,n/2]范围的数字个数 [1,2]
            int cnt = 0; 
            for (int v : nums)
            {
                if (v >= min && v <= mid)    cnt++; 
            }

            // 个数超过范围应有的长度，即存在重复数 （[1,2]应该只有两个数，但nums中有3个）
            if (cnt > mid - min + 1)    max = mid;
            else                        min = mid + 1;
        }
        
        return min; // 最后min停在目标数字上
    }
};
~~~


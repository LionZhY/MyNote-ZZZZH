> åŠ›æ‰£hot100æ€»ç»“ï¼Œä¸»è¦å‚è€ƒ[ä»£ç éšæƒ³å½•](https://programmercarl.com/)å’ŒåŠ›æ‰£é¢˜è§£åŒºå„ä½å¤§ç¥çš„é¢˜è§£ä»¥åŠgpt
>
> å®Œç»“å•¦ ğŸ‰ğŸ‰ğŸ‰



# å“ˆå¸Œ âœ…

> ***éœ€è¦æŸ¥è¯¢ä¸€ä¸ªå…ƒç´ æ˜¯å¦å‡ºç°è¿‡ï¼Œæˆ–è€…ä¸€ä¸ªå…ƒç´ æ˜¯å¦åœ¨é›†åˆé‡Œçš„æ—¶å€™ï¼Œå°±è¦ç¬¬ä¸€æ—¶é—´æƒ³åˆ°å“ˆå¸Œæ³•***

## 1 [ä¸¤æ•°ä¹‹å’Œ](https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked)

@å“ˆå¸Œ @æ•°ç»„

![image-20250601163055315](pic/image-20250601163055315.png)

éå†æ•°ç»„ï¼Œéœ€è¦ä¸€ä¸ªé›†åˆ**å­˜æ”¾ã€éå†è¿‡çš„å…ƒç´ ã€‘**ï¼Œåœ¨éå†æ•°ç»„numsçš„æ—¶å€™ï¼ŒåŒæ—¶å»è¿™ä¸ªç»„åˆä¸­å¯»æ‰¾ï¼ŒæŸå…ƒç´ ã€ target - å½“å‰éå†å…ƒç´  nums[i] ã€‘æ˜¯å¦å‡ºç°è¿‡ã€‚

å› ä¸ºæœ€åè¦æ‰¾åˆ°è¿™ä¸ªå…ƒç´ æ˜¯å¦å‡ºç°è¿‡ï¼Œè¿˜éœ€è¦å¾—åˆ°è¿™ä¸ªå…ƒç´ çš„ä¸‹æ ‡ï¼Œéœ€è¦ä½¿ç”¨key-valueç»“æ„å­˜æ”¾ï¼š

**< key: å…ƒç´ nums[i]ï¼Œ valueï¼šä¸‹æ ‡ i >**

åˆ¤æ–­å…ƒç´ æ˜¯å¦å‡ºç°è¿‡ï¼Œé‚£ä¹ˆå…ƒç´ å°±è¦ä½œä¸ºkeyï¼Œé€šè¿‡å…ƒç´ æ‰¾ä¸‹æ ‡ï¼Œä¸‹æ ‡ä½œä¸ºvalueã€‚

> std::unordered_map åº•å±‚å®ç°ä¸ºå“ˆå¸Œè¡¨ï¼Œstd::map å’Œstd::multimap çš„åº•å±‚å®ç°æ˜¯çº¢é»‘æ ‘ã€‚
>
> std::map å’Œstd::multimap çš„keyä¹Ÿæ˜¯æœ‰åºçš„,**è¿™é“é¢˜ç›®ä¸­å¹¶ä¸éœ€è¦keyæœ‰åºï¼Œé€‰æ‹©std::unordered_map æ•ˆç‡æ›´é«˜ï¼** 



![image-20250601171032968](pic/image-20250601171032968.png)

~~~C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        
        // unordered_map ä¸é‡å¤ æ— åºkey å­˜æ”¾éå†è¿‡çš„å…ƒç´ 
        unordered_map<int, int> umap; // < nums[i], ä¸‹æ ‡ i>

        for (int i = 0; i < nums.size(); i++)
        {
            //find æŸ¥æ‰¾ target - nums[i] åœ¨ä¸åœ¨ umapä¸­
            if (umap.find(target - nums[i]) != umap.end()) 
            {
                return {umap[target - nums[i]], i}; // æ‰¾åˆ°ï¼Œç›´æ¥è¿”å›ä¸‹æ ‡æ•°ç»„
            }
            umap.insert(pair<int, int>(nums[i], i));// æ²¡æ‰¾åˆ°ï¼Œå°±å­˜åˆ°umapé‡Œ
        }

        return {}; // æ²¡ç¬¦åˆæ¡ä»¶çš„ï¼Œè¿”å›ç©ºæ•°ç»„
        
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ï¼šO(N)

ç©ºé—´å¤æ‚åº¦ï¼šO(N)



**ACM** 

~~~C++
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

vector<int> twoSum(vector<int>& nums, int target)
{
	unordered_map<int, int> umap;
	for (int i = 0; i < nums.size(); i++)
	{
		if (umap.find(target - nums[i]) != umap.end())
		{
			return { umap[target - nums[i]], i };
		}
		umap.insert(pair<int, int>(nums[i], i));
	}
	
	return {};
}

int main() {
	int n, target; // æ•°ç»„é•¿åº¦nï¼Œç›®æ ‡å€¼target
	cin >> n >> target;
	vector<int> nums(n);

	for (int i = 0; i < n; i++) {
		cin >> nums[i]; // è¾“å…¥æ•°ç»„å…ƒç´ 
	}

	vector<int> result = twoSum(nums, target);

	if (!result.empty()) {
		cout << result[0] << " " << result[1] << endl;
	}
	else {
		cout << "No result" << endl;
	}

	return 0;

}
~~~

 ç¤ºä¾‹è¾“å…¥ï¼š

~~~C++
4 9
2 7 11 15
~~~

ç¤ºä¾‹è¾“å‡ºï¼š

~~~C++
0 1
~~~



## [49 å­—æ¯å¼‚ä½è¯åˆ†ç»„](https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250603102842280](pic/image-20250603102842280.png)

![image-20250603103135066](pic/image-20250603103135066.png)

![image-20250603104320749](pic/image-20250603104320749.png)



~~~C++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {

        // å“ˆå¸Œ 
        // key: æ’åºåçš„å­—ç¬¦ä¸²ï¼ˆå¼‚ä½è¯æ’åºåç»“æœç›¸åŒï¼‰
        // value: åŸå§‹å­—ç¬¦ä¸²ç»„æˆçš„åˆ—è¡¨ï¼ˆå±äºåŒä¸€ç»„çš„å¼‚ä½è¯ç»„åˆï¼‰--> å³ç­”æ¡ˆ

        unordered_map<string, vector<string>> umap;

        for (string& s : strs)
        {
            // æ’åºstrsä¸­æ¯ä¸€ä¸ªå­—ç¬¦ä¸²
            string sorted_s = s;
            ranges::sort(sorted_s);// æŒ‰ç…§ASCIIå€¼æ’åºsï¼Œæ’åºåå¼‚ä½è¯ä¼šå˜æˆç›¸åŒçš„å­—ç¬¦ä¸²

            // sorted_s ç›¸åŒçš„åŸå­—ç¬¦ä¸²ï¼Œå½’åˆ°ä¸€ç»„
            umap[sorted_s].push_back(s);
        }

        // æ•´ç†è¿”å›çš„å­—ç¬¦ä¸²æ•°ç»„
        vector<vector<string>> ans;
        ans.reserve(umap.size()); // é¢„åˆ†é…ç©ºé—´

        for (auto& [_, value] : umap) // éå†umapï¼Œè§£æ„umapï¼Œåªå…³å¿ƒvalueçš„å€¼
        {
            ans.push_back(value); // æ¯ä¸ªåˆ†ç»„åˆ—è¡¨åŠ å…¥ç»“æœ
        }

        return ans;    
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <vector>
#include <string>
#include <unordered_map>
#include <algorithm>

using namespace std;

vector<vector<string>> groupAnagrams(const vector<string>& strs)
{
    unordered_map<string, vector<string>> umap;

    for (const string& s : strs)
    {
        string sorted_s = s;
        // æ’åº åˆ†ç»„
        sort(sorted_s.begin(), sorted_s.end()); // æˆ–è€…ranges::sort(sorted_s);
        umap[sorted_s].push_back(s);
    }

    vector<vector<string>> ans;
    ans.reserve(umap.size());
    for (auto& [_, value] : umap) 
    {
        ans.push_back(value);
    }

    return ans;
}

int main()
{
    int n; // å­—ç¬¦ä¸²æ•°é‡
    cin >> n;
    vector<string> inputStr(n); // å­—ç¬¦ä¸²
    for (int i = 0; i < n; i++)
    {
        cin >> inputStr[i];
    }

    // è°ƒç”¨å‡½æ•°
    vector<vector<string>> result = groupAnagrams(inputStr);

    // è¾“å‡º
    for (const auto& group : result)
    {
        for (const string& word : group)
        {
            cout << word << " ";
        }
        cout << endl;
    }

    return 0;
}
~~~

ç¤ºä¾‹è¾“å…¥ï¼š

~~~C++
6
eat tea tan ate nat bat
~~~

ç¤ºä¾‹è¾“å‡ºï¼š

~~~C++
eat tea ate 
tan nat 
bat 
~~~



## [128 æœ€é•¿è¿ç»­åºåˆ—](https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&envId=top-100-liked)

![image-20250604104439319](pic/image-20250604104439319.png)

![image-20250604104627175](pic/image-20250604104627175.png)

`contains()` æ˜¯ C++20 å¼•å…¥çš„æˆå‘˜å‡½æ•°ï¼Œç”¨äºåˆ¤æ–­æŸä¸ªå…ƒç´ æ˜¯å¦å­˜åœ¨äºå…³è”å®¹å™¨ä¸­ã€‚

å°†æ•°ç»„ nums ä¸­çš„æ‰€æœ‰å…ƒç´ å­˜å…¥ä¸€ä¸ªå“ˆå¸Œé›†åˆ stï¼Œè¿™æ ·å¯ä»¥åœ¨ **O(1)** æ—¶é—´å†…åˆ¤æ–­æŸä¸ªæ•°æ˜¯å¦å­˜åœ¨ã€‚

![image-20250604104849078](pic/image-20250604104849078.png)

~~~C++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {

        int ans = 0;

        // æŠŠnumsè½¬æˆå“ˆå¸Œé›†åˆ ï¼ˆæ— åºä¸é‡å¤ï¼‰
        unordered_set<int> st(nums.begin(), nums.end());

        // æ³¨æ„ï¼šè¿™é‡Œéå†çš„æ˜¯é›†åˆï¼Œä¸æ˜¯åŸæ•°ç»„
        for (int x : st)
        {
            // å¦‚æœ x-1 åœ¨é›†åˆä¸­ï¼Œè¯´æ˜ x ä¸æ˜¯æŸä¸ªè¿ç»­åºåˆ—çš„èµ·ç‚¹ï¼Œè·³è¿‡
            if (st.contains(x - 1))
            {
                continue;
            }

            // x æ˜¯åºåˆ—çš„èµ·ç‚¹
            int y = x + 1;
            while (st.contains(y)) // ä¸æ–­å‘åæŸ¥æ‰¾ä¸‹ä¸€ä¸ªæ•°æ˜¯å¦åœ¨å“ˆå¸Œé›†åˆä¸­
            {
                y++;
            }

            // ä¸€ç›´æ‰¾çŸ¥é“æ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªè¿ç»­çš„æ•°ä¸ºæ­¢ï¼Œæ­¤æ—¶çš„ y æ˜¯ç¬¬ä¸€ä¸ªä¸åœ¨é›†åˆä¸­çš„æ•°
            // y - 1 å°±æ˜¯æœ€åä¸€ä¸ªåœ¨å“ˆå¸Œé›†åˆä¸­çš„æ•°

            // æ›´æ–°é•¿åº¦
            ans = max(ans, y - x); // [x, y-1]æ˜¯ä¸€ä¸ªè¿ç»­åºåˆ—ï¼Œé•¿åº¦æ˜¯ y - x
        }

        return ans;
    }
};
~~~

ACM æ¨¡å¼ï¼š

~~~C++
#include <vector>
#include <unordered_set>
#include <iostream>
#include <algorithm>


int longestConsecutive(const std::vector<int>& nums)
{
    int ans = 0;

    std::unordered_set<int> st(nums.begin(), nums.end()); // æ— åºä¸é‡å¤
    for (int x : st)
    {
        // å¦‚æœ x ä¸æ˜¯è¿ç»­åºåˆ—çš„èµ·ç‚¹ï¼Œè·³è¿‡
        if (st.find(x - 1) != st.end())
        {
            continue;
        }
        // x æ˜¯è¿ç»­åºåˆ—çš„èµ·ç‚¹ï¼Œä¸æ–­å‘åå¯»æ‰¾ä¸‹ä¸€ä¸ªæ•°
        int y = x + 1;
        while (st.find(y) != st.end())
        {
            y++;
        }

        ans = std::max(ans, y - x); // æ›´æ–°è¿ç»­åºåˆ—æœ€å¤§é•¿åº¦
    }

    return ans;
}


int main()
{
    int n;
    std::cin >> n; // è¾“å…¥æ•°å­—ä¸ªæ•°

    std::vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        std::cin >> nums[i]; // è¾“å…¥æ•°ç»„ nums
    }

    int result = longestConsecutive(nums);
    std::cout << result << std::endl;

    return 0;
}
~~~



# åŒæŒ‡é’ˆ âœ…

## [283 ç§»åŠ¨é›¶ï¼ˆå¿«æ…¢æŒ‡é’ˆï¼‰](https://leetcode.cn/problems/move-zeroes/?envType=study-plan-v2&envId=top-100-liked)

@å¿«æ…¢æŒ‡é’ˆ

![image-20250608105541481](pic/image-20250608105541481.png)



**å’Œ 27ã€ç§»é™¤å…ƒç´  ç›¸åŒï¼Œå¤šä¸€æ­¥slowåŠslowä¹‹åç½®é›¶**

~~~C++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // å¿«æ…¢æŒ‡é’ˆ

        int slowIndex = 0;
        int fastIndex = 0;

        for (fastIndex = 0; fastIndex < nums.size(); fastIndex++)
        {
            if (nums[fastIndex] != 0)
            {
                nums[slowIndex++] = nums[fastIndex]; // è¦†ç›– 0
            }
        }

        // å°†slowIndexåŠslowIndexä¹‹åçš„å…ƒç´ éƒ½ç½®é›¶
        for (int i = slowIndex; i < nums.size(); i++)
        {
            nums[i] = 0;
        }

    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <vector>

using namespace std;

void moveZero(vector<int>& nums)
{
    int slowIndex = 0;
    int fastIndex = 0;

    for (fastIndex = 0; fastIndex < nums.size(); fastIndex++)
    {
        if (nums[fastIndex] != 0)
        {
            nums[slowIndex++] = nums[fastIndex]; // åŸåœ°å‘å‰è¦†ç›–0
        }
    }

    for (int i = slowIndex; i < nums.size(); i++)
    {
        nums[i] = 0;
    }
}


int main() 
{
    int n;
    cin >> n; // è¾“å…¥æ•°ç»„ä¸ªæ•°

    vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i]; // è¾“å…¥æ•°ç»„å…ƒç´ 
    }

    moveZero(nums); // ç§»åŠ¨ 0

    for (int i = 0; i < n; i++)
    {
        cout << nums[i] << " "; // è¾“å‡ºç§»åŠ¨0åçš„nums
    }
    cout << endl;

    return 0;
}
~~~

ç¤ºä¾‹è¾“å…¥ï¼š

~~~C++
6
0 1 0 3 12 0
~~~

è¾“å‡ºï¼š

~~~C++
1 3 12 0 0 0
~~~





## [11 ç››æœ€å¤šæ°´çš„å®¹å™¨ï¼ˆæ”¶ç¼©ï¼‰](https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250609102202043](pic/image-20250609102202043.png)

![image-20250609103156207](pic/image-20250609103156207.png)



~~~C++
class Solution {
public:
    int maxArea(vector<int>& height) {

        // åŒæŒ‡é’ˆ æ”¶ç¼©
        
        int ans = 0;

        int left = 0;
        int right = height.size() - 1;

        while(left < right) // åªè¦ left < right å°±è¿˜èƒ½æ„æˆçŸ©å½¢é¢ç§¯
        {
            int area = (right - left) * min(height[left], height[right]); // çŸ©å½¢é¢ç§¯
            ans = max(ans, area); // ansä¿æŒæœ€å¤§å€¼

            // ç§»åŠ¨çŸ­è¾¹
            height[left] < height[right] ? left++ : right--;

            // å› ä¸ºçŸ­è¾¹èƒ½æ„æˆçš„æœ€å¤§çš„é¢ç§¯ï¼Œå°±æ˜¯area
        }
        
        return ans;
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <vector>

using namespace std;

int maxArea(vector<int>& height)
{
    int ans = 0;

    int left = 0;
    int right = height.size() - 1;

    while (left < right)
    {
        int area = (right - left) * min(height[left], height[right]);
        ans = max(ans, area);

        // ç§»åŠ¨çŸ­è¾¹
        height[left] < height[right] ? left++ : right--;
    }

    return ans;
}

int main()
{
    int n;
    cin >> n; // heightæ•°ç»„é•¿åº¦ï¼ˆæŸ±å­æ•°é‡ï¼‰

    vector<int> height(n);
    for (int i = 0; i < n; i++)
    {
        cin >> height[i]; // è¾“å…¥æ¯æ ¹æŸ±å­çš„é«˜åº¦
    }

    int result = maxArea(height);
    cout << result << endl; // è¾“å‡ºæœ€å¤§ç››æ°´é¢ç§¯

    return 0;
}
~~~

ç¤ºä¾‹è¾“å…¥ï¼š

~~~C++
9
1 8 6 2 5 4 8 3 7
~~~

è¾“å‡ºï¼š

~~~C++
49
~~~



## [15 ä¸‰æ•°ä¹‹å’Œï¼ˆæ”¶ç¼©ï¼‰](https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&envId=top-100-liked)

@åŒæŒ‡é’ˆæ”¶ç¼©

![image-20250609112752426](pic/image-20250609112752426.png)



åŒæŒ‡é’ˆæ”¶ç¼©ï¼Œå¤§äº†å¾€å·¦ï¼Œå°äº†å¾€å³

<img src="pic/image-20250609112849338.png" alt="image-20250609112849338" style="zoom:50%;" />

![image-20250609112912089](pic/image-20250609112912089.png)



![image-20250609113009075](pic/image-20250609113009075.png)

![image-20250610101954614](pic/image-20250610101954614.png)



~~~C++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {

        // å…ˆæ’åºnums
        sort(nums.begin(), nums.end());
        
        vector<vector<int>> result;
        
        for (int i = 0; i < nums.size(); i++)
        {
            // æ’åºåç¬¬ä¸€ä¸ªå…ƒç´ å·²ç»å¤§äº0ï¼Œä¸å¯èƒ½å‡‘æˆä¸‰å…ƒç»„
            if (nums[i] > 0)    break;
            
            // å»é‡ a
            // å¦‚æœiå’Œi-1å…ƒç´ ç›¸åŒï¼Œè¯´æ˜åé¢éå†ç»„åˆçš„ä¸‰æ•°ä¹‹å’Œåœ¨nums[i-1]çš„æ—¶å€™è¢«ç»„åˆè¿‡äº†ï¼Œè·³è¿‡
            if (i > 0 && nums[i] == nums[i - 1])    continue;

            // a = nums[i]  b = nums[left]  c = nums[right]   å›ºå®šiï¼Œç§»åŠ¨left right
            int left = i + 1;
            int right = nums.size() - 1;
            while(left < right) 
            {
                // ä¸‰æ•°ä¹‹å’Œ > 0ï¼Œrightå‘å·¦ç§»åŠ¨ï¼Œè®©å’Œå˜å°
                if (nums[i] + nums[left] + nums[right] > 0) right--;
                
                // ä¸‰æ•°ä¹‹å’Œ < 0ï¼Œleftå‘å³ç§»åŠ¨ï¼Œè®©å’Œå˜å¤§
                else if (nums[i] + nums[left] + nums[right] < 0) left++;
                
                // ä¸‰æ•°ä¹‹å’Œ = 0ï¼Œæ‰¾åˆ°ä¸€ä¸ªä¸‰å…ƒç»„
                else 
                {
                    // æ”¶é›†ä¸‰å…ƒç»„
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    
                    // å»é‡bå’Œcï¼Œå‘é‡Œæ”¶ç¼©
                    while (right > left && nums[right] == nums[right - 1])	right--;
                    while (right > left && nums[left] == nums[left + 1])	left++;
                    
                    // æ‰¾åˆ°ä¸€ç»„ä¸‰å…ƒç»„åï¼Œleftå’ŒrightåŒæ—¶å‘é‡Œæ”¶ç¼©ï¼Œå¯»æ‰¾ä¸‹ä¸€ç»„
                    right--;
                    left++;
                }
                
            }
        }

        return result;        
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ï¼š*O*(*n*2)

ç©ºé—´å¤æ‚åº¦ï¼šO(1)



ACM

~~~C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<vector<int>> threeSum(vector<int>& nums) 
{
    vector<vector<int>> result;
    
    // æ’åºnums
    sort(nums.begin(), nums.end());

    // a = nums[i]  b = nums[left]   c = nums[right]
    for (int i = 0; i < nums.size(); i++)
    {
        // æ’åºåç¬¬ä¸€ä¸ªå…ƒç´ å·²ç»å¤§äº0ï¼Œä¸å¯èƒ½å‡‘æˆä¸‰å…ƒç»„
        if (nums[i] > 0)    break;
        
        // å»é‡ a
        if (i > 0 && nums[i] == nums[i - 1])    continue;

        // ç§»åŠ¨left right åˆ¤æ–­ä¸‰æ•°ä¹‹å’Œ
        int left = i + 1;
        int right = nums.size() - 1;
        while(left < right)
        {
            if (nums[i] + nums[left] + nums[right] > 0) right--;
            else if (nums[i] + nums[left] + nums[right] < 0) left++;
            else // ä¸‰æ•°ä¹‹å’Œ = 0ï¼Œæ‰¾åˆ°ä¸€ä¸ªä¸‰å…ƒç»„
            {
                // æ”¶é›†ä¸‰å…ƒç»„
                result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                // å»é‡bå’Œcï¼Œå‘é‡Œæ”¶ç¼©
                while (right > left && nums[right] == nums[right - 1])
                {
                    right--;
                }
                while (right > left && nums[left] == nums[left + 1])
                {
                    left++;
                }
                // æ‰¾åˆ°ä¸€ç»„ä¸‰å…ƒç»„åï¼Œleftå’ŒrightåŒæ—¶å‘é‡Œæ”¶ç¼©ï¼Œå¯»æ‰¾ä¸‹ä¸€ç»„
                right--;
                left++;
            }
        }
    }
    return result;        
}


int main()
{
    int n;
    cin >> n; // numsæ•°ç»„é•¿åº¦

    vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i]; // è¾“å…¥numsæ•°ç»„
    }

    vector<vector<int>> result = threeSum(nums);

    for (int i = 0; i < result.size(); i++)
    {
        for (int j = 0; j < result[i].size(); j++)
        {
            cout << result[i][j] << " ";
        }
        cout << endl;
    }
    
    return 0;
}
~~~





## 42 [æ¥é›¨æ°´](https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-100-liked)

@å‰ç¼€å’Œ @åŒæŒ‡é’ˆæ”¶ç¼©

![image-20250610110445823](pic/image-20250610110445823.png)

### 1ã€å‰åç¼€åˆ†ç¦»

åˆ†å‰²æˆæ¯ä¸ª height[i] ä¸€å—ï¼ŒæŠŠæ¯å—çœ‹æˆæ˜¯å®½åº¦æ˜¯1ï¼Œé«˜åº¦ä¸º height[i] çš„æ°´æ¡¶ï¼Œèƒ½ç››å¤šå°‘æ°´ï¼Œ**å–å†³äºå·¦å³ä¸¤è¾¹æŒ¡æ¿çš„çŸ­æ¿æœ‰å¤šé«˜**ï¼Œä¹Ÿå°±æ˜¯å½“å‰height[i]**å‰åçš„æœ€é«˜é«˜åº¦å–è¾ƒå°å€¼**ã€‚

<img src="pic/image-20250610114059789.png" alt="image-20250610114059789" style="zoom:50%;" />

<img src="pic/image-20250610113706432.png" alt="image-20250610113706432" style="zoom: 50%;" />

height[i] çš„**ã€å·¦è¾¹æœ€é«˜é«˜åº¦ï¼Œå³è¾¹æœ€é«˜é«˜åº¦ã€‘å–æœ€å°å€¼**ï¼Œå†**å‡å» height[i]** å°±æ˜¯å½“å‰è¿™ä¸ªå—èƒ½ç››çš„æ°´çš„é«˜åº¦ï¼Œä¹Ÿå³é¢ç§¯ï¼ˆåº•éƒ¨å®½åº¦ä¸º1ï¼‰ã€‚

~~~C++
ans += min(pre_max[i], suf_max[i]) - height[i]; // æ¯å—çš„é¢ç§¯ï¼Œå®½åº¦æ˜¯1
~~~

~~~C++
class Solution {
public:
    int trap(vector<int>& height) {
        
        // å‰åç¼€åˆ†ç¦»
		// æ—¶é—´å¤æ‚åº¦ O(n)   ç©ºé—´å¤æ‚åº¦ O(n)
        int n = height.size();

        // ä» height[0] åˆ° height[i] çš„æœ€å¤§å€¼ï¼Œä»å‰å‘å
        vector<int> pre_max(n); 
        pre_max[0] = height[0];
        for (int i = 1; i < n; i++)	pre_max[i] = max(pre_max[i - 1], height[i]);
        
        // ä» height[n-1] åˆ° height[i] çš„æœ€å¤§å€¼ï¼Œä»åå‘å‰
        vector<int> suf_max(n); 
        suf_max[n - 1] = height[n - 1];
        for (int i = n - 2; i >= 0; i--)	suf_max[i] = max(suf_max[i + 1], height[i]);
        

        int ans = 0;
        for (int i = 0; i < n; i++)
        {
            // å– å‰ç¼€åç¼€çš„è¾ƒå°å€¼ - height[i] ä½œä¸ºå½“å‰ç››æ°´çš„é«˜åº¦
            ans += min(pre_max[i], suf_max[i]) - height[i]; // æ¯å—çš„é¢ç§¯ï¼Œå®½åº¦æ˜¯1
        }

        return ans;
    }
};
~~~



ACMï¼š

~~~C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int trap(vector<int>& height) 
{
    int n = height.size();

    // å‰ç¼€æœ€å¤§å€¼
    vector<int> pre_max(n);
    pre_max[0] = height[0];
    for (int i = 1; i < n; i++)
    {
        pre_max[i] = max(pre_max[i - 1], height[i]);
    }
    // åç¼€æœ€å¤§å€¼
    vector<int> suf_max(n);
    suf_max[n - 1] = height[n - 1];
    for (int i = n - 2; i >= 0; i--)
    {
        suf_max[i] = max(suf_max[i + 1], height[i]);
    }

    int ans = 0;
    for (int i = 0; i < n; i++)
    {
        ans += min(suf_max[i], pre_max[i]) - height[i]; // ç´¯åŠ é¢ç§¯
    }
    return ans;
    
}

int main()
{
    int n;
    cin >> n; // è¾“å…¥heighté•¿åº¦

    vector<int> height(n);
    for (int i = 0; i < n; i++)
    {
        cin >> height[i]; // è¾“å…¥heightæ•°ç»„
    }

    int result = trap(height);
    cout << result << endl;

    return 0;
}
~~~

ç¤ºä¾‹è¾“å…¥ï¼š

~~~C++
12
0 1 0 2 1 0 1 3 2 1 2 1
~~~

è¾“å‡ºï¼š

~~~C++
6
~~~





### 2ã€ç›¸å‘åŒæŒ‡é’ˆ

<img src="pic/image-20250612104513382.png" alt="image-20250612104513382" style="zoom: 50%;" />

**æ€»ç»“ï¼š**æ¥æ°´å¤šå°‘ç”±**çŸ­çš„æœ¨æ¿**å†³å®šï¼Œleft rightæŒ‡é’ˆå‘ä¸­é—´æ”¶ç¼©

æ¥æ°´çš„é«˜åº¦ç”±å‰ç¼€æœ€å¤§å€¼å’Œåç¼€æœ€å¤§å€¼ä¸­çš„**è¾ƒå°å€¼**å†³å®šï¼Œå·¦å³æŒ‡é’ˆè°å°è°ç§»åŠ¨ï¼Œç›¸é‡ä½ç½®ä¼šæ˜¯æœ€é«˜

- å¦‚æœ**å‰ç¼€æœ€å¤§å€¼ < åç¼€æœ€å¤§å€¼**ï¼Œè¿™ä¸ªæœ¨æ¡¶çš„å®¹é‡å°±æ˜¯**å‰ç¼€æœ€å¤§å€¼-height[left]**ï¼Œç®—å®Œä¹‹åleftæŒ‡é’ˆ**å‘å³**ï¼›
- å¦‚æœ**åç¼€æœ€å¤§å€¼ < å‰ç¼€æœ€å¤§å€¼**ï¼Œè¿™ä¸ªæœ¨æ¡¶çš„å®¹é‡å°±æ˜¯**åç¼€æœ€å¤§å€¼-height[right]**ï¼Œç®—å®Œä¹‹årightæŒ‡é’ˆ**å‘å·¦**

~~~C++
class Solution {
public:
    int trap(vector<int>& height) {

        // ç›¸å‘åŒæŒ‡é’ˆ
        // æ—¶é—´å¤æ‚åº¦ O(n)   ç©ºé—´å¤æ‚åº¦ O(1)
        int ans = 0;

        int left = 0, right = height.size() - 1; // å·¦å³æŒ‡é’ˆï¼Œå‘ä¸­é—´ç§»åŠ¨

        int pre_max = 0, suf_max = 0; // å‰åç¼€æœ€å¤§å€¼

        while (left < right) // å¯ä»¥ä¸åŠ ç­‰å·ï¼Œå› ä¸ºåœ¨ã€Œè°å°ç§»åŠ¨è°ã€çš„è§„åˆ™ä¸‹ï¼Œç›¸é‡çš„ä½ç½®ä¸€å®šæ˜¯æœ€é«˜çš„æŸ±å­ï¼Œè¿™ä¸ªæŸ±å­æ˜¯æ— æ³•æ¥æ°´çš„
        {
            pre_max = max(pre_max, height[left]);
            suf_max = max(suf_max, height[right]);

            // æ‰¾èƒ½ç¡®å®šçš„è¾ƒçŸ­çš„æŸ±å­
            if (pre_max < suf_max)
            {
                ans += pre_max - height[left];
                left++; 
            }
            else
            {
                ans += suf_max - height[right];
                right--;
            }
        }

        return ans;        
    }
};
~~~





# æ»‘åŠ¨çª—å£ âœ…

## 3 [æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-100-liked)

@æ»‘åŠ¨çª—å£

![image-20250616162717463](pic/image-20250616162717463.png)

![image-20250616163704232](pic/image-20250616163704232.png)

![image-20250616163714515](pic/image-20250616163714515.png)



~~~C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {

        int n = s.size();
        int ans = 0; // çª—å£é•¿åº¦ï¼Œå³æœ€é•¿ä¸é‡å¤å­ä¸²é•¿åº¦

        // çª—å£ [left, right]
        int left = 0;
        int right = 0;

        unordered_map<char, int> cnt; // cnt <å‡ºç°çš„å­—ç¬¦ï¼Œå­—ç¬¦å‡ºç°çš„æ¬¡æ•°>

        for (right = 0; right < n; right++) // right++, çª—å£å³ç§»
        { 
            char c = s[right];
            cnt[c]++; // é‡åˆ°çš„å­—ç¬¦ï¼Œæ¬¡æ•°+1

            // cnt[c] > 1 è¯´æ˜æœ‰é‡å¤å­—ç¬¦
            while (cnt[c] > 1)
            {
                cnt[s[left]]--; // å·¦è¾¹ç•Œæ”¶ç¼©ï¼Œå»é™¤ä¸€ä¸ªå·¦è¾¹ç•Œå­—ç¬¦çš„æ•°é‡
                left++; // ç¼©å°çª—å£
            }

            ans = max(ans, right - left + 1); // æ›´æ–°çª—å£é•¿åº¦æœ€å¤§å€¼
        }

        return ans;    
    }
};
~~~



ACM 

~~~C++
#include <iostream>
#include <string>
#include <unordered_map>

using namespace std;

int lengthOfLongestSubstring(const string& s)
{
    int ans = 0;

    int left = 0; 
    int right = 0;

    unordered_map<char, int> cnt; // <å­—ç¬¦ï¼Œå­—ç¬¦å‡ºç°æ¬¡æ•°>

    for (right = 0; right < s.size(); right++)
    {
        char c = s[right];
        cnt[c]++; // ç»Ÿè®¡å­—ç¬¦å‡ºç°æ¬¡æ•°

        while (cnt[c] > 1)
        {
            cnt[s[left]]--;
            left++;
        }

        ans = max(ans, right - left + 1);
    }

    return ans;
}

int main()
{
    string s;
    cin >> s; // è¾“å…¥å­—ç¬¦ä¸²

    int result = lengthOfLongestSubstring(s);
    cout << result << endl;

    return 0;
}
~~~

ç¤ºä¾‹è¾“å…¥ï¼š

~~~C++
abcabcbb
~~~

è¾“å‡ºï¼š

~~~C++
3
~~~





## 438 [æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰çš„å­—æ¯å¼‚ä½è¯](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked)

@æ»‘åŠ¨çª—å£

![image-20250617110241918](pic/image-20250617110241918.png)

![image-20250617112439541](pic/image-20250617112439541.png)



### 1ã€å®šé•¿çª—å£ï¼ˆæ¨èï¼‰

![image-20250617112250564](pic/image-20250617112250564.png)

![image-20250617112552844](pic/image-20250617112552844.png)

<img src="pic/image-20250617114503142.png" alt="image-20250617114503142" style="zoom: 33%;" />

~~~C++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) { // s = "cbaebabacd", p = "abc"

        // å®šé•¿æ»‘åŠ¨çª—å£s'  çª—å£é•¿åº¦æ˜¯p.size()

        vector<int> ans;

        vector<int> cnt_p(26); // p ä¸­çš„æ¯ä¸ªå­—æ¯å‡ºç°æ¬¡æ•°
        vector<int> cnt_s(26); // çª—å£å­ä¸² s'çš„æ¯ä¸ªå­—æ¯å‡ºç°æ¬¡æ•°

        for (char c : p)
        {
            cnt_p[c - 'a']++; // å­—æ¯å¯¹åº”ä¸‹æ ‡ä½ç½®çš„æ•°++
        }

        for (int right = 0; right < s.size(); right++) // å³è¾¹ç•Œ++
        {
            cnt_s[s[right] - 'a']++; // å³è¾¹ç•Œå­—æ¯è¿›å…¥çª—å£ s'
            int left = right - p.size() + 1;// å·¦è¾¹ç•Œ çª—å£é•¿åº¦æ˜¯p.size()

            // çª—å£é•¿åº¦ä¸å¤Ÿp.size() è·³è¿‡
            if (left < 0)   continue; 

            // s'å’Œ p çš„æ¯ç§å­—æ¯å‡ºç°æ¬¡æ•°ç›¸åŒï¼Œæ”¶é›†ç»“æœ
            if (cnt_s == cnt_p)
            {
                ans.push_back(left); // s'çš„å·¦è¾¹ç•Œä¸‹æ ‡åŠ å…¥ç»“æœ
            }

            cnt_s[s[left] - 'a']--; // æ¥ä¸‹æ¥è¿›å…¥ä¸‹ä¸€ç»„s', å·¦è¾¹ç•Œå­—æ¯ç¦»å¼€çª—å£ï¼Œæ¬¡æ•°--
        }

        return ans;  
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <string>
#include <iostream>

using namespace std;

// s = "cbaebabacd", p = "abc"
vector<int> findAnagrams(const string& s, const string& p)
{
    vector<int> ans;

    vector<int> cnt_s(26);
    vector<int> cnt_p(26);

    for (char c : p)
    {
        cnt_p[c - 'a']++;
    }

    for (int right = 0; right < s.size(); right++)
    {
        cnt_s[s[right] - 'a']++;
        int left = right - p.size() + 1;

        if(left < 0)    continue;

        if (cnt_s == cnt_p)
        {
            ans.push_back(left);
        }

        cnt_s[s[left] - 'a']--;
    }

    return ans;
}


int main()
{
    string s;
    string p;
    cin >> s >> p; // è¾“å…¥å­—ç¬¦ä¸² s p

    vector<int> result = findAnagrams(s, p);
    for (int idx : result)
    {
        cout << idx << " ";
    }
    cout << endl;
    
    return 0;
}
~~~

ç¤ºä¾‹è¾“å…¥ï¼š

~~~C++
cbaebabacd abc
~~~

è¾“å‡ºï¼š

~~~C++
0 6
~~~





### 2ã€å˜é•¿çª—å£

![image-20250617163418441](pic/image-20250617163418441.png)

![image-20250617162142140](pic/image-20250617162142140.png)

![image-20250617162148186](pic/image-20250617162148186.png)



~~~C++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) { // s = "cbaebabacd", p = "abc"

        // ä¸å®šé•¿çª—å£

        vector<int> ans;

        vector<int> cnt(26); // ç»Ÿè®¡å­—æ¯ï¼Œåˆå¹¶äº† cnt_s å’Œ cnt_p

        for (char c : p)
        {
            cnt[c - 'a']++;
        }

        int left = 0;
        for (int right = 0; right < s.size(); right++)
        {
            int c = s[right] - 'a';
            cnt[c]--; // å³ç«¯å­—ç¬¦è¿›å…¥çª—å£ï¼Œæ¶ˆå»å¯¹åº”å­—ç¬¦åœ¨cntä¸­çš„ä¸ªæ•°

            // çª—å£é‡Œcnt[c]å¯¹åº”å­—ç¬¦æ¶ˆå»å¤ªå¤šäº†ï¼Œè¶…è¿‡äº†pçš„éœ€æ±‚ï¼Œæ”¶ç¼©å·¦è¾¹ç•Œï¼Œç›´åˆ°cnt>=0
            while (cnt[c] < 0)
            {
                cnt[s[left] - 'a']++; // å·¦ç«¯ç‚¹ç¦»å¼€ï¼Œæ¬¡æ•°å†è¡¥ç»™cnt
                left++;
            }

            // å› ä¸ºå½“å‡ºç°ä¸å±äºpçš„å­—ç¬¦ï¼Œæˆ–è€…å­—ç¬¦é‡å¤æ—¶ï¼Œçª—å£å·²ç»è¢«ä¸Šé¢çš„whileå¤„ç†äº†
            // æ ¹æœ¬åˆ°ä¸äº† çª—å£é•¿åº¦ = p.size() è¿™ä¸€æ­¥

            // æ‰€ä»¥åªè¦é‡åˆ° çª—å£é•¿åº¦ = p.size()ï¼Œå°±è¯´æ˜å½“å‰çª—å£æ‰¾åˆ°äº†ç»“æœ
            if (right - left + 1 == p.size())
            {
                ans.push_back(left);
            }
        }

        return ans;
    }
};
~~~















# å­ä¸² âœ…

## [560 å’Œä¸ºkçš„å­æ•°ç»„](https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked)

@å‰ç¼€å’Œ

![image-20250617175344196](pic/image-20250617175344196.png)

**å­æ•°ç»„çš„å’Œå¯ä»¥ç”±==ä¸¤ä¸ªå‰ç¼€å’Œä¹‹å·®==è¡¨ç¤º**

<img src="pic/image-20250617231427634.png" alt="image-20250617231427634" style="zoom:50%;" />

<img src="pic/image-20250617231437509.png" alt="image-20250617231437509" style="zoom:50%;" />

<img src="pic/image-20250617231448024.png" alt="image-20250617231448024" style="zoom:50%;" />

<img src="pic/image-20250617231502464.png" alt="image-20250617231502464" style="zoom:50%;" />

![image-20250617231510992](pic/image-20250617231510992.png)

![image-20250617232228785](pic/image-20250617232228785.png)

~~~C++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {

        int n = nums.size();
        vector<int> s(n + 1); // å‰ç¼€å’Œ s[i] = nums[0] + ... + nums[i - 1]
        for (int i = 0; i < n; i++)
        {
            s[i + 1] = s[i] + nums[i];
        }

        // s[j] - s[i] = numsåŒºé—´[i, j-1]çš„å’Œ
        // é¢˜æ„æ‰¾è¿™ä¸ªåŒºé—´å’Œæ˜¯kçš„ï¼Œæœ‰å‡ ä¸ªè¿™æ ·çš„åŒºé—´
        // å°±æ˜¯æ‰¾æœ‰å‡ ä¸ª s[j] - s[i] = k ==> s[i] = s[j] - k

        int ans = 0;
        unordered_map<int, int> cnt; // <s[i], s[i]å‡ºç°æ¬¡æ•°>

        // æ³¨æ„ï¼ï¼ï¼éå†çš„æ˜¯å‰ç¼€å’Œ s
        for (int sj : s)
        {
            // å¦‚æœæœ‰ sj - k åœ¨cntå‡ºç°è¿‡ï¼Œè¯´æ˜å­˜åœ¨ si = sj - kï¼ŒæŠŠ sj - k å‡ºç°è¿‡çš„æ¬¡æ•°éƒ½åŠ åˆ°ansä¸Š
            ans += cnt.contains(sj - k) ? cnt[sj - k] : 0;
            cnt[sj]++; // cntä¸­å½“å‰sjçš„æ¬¡æ•°+1
        }
        
        return ans;
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <unordered_map>
#include <iostream>

using namespace std;

int subarraySum(const vector<int>& nums, int k)
{
    int n = nums.size();

    vector<int> s(n + 1, 0); // å‰ç¼€å’Œ
    for (int i = 0; i < n; i++)
    {
        s[i + 1] = s[i] + nums[i];
    }

    // s[j] - s[i] = k => s[i] = s[j] - k

    int ans = 0;
    unordered_map<int, int> cnt; // <s[i], s[i]å‡ºç°çš„æ¬¡æ•°>
    for (int sj : s)
    {
        if (cnt.count(sj - k))
        {
            ans += cnt[sj - k];
        }
        cnt[sj]++;
    }
    
    return ans;
}


int main() 
{
    int n, k;
    cin >> n >> k; // è¾“å…¥numsé•¿åº¦ å’Œ k

    vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i]; // è¾“å…¥nums
    }

    int result = subarraySum(nums, k);
    cout << result << endl;

    return 0;
}
~~~

ç¤ºä¾‹è¾“å…¥ï¼š

~~~C++
3 2
1 1 1
~~~

è¾“å‡ºï¼š

~~~C++
2
~~~







## [239 æ»‘åŠ¨çª—å£æœ€å¤§å€¼](https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&envId=top-100-liked)

@å•è°ƒé˜Ÿåˆ—

![image-20250620153953637](pic/image-20250620153953637.png)



<img src="pic/image-20250620160701011.png" alt="image-20250620160701011" style="zoom:80%;" />

<img src="pic/image-20250620160836709.png" alt="image-20250620160836709" style="zoom:80%;" />

<img src="pic/image-20250620160921994.png" alt="image-20250620160921994" style="zoom:80%;" />

![239.æ»‘åŠ¨çª—å£æœ€å¤§å€¼-2](pic/239.æ»‘åŠ¨çª—å£æœ€å¤§å€¼-2.gif)

![image-20250620153818438](pic/image-20250620153818438.png)

![image-20250620154103490](pic/image-20250620154103490.png)



~~~C++
class Solution {
private:
    // dequeå®ç°å•è°ƒé˜Ÿåˆ— ä»å¤§åˆ°å°
    class MyQueue
    {
    public:
        deque<int> que; // ä½¿ç”¨dequeå®ç°å•è°ƒé˜Ÿåˆ—

        // push
        void push(int value)
        {
            // å³å°†æ”¾è¿›queçš„value > backå…¥å£æ•°å€¼ï¼Œå°±å°†queåç«¯çš„æ•°å€¼å¼¹å‡ºï¼Œç›´åˆ°value < å…¥å£
            // ä¿è¯é˜Ÿåˆ—å‰é¢éƒ½æ˜¯æ¯”valueå¤§çš„å€¼ï¼Œæ‰èƒ½ä»å¤§åˆ°å°
            while (!que.empty() && value > que.back())  que.pop_back();
            que.push_back(value);
        }

        // pop
        void pop(int value)
        {
            // æ¯æ¬¡popæ¯”è¾ƒè¦å¼¹å‡ºçš„æ•°å€¼ï¼Œæ˜¯å¦ç­‰äºqueå‡ºå£çš„æ•°å€¼ï¼Œå¦‚æœç›¸ç­‰åˆ™å¼¹å‡º
            if (!que.empty() && value == que.front())   que.pop_front();
        }

        // getMaxvalue æŸ¥è¯¢å½“å‰é˜Ÿåˆ—é‡Œçš„æœ€å¤§å€¼ï¼Œç›´æ¥è¿”å›queçš„front
        int getMax()
        {
            return que.front();
        }
    };


public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {

        vector<int> result;

        MyQueue que; // åˆ›å»ºå•è°ƒé˜Ÿåˆ—
        
        // å‰kä¸ªå…ƒç´ ï¼ˆç¬¬ä¸€ä¸ªçª—å£ï¼‰æ”¾å…¥que
        for (int i = 0; i < k; i++)
        {
            que.push(nums[i]); // pushçš„æ—¶å€™å·²ç»ä¿è¯äº†å•è°ƒ
        }
        result.push_back(que.getMax()); // result è®°å½•ç¬¬ä¸€ä¸ªçª—å£æœ€å¤§å€¼

        // ç»§ç»­è®¡ç®—åé¢çš„çª—å£
        for (int i = k; i < nums.size(); i++)
        {
            que.pop(nums[i - k]); // ç§»åŠ¨çª—å£ï¼Œpopå‡ºqueä¸­å½“å‰çª—å£çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
            que.push(nums[i]); // æ–°å…ƒç´ pushè¿›æ–°çª—å£

            result.push_back(que.getMax()); // è®°å½•å½“å‰çª—å£å†…çš„æœ€å¤§å€¼
        }
        
        return result;
        
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <deque>
#include <vector>

using namespace std;

// å•è°ƒé˜Ÿåˆ—ç±»
class MyQueue
{
public:
    deque<int> que;
    
    // push ä¿è¯ä»å¤§åˆ°å°
    void push(int value)
    {
        while (!que.empty() && value > que.back()) // å¦‚æœvalue > que.back() å°±å¼¹å‡ºåŸæ¥è¾ƒå°çš„back
        {
            que.pop_back();
        }
        que.push_back(value); // æ–°å€¼æ”¾è¿›å»ï¼Œé˜Ÿåˆ—å‰é¢æ˜¯æ¯”valueå¤§çš„å€¼ï¼Œæ‰èƒ½ä»å¤§åˆ°å°
    }

    // pop çª—å£æ»‘å‡ºå…ƒç´ ä¸é˜Ÿå¤´ç›¸ç­‰æ—¶å¼¹å‡º
    void pop(int value)
    {
        if (!que.empty() && value == que.front())
        {
            que.pop_front();
        }
    }

    // getMax è¿”å›å½“å‰çª—å£çš„æœ€å¤§å€¼ï¼ˆå°±æ˜¯é˜Ÿåˆ—çš„frontï¼‰
    int getMax()
    {
        return que.front();
    }

};

// è¿”å›æ»‘åŠ¨çª—å£ä¸­çš„æœ€å¤§å€¼
vector<int> maxSlidingWindow(const vector<int>& nums, int k)
{
    vector<int> result;
    MyQueue que;

    // åˆå§‹åŒ–å‰kä¸ªå…ƒç´ ï¼ˆç¬¬ä¸€ä¸ªçª—å£ï¼‰
    for (int i = 0; i < k; i++)
    {
        que.push(nums[i]);
    }
    result.push_back(que.getMax());

    // å¼€å§‹æ»‘åŠ¨çª—å£
    for (int i = k; i < nums.size(); i++)
    {
        que.pop(nums[i - k]);
        que.push(nums[i]);
        result.push_back(que.getMax());
    }

    return result;
}

int main()
{
    int n, k;
    cin >> n >> k; // è¾“å…¥numså…ƒç´ ä¸ªæ•°ï¼Œå’Œçª—å£å¤§å°k

    vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i]; // è¾“å…¥numså…ƒç´ 
    }

    vector<int> ans = maxSlidingWindow(nums, k);
    for (int x : ans)
    {
        cout << x << " ";
    }
    cout << endl;

    return 0;
}
~~~

ç¤ºä¾‹è¾“å…¥ï¼š

~~~C++
8 3 
1 3 -1 -3 5 3 6 7
~~~

è¾“å‡ºï¼š

~~~C++
3 3 5 5 6 7 
~~~





## 76 [æœ€å°è¦†ç›–å­ä¸²](https://leetcode.cn/problems/minimum-window-substring/?envType=study-plan-v2&envId=top-100-liked)

@æ»‘åŠ¨çª—å£

![image-20250621115145749](pic/image-20250621115145749.png)		

![image-20250621115156244](pic/image-20250621115156244.png)

![image-20250622103406601](pic/image-20250622103406601.png)

![image-20250621115208025](pic/image-20250621115208025.png)

![image-20250621115228527](pic/image-20250621115228527.png)



~~~C++
class Solution {
public:
    // åˆ¤æ–­å­ä¸²æ˜¯å¦è¦†ç›–ï¼ˆå­—æ¯å‡ºç°æ¬¡æ•°ï¼‰
    bool is_covered(int cnt_s[], int cnt_t[]) 
    {
        for (int i = 'A'; i <= 'Z'; i++)
        {
            if (cnt_s[i] < cnt_t[i])
            {
                return false;
            }
        }

        for (int i = 'a'; i <= 'z'; i++)
        {
            if (cnt_s[i] < cnt_t[i])
            {
                return false;
            }
        }
        
        return true;
    }

    string minWindow(string s, string t) {
        
        int m = s.length();

        int ans_left = -1, ans_right = m; // æœ€çŸ­å­ä¸²çš„å·¦å³ç«¯ç‚¹

        int cnt_s[128]{}; // s å­ä¸²å­—æ¯çš„å‡ºç°æ¬¡æ•°
        int cnt_t[128]{}; // t ä¸­å­—æ¯çš„å‡ºç°æ¬¡æ•°
        for (char c : t)
        {
            cnt_t[c]++;
        }

        // éå† s
        int left = 0;
        for (int right = 0; right < m; right++)
        {
            cnt_s[s[right]]++; // å³ç«¯ç‚¹å­—æ¯ç§»å…¥å­ä¸²
            
            while (is_covered(cnt_s, cnt_t)) // så­ä¸²æ¶µç›–t
            {
                if (right - left < ans_right - ans_left) // å½“å‰å­ä¸²æ›´çŸ­ï¼Œæ›´æ–°ç«¯ç‚¹
                {
                    ans_left = left;
                    ans_right = right; 
                }

                cnt_s[s[left]]--; // å·¦ç«¯ç‚¹å­—æ¯ç§»å‡ºå­ä¸²
                left++;
            }
        }

        // è¿”å›å­ä¸²
        return ans_left < 0 ? "" : s.substr(ans_left, ans_right - ans_left + 1);
        
    }
};
~~~



ACM

~~~C++
#include <string>
#include <iostream>

using namespace std;

// åˆ¤æ–­å­ä¸²æ˜¯å¦è¦†ç›– t ä¸­æ‰€æœ‰å­—ç¬¦
bool is_covered(int cnt_s[], int cnt_t[])
{
    for (int i = 'A'; i <= 'Z'; i++) 
    {
        if (cnt_s[i] < cnt_t[i]) return false;
    }

    for (int i = 'a'; i <= 'z'; i++) 
    {
        if (cnt_s[i] < cnt_t[i]) return false;
    }

    return true;
}

// æ±‚æœ€å°è¦†ç›–å­ä¸²
string minWindow(const string& s, const string& t)
{
    int m = s.length();

    int ans_left = -1, ans_right = m;

    int cnt_s[128] = {0};
    int cnt_t[128] = {0};
    for (char c : t)
    {
        cnt_t[c]++;
    }

    // éå† s
    int left = 0;
    for (int right = 0; right < m; right++)
    {
        cnt_s[s[right]]++;

        // å¦‚æœç¬¦åˆè¦†ç›–ï¼Œæ›´æ–°æœ€çŸ­å­ä¸²ç«¯ç‚¹ï¼Œå·¦ç§»left
        while (is_covered(cnt_s, cnt_t))
        {
            if (right - left < ans_right - ans_left)
            {
                ans_left = left;
                ans_right = right;
            }

            cnt_s[s[left]]--;
            left++;
        }
    }

    return (ans_left < 0) ? "" : s.substr(ans_left, ans_right - ans_left + 1);
}


int main()
{
    string s, t;
    cin >> s >> t;

    string result = minWindow(s, t);
    cout << result << endl;

    return 0;
}
~~~

ç¤ºä¾‹è¾“å…¥ï¼š

~~~C++
ADOBECODEBANC ABC
~~~

è¾“å‡ºï¼š

~~~C++
BANC
~~~



# æ™®é€šæ•°ç»„ âœ…



## 53 [æœ€å¤§å­æ•°ç»„å’Œ](https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked)

@åŠ¨æ€è§„åˆ’ @è´ªå¿ƒ

![image-20250622105708128](pic/image-20250622105708128.png)



### è´ªå¿ƒ

<img src="pic/image-20250622110414358.png" alt="image-20250622110414358" style="zoom:50%;" />

![53.æœ€å¤§å­åºå’Œ](pic/53.æœ€å¤§å­åºå’Œ.gif)

~~~C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {

        // è´ªå¿ƒ

        // æ³¨æ„æ‰¾çš„åªæ˜¯ ã€æœ€å¤§å’Œã€‘ï¼Œæ²¡è®©æ‰¾å­æ•°ç»„

        // ä¸»è¦æ€è·¯ï¼šè´Ÿæ•°åªä¼šæ‹–ç´¯åŠ å’Œï¼Œæ‰€ä»¥é‡åˆ°å’Œå˜æˆè´Ÿçš„ï¼Œèˆå¼ƒï¼Œè´Ÿçš„åªä¼šå‡å°åé¢çš„åŠ å’Œ
        
        int result = INT32_MIN;
        int count = 0;

        // è®°å½•è¿ç»­å’Œcountï¼Œå¦‚æœcount < 0ï¼Œèˆå¼ƒï¼Œå†ä»ä¸‹ä¸€ä¸ªæ•°å¼€å§‹è®¡å’Œ
        for (int i = 0; i < nums.size(); i++)
        {
            count += nums[i];
            result = max(count, result); // æ›´æ–°resultï¼Œå–å¤§çš„count
            
            if (count <= 0)	count = 0; // èˆå¼ƒï¼Œä»ä¸‹ä¸€ä¸ªæ•°nums[i + 1]é‡æ–°åŠ å’Œ
        }

        return result;
    }
};
~~~



### åŠ¨æ€è§„åˆ’

![image-20250622110929679](pic/image-20250622110929679.png)

<img src="pic/20210303104129101.png" alt="53.æœ€å¤§å­åºå’Œï¼ˆåŠ¨æ€è§„åˆ’ï¼‰" style="zoom:50%;" />



~~~C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        
        if (nums.size() == 0)   return 0;
        
        // åŠ¨æ€è§„åˆ’

        // dp[i] - ä»¥nums[i]ç»“å°¾(åŒ…æ‹¬)çš„æœ€å¤§è¿ç»­å­åºåˆ—å’Œä¸ºdp[i]
        vector<int> dp(nums.size());

        // åˆå§‹åŒ–
        dp[0] = nums[0];

        int result = dp[0];

        // é€’æ¨
        for (int i = 1; i < nums.size(); i++)
        {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]);// ä¸¤ç§æ¨å‡ºdp[i]çš„æ–¹å¼ï¼Œå–max

            if (dp[i] > result) result = dp[i]; // å–dp[i]çš„æœ€å¤§å€¼è¿”å›
        }

        return result;  
    }
};
~~~





ACM

~~~C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdint>

using namespace std;

// åŠ›æ‰£53 æœ€å¤§å­æ•°ç»„å’Œ

/**************  åŠ¨æ€è§„åˆ’ *****************/ 
// int maxSubArray(const vector<int>& nums)
// {
//     if (nums.size() == 0)   return 0;

//     // åŠ¨æ€è§„åˆ’
//     vector<int> dp(nums.size()); // ä»¥nums[i]ç»“å°¾(åŒ…æ‹¬)çš„æœ€å¤§è¿ç»­å­åºåˆ—å’Œä¸ºdp[i]
//     dp[0] = nums[0];

//     int result = dp[0];

//     for (int i = 1; i < nums.size(); i++)
//     {
//         dp[i] = max(dp[i - 1] + nums[i], nums[i]);
//         result = max(result, dp[i]);
//     }

//     return result;
// }


/**************  è´ªå¿ƒ *****************/ 
int maxSubArray(const vector<int>& nums)
{
    int result = INT32_MIN;
    int count = 0;

    // è®°å½•è¿ç»­å’Œcountï¼Œå¦‚æœcount < 0ï¼Œèˆå¼ƒï¼Œå†ä»ä¸‹ä¸€ä¸ªæ•°å¼€å§‹è®¡å’Œ (è´Ÿçš„åªä¼šå‡å°åé¢çš„åŠ å’Œ)
    for (int i = 0; i < nums.size(); i++)
    {
        count += nums[i];
        if (result < count) result = count;
        if (count <= 0)  count = 0; // èˆå¼ƒï¼Œä»ä¸‹ä¸€ä¸ªæ•°nums[i + 1]é‡æ–°åŠ å’Œ
    }

    return result;
}


int main()
{
    int n;
    cin >> n; // è¾“å…¥æ•°ç»„å…ƒç´ ä¸ªæ•°

    vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i]; // è¾“å…¥æ•°ç»„
    }

    int result = maxSubArray(nums);
    cout << result << endl;

    return 0;
}

~~~

ç¤ºä¾‹è¾“å…¥ï¼š

~~~shell
9
-2 1 -3 4 -1 2 1 -5 4
~~~

è¾“å‡ºï¼š

~~~shell
6 #å¯¹åº” [4, -1, 2, 1]
~~~





## 56 [åˆå¹¶åŒºé—´](https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked)

@è´ªå¿ƒ

![image-20250623104644609](pic/image-20250623104644609.png)

<img src="pic/image-20250623104950499.png" alt="image-20250623104950499" style="zoom: 50%;" />



<img src="pic/image-20250623105338164.png" alt="image-20250623105338164" style="zoom:40%;" />



<img src="pic/image-20250623105441129.png" alt="image-20250623105441129" style="zoom:50%;" />

~~~C++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {

        if (intervals.size() == 0)  return intervals;

        // å…ˆæŒ‰å·¦è¾¹ç•Œæ’åºï¼Œä»å°åˆ°å¤§ (lambda)
        sort(intervals.begin(), intervals.end(),
                [](const vector<int>& a, const vector<int>& b) {return a[0] < b[0];} );

        vector<vector<int>> result;
        result.push_back(intervals[0]); // ç¬¬ä¸€ä¸ªåŒºé—´æ”¾è¿›result
        for (int i = 1; i < intervals.size(); i++)
        {
            // æœ‰é‡å ï¼Œæ›´æ–°å‰ä¸€ä¸ªèŒƒå›´çš„å³è¾¹ç•Œ 
            if (intervals[i][0] <= result.back()[1]) // éœ€è¦<=ï¼Œè¾¹ç•Œé‡å ä¹Ÿç®—
            {
                // æ›´æ–°å³è¾¹ç•Œï¼Œè¦æ¯”è¾ƒå–è¾ƒå¤§å€¼ï¼Œä¸èƒ½ç›´æ¥å–æ–°çš„intervals[i][1]
                result.back()[1] = max(result.back()[1], intervals[i][1]); 
            }
            // æ— é‡å ï¼Œç›´æ¥æ”¾è¿›result
            else 
            {
                result.push_back(intervals[i]);
            }
        }

        return result;  
    }
};
~~~



lambdaè¡¨è¾¾å¼ï¼š

~~~C++
  // å…ˆæŒ‰å·¦è¾¹ç•Œæ’åºï¼Œä»å°åˆ°å¤§ (lambda)
  sort(intervals.begin(), intervals.end(),
          [](const vector<int>& a, const vector<int>& b) {return a[0] < b[0];});
~~~

å¦‚æœç”¨ä»¿å‡½æ•°ï¼š

~~~C++
class Solution {
public:
    // ä»¿å‡½æ•°
    static bool cmp (const vector<int>& a, const vector<int>& b)
    {
        return a[0] < b[0];
    }

    vector<vector<int>> merge(vector<vector<int>>& intervals) {

        if (intervals.size() == 0)  return intervals;

        // å…ˆæŒ‰å·¦è¾¹ç•Œæ’åºï¼Œä»å°åˆ°å¤§ (lambda)
        sort(intervals.begin(), intervals.end(), cmp); // æ›¿æ¢æˆ cmp
		
        // ...
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<vector<int>> merge(vector<vector<int>>& intervals)
{
    if (intervals.size() == 0)  return intervals;

    // æŒ‰å·¦è¾¹ç•Œæ’åº ä»å°åˆ°å¤§
    sort(intervals.begin(), intervals.end(),
        [](const vector<int>& a, const vector<int>& b) {return a[0] < b[0];} );

    vector<vector<int>> result;
    result.push_back(intervals[0]);
    for (int i = 1; i < intervals.size(); i++)
    {
        if (result.back()[1] >= intervals[i][0]) // æœ‰é‡å ï¼Œæ›´æ–°å³è¾¹ç•Œ
        {
            result.back()[1] = max(result.back()[1], intervals[i][1]);
        }
        else // æ— é‡å ï¼Œç›´æ¥æ”¾è¿›result
        {
            result.push_back(intervals[i]);
        }
    }

    return result;
}


int main()
{
    int n;
    cin >> n; // intervalsæ•°ç»„å…ƒç´ ä¸ªæ•° (åŒºé—´ä¸ªæ•°)

    vector<vector<int>> intervals(n, vector<int>(2));
    for (int i = 0; i < n; i++)
    {
        cin >> intervals[i][0] >> intervals[i][1];// è¾“å…¥æ¯ä¸ªåŒºé—´å·¦å³ç«¯ç‚¹
    }

    vector<vector<int>> result = merge(intervals);
    for (const auto& interval : result)
    {
        cout << interval[0] << " " << interval[1] << endl;
    }

    return 0;
}
~~~

ç¤ºä¾‹è¾“å…¥ï¼š

~~~C++
4
1 3
2 6
8 10
15 18
~~~

è¾“å‡ºï¼š

~~~C++
1 6
8 10
15 18
~~~









## [189 è½®è½¬æ•°ç»„](https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250623163553318](pic/image-20250623163553318.png)

~~~C++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        // [1,2,3,4,5,6,7] k = 3

        k = k % nums.size(); // å¦‚æœ k è¶…è¿‡nums.size()çš„è¯

        reverse(nums.begin(), nums.end());      // æ•´ä½“åè½¬      [7,6,5,4,3,2,1]
        reverse(nums.begin(), nums.begin() + k);// åè½¬å‰kä¸ª     [5,6,7,4,3,2,1]
        reverse(nums.begin() + k, nums.end());  // åè½¬k+1åˆ°æœ€å [5,6,7,1,2,3,4]
        
    }
};
~~~

![image-20250623163609915](pic/image-20250623163609915.png)



ACM

~~~c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;


// è½®è½¬æ•°ç»„å‡½æ•°
void rotate(vector<int>& nums, int k)
{
    if (nums.size() == 0)   return;

    k = k % nums.size();

    // ä¸‰æ¬¡åè½¬
    reverse(nums.begin(), nums.end());
    reverse(nums.begin(), nums.begin() + k);
    reverse(nums.begin() + k, nums.end());
}


int main()
{
    int n, k;
    cin >> n >> k; // è¾“å…¥æ•°ç»„é•¿åº¦ å’Œè½®è½¬æ­¥æ•°k

    vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i]; // è¾“å…¥æ•°ç»„å…ƒç´ 
    }

    rotate(nums, k);

    for (int x : nums)
    {
        cout << x << " ";
    }
    cout << endl;

    return 0;
}
~~~

ç¤ºä¾‹è¾“å…¥ï¼š

~~~c++
7 3
1 2 3 4 5 6 7
~~~

è¾“å‡ºï¼š
~~~
5 6 7 1 2 3 4
~~~



## [238 é™¤è‡ªèº«ä»¥å¤–æ•°ç»„çš„ä¹˜ç§¯](https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked)

@å‰ç¼€@åç¼€ä¹˜ç§¯

![image-20250624105932275](pic/image-20250624105932275.png)

![image-20250624110050465](pic/image-20250624110050465.png)

~~~C++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {

        // nums[i]å‰çš„ä¹˜ç§¯ * nums[i]åçš„ä¹˜ç§¯

        int n = nums.size();

        // nums[i]å‰çš„ä¹˜ç§¯  nums[0]*nums[1]*...*nums[i-1]
        vector<int> pre(n, 1);
        for (int i = 1; i < n; i++)
        {
            pre[i] = pre[i - 1] * nums[i - 1];
        }

        // nums[i]åçš„ä¹˜ç§¯ nums[i+1]*nums[i+2]*...*nums[n-1]
        vector<int> suf(n, 1);
        for (int i = n - 2; i >= 0; i--)
        {
            suf[i] = suf[i + 1] * nums[i + 1]; // ä»åå‘å‰ä¹˜
        }

        vector<int> ans(n);
        for (int i = 0; i < n; i++)
        {
            ans[i] = pre[i] * suf[i];
        }

        return ans;
    }
};
~~~



![image-20250624110818200](pic/image-20250624110818200.png)

~~~C++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {

        // nums[i]å‰çš„ä¹˜ç§¯ * nums[i]åçš„ä¹˜ç§¯

        // ä¼˜åŒ–

        int n = nums.size();

        vector<int> suf(n);
        suf[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--)
        {
            suf[i] = suf[i + 1] * nums[i + 1];
        }

        int pre = 1;
        for (int i = 0; i < n; i++)
        {
            // æ­¤æ—¶ pre ä¸º nums[0] åˆ° nums[i-1] çš„ä¹˜ç§¯ï¼Œç›´æ¥ä¹˜åˆ° suf[i] ä¸­
            suf[i] *= pre;
            pre *= nums[i];
        }

        return suf; // sufå·²ç»ä¹˜ä¸Šäº†preï¼Œå°±æ˜¯ans
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <vector>

using namespace std;


vector<int> productExceptSelf(const vector<int>& nums)
{
    int n = nums.size();

    // nums[i]å‰çš„ä¹˜ç§¯ * nums[i]åçš„ä¹˜ç§¯

    // pre[i] = nums[0]*nums[1]*...*nums[i-1]
    vector<int> pre(n, 1);
    for (int i = 1; i < n; i++)
    {
        pre[i] = pre[i - 1] * nums[i - 1];
    }

    // suf[i] = nums[i+1]*nums[i+2]*...*nums[n-1]
    vector<int> suf(n, 1);
    for (int i = n - 2; i >= 0; i--)
    {
        suf[i]  = suf[i + 1] * nums[i + 1]; // ä»åå‘å‰ä¹˜
    }

    vector<int> ans(n);
    for (int i = 0; i < n; i++)
    {
        ans[i] = pre[i] * suf[i];
    }

    return ans;
}


int main()
{
    int n;
    cin >> n;// numså…ƒç´ ä¸ªæ•°

    vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i];// è¾“å…¥æ•°ç»„
    }

    vector<int> result = productExceptSelf(nums);
    for (int x : result)
    {
        cout << x << " ";
    }
    cout << endl;

    return 0;
}
~~~

ç¤ºä¾‹è¾“å…¥ï¼š

~~~C++
4
1 2 3 4
~~~

è¾“å‡ºï¼š

~~~C++
24 12 8 6
~~~



## [41 ç¼ºå¤±çš„ç¬¬ä¸€ä¸ªæ­£æ•°](https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&envId=top-100-liked)

@å“ˆå¸Œ

![image-20250625101823232](pic/image-20250625101823232.png)



https://leetcode.cn/problems/first-missing-positive/solutions/7703/tong-pai-xu-python-dai-ma-by-liweiwei1419

æœ¬é¢˜çš„éš¾ç‚¹åœ¨ï¼šåªèƒ½ä½¿ç”¨å¸¸æ•°çº§åˆ«çš„é¢å¤–ç©ºé—´ï¼Œåœ¨è¿™ä¸ªé™åˆ¶ä¸‹æœ¬é¢˜çš„æ€è·¯æœ‰ä¸€ä¸ªéæ­£å¼çš„åç§°ï¼š**åŸåœ°å“ˆå¸Œ**ã€‚

![image-20250625102204090](pic/image-20250625102204090.png)

![image-20250625102219196](pic/image-20250625102219196.png)

![image-20250625110120087](pic/image-20250625110120087.png)

![image-20250625102516136](pic/image-20250625102516136.png)



![image-20250625110017460](pic/image-20250625110017460.png)

~~~C++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {

        // å¦‚æœä¸ç¼ºå¤±æ­£æ•°ï¼šä¸‹æ ‡içš„ä½ç½®ï¼Œæ”¾çš„åº”è¯¥æ˜¯i+1ï¼Œå³nums[i] = i + 1
        // nums = [1, 2, 3, 4, ...]
        // ä¸‹æ ‡    0  1  2  3 ...

        // å½“ä¸‹æ ‡ i ä½ç½®çš„æ•°ï¼Œä¸æ˜¯ i+1 æ—¶(nums[i] != i + 1)ï¼Œi+1 å°±æ˜¯ç¼ºå¤±çš„æœ€å°æ­£æ•°

        // æ³¨æ„æ˜¯æŠŠæ•°æ”¾åˆ°æ­£ç¡®ä½ç½®ï¼Œæ•°æ‰¾ä½ç½®ï¼Œè€Œä¸æ˜¯ä½ç½®æ‰¾æ•°ï¼ï¼ï¼


        // éå†numsï¼Œç»™æ¯ä¸ªnums[i]æ‰¾æ­£ç¡®çš„ä½ç½®
        for (int i = 0; i < nums.size(); i++)
        {
            // ç»™nums[i]æ‰¾ä½ç½®ï¼Œäº¤æ¢åçš„nums[i]å¯èƒ½ä½ç½®ä¹Ÿä¸å¯¹ï¼Œæ‰€ä»¥whileç›´åˆ°ä½ç½®æ­£ç¡®
            while (nums[i] != i + 1)
            {
                if (nums[i] <= 0 ||               // è´Ÿæ•°æˆ–0
                    nums[i] > nums.size() ||      // è¶…è¿‡æ•°ç»„é•¿åº¦çš„æ•°
                    nums[i] == nums[nums[i] - 1]) // nums[i]é‡å¤ï¼Œnums[i]è¯¥åœ¨çš„ä½ç½®å·²ç»æœ‰æ­£ç¡®çš„æ•°äº†
                {
                    break; // è¿™ä¸‰ç§æƒ…å†µä¸ç§»åŠ¨
                }

                // å°†nums[i]æ”¾åˆ°å¯¹åº”ä½ç½®ï¼ˆå³äº¤æ¢ nums[i] ä¸ nums[nums[i] - 1]ï¼‰
                int idx = nums[i] - 1;
                swap(nums[i], nums[idx]); 
            }
        }


        // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªä¸æ»¡è¶³ nums[i] == i + 1 çš„ä½ç½®
        for (int i = 0; i < nums.size(); i++)
        {
            if (nums[i] != i + 1)   return i + 1;
        }

        // å¦‚æœæ‰€æœ‰éƒ½ç›¸ç¬¦ï¼Œç¼ºå°‘çš„å°±æ˜¯æœ€åä¸€ä¸ªæ•°çš„ä¸‹ä¸€ä¸ª [1, 2, 3, 4, ..., n-1]  n = nums.size()
        return (nums.size() + 1);
        
    }
};
~~~





ACM

~~~C++
#include <iostream>
#include <vector>

using namespace std;


int firstMissingPositive(vector<int>& nums)
{
    int n = nums.size();

    // æŠŠæ¯ä¸ªæ•°æ”¾åˆ°æ­£ç¡®çš„ä½ç½®ä¸Šï¼ˆå³ nums[i] åº”è¯¥åœ¨ ä¸‹æ ‡ä¸ºnums[i] - 1 ä½ç½®ä¸Šï¼‰
    for (int i = 0; i < n; i++)
    {
        while (nums[i] != i + 1)
        {
            if (nums[i] < 0 || nums[i] > n || nums[i] == nums[nums[i] - 1]) 
            {
                break; // éæ³•æ•°å­—æˆ–é‡å¤ï¼Œä¸å¤„ç†
            }

            // æŠŠnums[i]äº¤æ¢åˆ°æ­£ç¡®ä½ç½®
            int idx = nums[i] - 1;
            swap(nums[i], nums[idx]);
        }
    }

    // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªä¸æ»¡è¶³ nums[i] == i + 1 çš„ä½ç½®
    for (int i = 0; i < n; i++)
    {
        if (nums[i] != i + 1)   return i + 1;
    }

    // æ‰€æœ‰éƒ½æ»¡è¶³ï¼Œè¿”å› n + 1
    return n + 1;
}

int main()
{
    int n;
    cin >> n; // è¾“å…¥numså…ƒç´ ä¸ªæ•°

    vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i]; // è¾“å…¥æ•°ç»„
    }

    int result = firstMissingPositive(nums);
    cout << result << endl;

}
~~~

ç¤ºä¾‹è¾“å…¥ï¼š

~~~C++
5
3 4 -1 1 2
~~~

è¾“å‡ºï¼š

~~~C++
5
~~~



# çŸ©é˜µ âœ…



## [73 çŸ©é˜µç½®é›¶](https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250626113039919](pic/image-20250626113039919.png)

![image-20250626162610999](pic/image-20250626162610999.png)

![image-20250626162624915](pic/image-20250626162624915.png)

![image-20250626162915024](pic/image-20250626162915024.png)

~~~C++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {

        if (matrix.size() == 0) return;

        const int m = matrix.size();    // æœ‰å‡ è¡Œ
        const int n = matrix[0].size(); // æœ‰å‡ åˆ—

        bool firstRow = false; // è®°å½•ç¬¬ä¸€è¡Œæ˜¯å¦æœ‰0
        bool firstCol = false; // è®°å½•ç¬¬ä¸€åˆ—æ˜¯å¦æœ‰0

        // éå†æ‰€æœ‰å…ƒç´ ï¼Œå°† 0 æ‰€åœ¨è¡Œåˆ—çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼ˆå³ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—çš„å…ƒç´ ç½®é›¶ï¼‰
        for (int i = 0; i < m; i++) // è¡Œ
        {
            for (int j = 0; j < n; j++)
            {
                const int item = matrix[i][j];
                if (item == 0) 
                {
                    if (i == 0) firstRow = true; // å¦‚æœæ˜¯ç¬¬ä¸€è¡Œçš„å…ƒç´ æ˜¯0ï¼Œè®°å½•
                    if (j == 0) firstCol = true; // å¦‚æœæ˜¯ç¬¬ä¸€åˆ—çš„å…ƒç´ æ˜¯0ï¼Œè®°å½•

                    // å°†å¯¹åº”ç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—çš„å…ƒç´ ç½®é›¶ï¼Œä½œä¸ºä¿®æ”¹å…¶ä»–è¡Œåˆ—çš„æ ‡å¿—
                    matrix[0][j] = 0;
                    matrix[i][0] = 0;
                }
            }
        }

        // å†æ ¹æ®ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—çš„æ•°ï¼Œç½®é›¶å…¶ä»–è¡Œåˆ—çš„å…ƒç´ 
        for (int i = 1; i < m; i++)
        {
            for (int j = 1; j < n; j++)
            {
                const int item = matrix[i][j];
                // å¦‚æœå½“å‰å…ƒç´ æ‰€åœ¨è¡Œåˆ—çš„ç¬¬ä¸€è¡Œæˆ–ç¬¬ä¸€åˆ—ä¸­æœ‰0ï¼Œåˆ™ç½®é›¶å½“å‰å…ƒç´ 
                if (matrix[0][j] == 0 || matrix[i][0] == 0)
                {
                    matrix[i][j] = 0;
                }
            }
        }

        
        // æœ€åä¿®æ”¹ç¬¬ä¸€è¡Œ ç¬¬ä¸€åˆ—ï¼ˆå¦‚æœç¬¬ä¸€è¡Œæˆ–ç¬¬ä¸€åˆ—ä¸­æœ‰0ï¼‰
        if (firstRow) 
        {
            for (int j = 0; j < n; j++)
            {
                matrix[0][j] = 0; // ç¬¬ä¸€è¡Œå…¨éƒ¨ç½®é›¶
            }
        }
        if (firstCol)
        {
            for (int i = 0; i < m; i++)
            {
                matrix[i][0] = 0; // ç¬¬ä¸€åˆ—å…¨éƒ¨ç½®é›¶
            }
        }

    }
};
~~~



ACM 

~~~C++
#include <vector>
#include <iostream>

using namespace std;


// åŸåœ°å°†çŸ©é˜µä¸­åŒ…å«0çš„è¡Œåˆ—å…¨ç½®0
void setZeroes(vector<vector<int>>& matrix)
{
    if (matrix.size() == 0) return;

    const int m = matrix.size();    // è¡Œæ•°
    const int n = matrix[0].size(); // åˆ—æ•°

    bool firstRow = false; // ç¬¬ä¸€è¡Œæ˜¯å¦åŒ…å«0
    bool firstCol = false; // ç¬¬ä¸€åˆ—æ˜¯å¦åŒ…å«0

    // æ ‡è®°è¡Œåˆ—
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (matrix[i][j] == 0)
            {
                if (i == 0) firstRow = true; // ç¬¬ä¸€è¡Œçš„å…ƒç´ 
                if (j == 0) firstCol = true; // ç¬¬ä¸€åˆ—çš„å…ƒç´ 
                matrix[0][j] = 0; // æ ‡è®°åˆ—
                matrix[i][0] = 0; // æ ‡è®°è¡Œ
            }
        }
    }

     // éå†éé¦–è¡Œé¦–åˆ—ï¼Œä½¿ç”¨é¦–è¡Œé¦–åˆ—çš„0æ ‡è®°æ¸…é›¶
     for (int i = 1; i < m; i++)
     {
        for (int j = 1; j < n; j++)
        {
            if (matrix[0][j] == 0 || matrix[i][0] == 0)     matrix[i][j] = 0;
        }
     }

     // æ ¹æ® firstRow firstCol å¤„ç†ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—
     if (firstRow)
     {
        for (int j = 0; j < n; j++)
        {
            matrix[0][j] = 0;
        }
     }
     if (firstCol)
     {
        for (int i = 0; i < m; i++)
        {
            matrix[i][0] = 0;
        }
     }

}



int main()
{
    int m, n;
    cin >> m >> n; // è¾“å…¥è¡Œåˆ—æ•°

    vector<vector<int>> matrix(m, vector<int>(n));
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            cin >> matrix[i][j]; // è¾“å…¥çŸ©é˜µ
        }
    }

    cout << endl;
    
    setZeroes(matrix);
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            cout << matrix[i][j] << " "; // è¾“å‡ºç»“æœ
        }
        cout << endl;
    }

    return 0;
}
~~~



ç¤ºä¾‹è¾“å…¥ï¼š

~~~C++
3 4
1 1 1 0
1 0 1 1
1 1 1 1
~~~

è¾“å‡º

~~~C++
0 0 0 0
0 0 0 0
1 0 1 0
~~~





## [èºæ—‹çŸ©é˜µ](https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250627114210513](pic/image-20250627114210513.png)



### 1ã€æ ‡è®° + æ–¹å‘æ•°ç»„

![image-20250627114220015](pic/image-20250627114220015.png)

![image-20250627114225565](pic/image-20250627114225565.png)

![image-20250627114235868](pic/image-20250627114235868.png)

~~~C++
class Solution {
	// æ–¹å‘æ•°ç»„ï¼Œæ³¨æ„é¡ºåºï¼ï¼ï¼ï¼
    static constexpr int DIRS[4][2] = {
        {0, 1},   // å‘å³
        {1, 0},   // å‘ä¸‹
        {0, -1},  // å‘å·¦
        {-1, 0}   // å‘ä¸Š
	};

public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size();    // è¡Œæ•°
        int n = matrix[0].size(); // åˆ—æ•°

        vector<int> ans(m * n);

        int i = 0, j = 0, di = 0; // åˆå§‹è¡Œå·ï¼Œåˆ—å·ï¼Œå‰è¿›æ–¹å‘
        for (int k = 0 ; k < m * n; k++) // ä¸€å…±èµ°m*næ­¥ï¼Œæ”¶é›†m*nä¸ªæ•°æ®ä¸ºæ­¢
        {
            ans[k] = matrix[i][j];  // æ”¶é›†
            matrix[i][j] = INT_MAX; // æ ‡è®°ï¼Œè¡¨ç¤ºå·²ç»è®¿é—®è¿‡ï¼ŒåŠ å…¥åˆ°ansé‡Œ

            // (x, y) æ˜¯ä¸‹ä¸€æ­¥çš„ä½ç½®ï¼Œå‰è¿›æ–¹å‘æ˜¯ DIRS[i]
            int x = i + DIRS[di][0]; // ç§»åŠ¨ï¼Œè¡Œå· + DIRS[di][0]
            int y = j + DIRS[di][1]; // ç§»åŠ¨ï¼Œåˆ—å· + DIRS[di][1]

            // å…ˆåˆ¤æ–­ (x, y) æ˜¯å¦å‡ºç•Œæˆ–è€…å·²ç»è®¿é—®è¿‡
            if (x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] == INT_MAX)
            {
                di = (di + 1) % 4; // å³è½¬90åº¦
            }

            // ç¡®å®šä¸‹ä¸€ä¸ªä½ç½®
            i += DIRS[di][0]; 
            j += DIRS[di][1];
        }

        return ans;       
    }
};
~~~



`constexpr`æ˜¯ C++11 å¼•å…¥çš„ä¸€ä¸ªå…³é”®å­—ï¼Œç”¨æ¥å£°æ˜â€œå¸¸é‡è¡¨è¾¾å¼â€ã€‚å®ƒçš„æ ¸å¿ƒä½œç”¨æ˜¯ï¼š**åœ¨ç¼–è¯‘æœŸå°±èƒ½ç¡®å®šç»“æœ**ã€‚



### 2ã€æ”¶ç¼©è¾¹ç•Œ

![image-20250627114331643](pic/image-20250627114331643.png)



~~~C++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {

        vector <int> ans;
        if(matrix.empty()) return ans; //è‹¥æ•°ç»„ä¸ºç©ºï¼Œç›´æ¥è¿”å›ç­”æ¡ˆ

        int u = 0; //èµ‹å€¼ä¸Šä¸‹å·¦å³è¾¹ç•Œ
        int d = matrix.size() - 1;
        int l = 0;
        int r = matrix[0].size() - 1;

        while(true)
        {
            // å‘å³ç§»åŠ¨ç›´åˆ°æœ€å³
            for(int i = l; i <= r; ++i) ans.push_back(matrix[u][i]);
            if(++ u > d) break; //é‡æ–°è®¾å®šä¸Šè¾¹ç•Œï¼Œè‹¥ä¸Šè¾¹ç•Œå¤§äºä¸‹è¾¹ç•Œï¼Œåˆ™éå†å®Œæˆï¼Œä¸‹åŒ
            
            // å‘ä¸‹
            for(int i = u; i <= d; ++i) ans.push_back(matrix[i][r]); 
            if(-- r < l) break; //é‡æ–°è®¾å®šå³è¾¹ç•Œ

            // å‘å·¦
            for(int i = r; i >= l; --i) ans.push_back(matrix[d][i]); 
            if(-- d < u) break; //é‡æ–°è®¾å®šä¸‹è¾¹ç•Œ

            // å‘ä¸Š
            for(int i = d; i >= u; --i) ans.push_back(matrix[i][l]); 
            if(++ l > r) break; //é‡æ–°è®¾å®šå·¦è¾¹ç•Œ
        }


        return ans;
    }
};
~~~

**`++u` å…ˆè‡ªå¢ï¼Œå†æ¯”è¾ƒ**

~~~C++
if (++u > d) 
~~~







ACM 

~~~C++
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

static constexpr int DIRS[4][2] = {
    {0, 1},   // å‘å³
    {1, 0},   // å‘ä¸‹
    {0, -1},  // å‘å·¦
    {-1, 0}   // å‘ä¸Š
};

// è¿”å›çŸ©é˜µçš„èºæ—‹éå†é¡ºåº
vector<int> spiralOrder(vector<vector<int>>& matrix) {
    int m = matrix.size();        // è¡Œæ•°
    int n = matrix[0].size();     // åˆ—æ•°
    vector<int> ans(m * n);

    int i = 0, j = 0, di = 0;     // å½“å‰åæ ‡ (i, j)ï¼Œæ–¹å‘ç´¢å¼• di

    for (int k = 0; k < m * n; k++) {
        ans[k] = matrix[i][j];      // æ”¶é›†å½“å‰å…ƒç´ 
        matrix[i][j] = INT_MAX;     // æ ‡è®°è®¿é—®

        int x = i + DIRS[di][0];    // ä¸‹ä¸€è¡Œ
        int y = j + DIRS[di][1];    // ä¸‹ä¸€åˆ—

        // å‡ºç•Œæˆ–å·²è®¿é—®ï¼Œå³è½¬
        if (x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] == INT_MAX) {
            di = (di + 1) % 4;
        }

        i += DIRS[di][0];
        j += DIRS[di][1];
    }

    return ans;
}

int main() {
    int m, n;
    cin >> m >> n; // è¾“å…¥çŸ©é˜µè¡Œåˆ—æ•°

    vector<vector<int>> matrix(m, vector<int>(n));
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            cin >> matrix[i][j];
        }
    }

    vector<int> result = spiralOrder(matrix);
    for (int x : result) {
        cout << x << " ";
    }
    cout << endl;

    return 0;
}
~~~

ç¤ºä¾‹è¾“å…¥ï¼š

~~~C++
3 3
1 2 3
4 5 6
7 8 9
~~~

è¾“å‡ºï¼š

~~~C++
1 2 3 6 9 8 7 4 5
~~~



## [48 æ—‹è½¬å›¾åƒ](https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250628113029036](pic/image-20250628113029036.png)

![image-20250628113058397](pic/image-20250628113058397.png)

![image-20250628113104568](pic/image-20250628113104568.png)



~~~C++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {

        // ä¸¤æ¬¡ç¿»è½¬ï¼š(i,j) --> (j,i) --> (j,nâˆ’1âˆ’i)
        // - è½¬ç½®ï¼šæŒ‰ç…§ä¸»å¯¹è§’çº¿ç¿»è½¬ï¼Œ (i,j) --> (j,i)
        // - è¡Œç¿»è½¬ï¼šæ¯ä¸€è¡Œçš„å†…éƒ¨å…ƒç´ å¯¹ç§°ç¿»è½¬ï¼Œ(j,i) --> (j,nâˆ’1âˆ’i)

        int n = matrix.size();

        // ç¬¬ä¸€æ­¥ï¼šä¸»å¯¹è§’çº¿ç¿»è½¬ (i, j) --> (j, i)
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < i; j++) // æ‰¾ä¸»å¯¹è§’çº¿ä¸‹æ–¹çš„å…ƒç´ 
            {
                swap(matrix[i][j], matrix[j][i]);
            }
        }

        // ç¬¬äºŒæ­¥ï¼šè¡Œå†…å¯¹ç§°ç¿»è½¬ (i, j) --> (i,nâˆ’1âˆ’j) æ³¨æ„ä¸‹æ ‡æ˜¯iè¿˜æ˜¯jï¼ï¼ï¼
        for (auto& row : matrix)
        {
            ranges::reverse(row); // æˆ–è€…reverse(row.begin(), row.end());
        }
   
    }
};

        // ç¬¬äºŒæ­¥å¦‚æœç›´æ¥å†™æ™®é€šå¾ªç¯  ï¼ˆæ³¨æ„ä¸‹æ ‡æ˜¯iè¿˜æ˜¯jï¼ï¼ï¼ï¼‰
        // for (int i = 0; i < n; i++)
        // {
        //     for (int j = 0; j < (n/2); j++)
        //     {
        //         swap(matrix[i][j], matrix[i][n - 1 -j]);
        //     }
        // }
        // 
        // æˆ–è€… ï¼ˆæ¨èï¼‰
        // for (int i = 0; i < matrix.size(); i++) 
        // {
        //     int left = 0;
        //     int right = matrix[i].size() - 1;
        //     while (left < right) 
        //     {
        //         swap(matrix[i][left], matrix[i][right]);
        //         left++;
        //         right--;
        //     }
        // }


~~~



ACMï¼š

~~~C++
#include <iostream>
#include <vector>
#include <algorithm> // for std::swap, std::ranges::reverse

using namespace std;

// å°†çŸ©é˜µåŸåœ°é¡ºæ—¶é’ˆæ—‹è½¬90åº¦
void rotate(vector<vector<int>>& matrix) {
    int n = matrix.size();

    // ç¬¬ä¸€æ­¥ï¼šä¸»å¯¹è§’çº¿ç¿»è½¬ (i, j) -> (j, i)
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < i; j++) {
            swap(matrix[i][j], matrix[j][i]);
        }
    }

    // ç¬¬äºŒæ­¥ï¼šæ¯è¡Œå·¦å³ç¿»è½¬ (j, i) -> (j, n-1-i)
    for (auto& row : matrix) {
        reverse(row.begin(), row.end());  // ä½¿ç”¨ std::reverse æ›¿ä»£ ranges::reverse
    }
}

int main() {
    int n;
    cin >> n; // è¾“å…¥çŸ©é˜µå¤§å°ï¼ˆn x nï¼‰

    vector<vector<int>> matrix(n, vector<int>(n));
    for (int i = 0; i < n; i++) 
    {
        for (int j = 0; j < n; j++) 
        {
            cin >> matrix[i][j]; // è¾“å…¥çŸ©é˜µ
        }
    }

    rotate(matrix);

    // è¾“å‡ºæ—‹è½¬åçš„çŸ©é˜µ
    for (const auto& row : matrix) 
    {
        for (int x : row) 
        {
            cout << x << " ";
        }
        cout << endl;
    }

    return 0;
}

~~~

è¾“å…¥ï¼š

~~~C++
3
1 2 3
4 5 6
7 8 9
~~~

è¾“å‡ºï¼š

~~~C++
7 4 1
8 5 2
9 6 3
~~~



## 240 æœç´¢äºŒç»´çŸ©é˜µII

![image-20250629105356412](pic/image-20250629105356412.png)

ä¾æ—§æ˜¯çµç¥ï¼ï¼ï¼

![image-20250629105411464](pic/image-20250629105411464.png)

![image-20250629105431219](pic/image-20250629105431219.png)



~~~C++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {

        // æ¯”è¾ƒå³ä¸Šè§’ï¼Œtargetå¤§åˆ è¡Œï¼Œtargetå°åˆ åˆ—

        int m = matrix.size(), n = matrix[0].size();
        
        int i = 0, j = n - 1; // å³ä¸Šè§’

        while (i < m && j >= 0)
        {
            if (target == matrix[i][j]) return true; // æ‰¾åˆ°
            
            if (target > matrix[i][j])  i++; // targetå¤§ï¼Œå»ä¸‹ä¸€è¡Œ
            else                        j--; // targetå°ï¼Œå»å‰ä¸€åˆ—
        }
        
        return false;
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <ratio>
#include <vector>

using namespace std;


bool searchMatrix(vector<vector<int>>& matrix, int target) {

    // æ¯”è¾ƒå³ä¸Šè§’ï¼Œtargetå¤§åˆ è¡Œï¼Œtargetå°åˆ åˆ—

    int m = matrix.size(), n = matrix[0].size();
    
    int i = 0, j = n - 1; // å³ä¸Šè§’

    while (i < m && j >= 0)
    {
        if (target == matrix[i][j]) return true; // æ‰¾åˆ°
        
        if (target > matrix[i][j])  i++; // targetå¤§ï¼Œå»ä¸‹ä¸€è¡Œ
        else                        j--; // targetå°ï¼Œå»å‰ä¸€åˆ—
    }
    
    return false;
}


int main()
{
    int m, n, target;
    cin >> m >> n >> target; // è¾“å…¥çŸ©é˜µè¡Œæ•°ï¼Œåˆ—æ•°ï¼Œç›®æ ‡å€¼

    vector<vector<int>> matrix(m, vector<int>(n));
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            cin >> matrix[i][j]; // è¾“å…¥çŸ©é˜µå…ƒç´ 
        }
    }

    bool found = searchMatrix(matrix, target);
    cout << (found ? "true" : "false") << endl;


    return 0;
}
~~~

è¾“å…¥ï¼š

~~~C++
3 4 5
1 4 7 11
2 5 8 12
3 6 9 16
~~~

è¾“å‡ºï¼š

~~~C++
true
~~~





# é“¾è¡¨ âœ…

## åŸºæœ¬ACMç»“æ„

~~~C++
#include <iostream>
using namespace std;

// å®šä¹‰å•é“¾è¡¨ç»“æ„ä½“
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};


// å·¥å…·å‡½æ•°ï¼šå°¾æ’æ³•æ„å»ºé“¾è¡¨ï¼ˆä» vector<int>ï¼‰
ListNode* buildList(const vector<int>& nums) 
{
    if (nums.empty()) return nullptr;
    ListNode* head = new ListNode(nums[0]);
    ListNode* cur = head;
    for (int i = 1; i < nums.size(); i++) 
    {
        cur->next = new ListNode(nums[i]);
        cur = cur->next;
    }
    return head;
}

// å·¥å…·å‡½æ•°ï¼šæ‰“å°é“¾è¡¨
void printList(ListNode* head) 
{
    while (head) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}


// æ ¹æ®é¢˜ç›®éœ€æ±‚å®šä¹‰å‡½æ•°ï¼Œæ¯”å¦‚åè½¬é“¾è¡¨
ListNode* solve(ListNode* head) {
   
}


// ä¸»å‡½æ•°ï¼šè¯»å–è¾“å…¥ï¼Œè°ƒç”¨é€»è¾‘ï¼Œè¾“å‡ºç»“æœ
int main() {
    int n;
    cin >> n;  // è¾“å…¥é“¾è¡¨é•¿åº¦
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i]; // è¾“å…¥æ¯ä¸ªèŠ‚ç‚¹å€¼
    }
    ListNode* head = buildList(nums); // æ„å»ºé“¾è¡¨

    ListNode* result = solve(head); // è°ƒç”¨é¢˜è§£é€»è¾‘
    printList(result); // è¾“å‡ºç»“æœé“¾è¡¨

    return 0;
}

~~~

å¦‚æœä¸æ„å»ºå·¥å…·å‡½æ•°ï¼š

~~~C++
#include <iostream>
using namespace std;

// å®šä¹‰å•é“¾è¡¨ç»“æ„ä½“
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};


// æ ¹æ®é¢˜ç›®éœ€æ±‚å®šä¹‰å‡½æ•°
ListNode* solve(ListNode* head) {
    
}


int main()
{
    // ç›´æ¥æ„å»ºé“¾è¡¨
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    ...
    // æ‰§è¡Œé¢˜ç›®é€»è¾‘
    ListNode* result = solve(head);
    
    // æ‰“å°
    while (head)
    {
        cout << result->val << endl;
        result = result->next;
    }
    
    return 0;
}
~~~





## 160 [ç›¸äº¤é“¾è¡¨](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250630104059221](pic/image-20250630104059221.png)

==**æ³¨æ„æ˜¯æŒ‡é’ˆç›¸ç­‰ï¼ï¼ï¼** **ä¸æ˜¯æ•°å€¼ç›¸ç­‰ï¼ï¼**==



### 1ã€æ‹¼æ¥é“¾è¡¨ï¼ˆæ¨èï¼ï¼‰

> [Krahets é¢˜è§£](https://leetcode.cn/problems/intersection-of-two-linked-lists/solutions/12624/intersection-of-two-linked-lists-shuang-zhi-zhen-l/?envType=study-plan-v2&envId=top-100-liked)

- å‡è®¾æ‹¼æ¥ä¸¤ä¸ªé“¾è¡¨ åˆ†åˆ«**BAæ‹¼æ¥ï¼ŒABæ‹¼æ¥**ï¼Œæ‹¼æ¥åä¸¤é“¾è¡¨é•¿åº¦è‚¯å®šç›¸åŒ
- å¦‚æœAå’ŒBæœ‰ç›¸äº¤ï¼Œåˆ™ **BA å’Œ AB** çš„**æœ«å°¾å‡ ä½è‚¯å®šæ˜¯ç›¸åŒçš„**
- è¿™æ ·çš„ä¸¤ä¸ªå åŠ é“¾è¡¨åŒæ—¶éå†åˆ°æœ‰ç›¸åŒèŠ‚ç‚¹çš„æ—¶å€™ï¼Œä¸€å®šä¸€è¾¹æ˜¯A é“¾è¡¨ä¸€è¾¹æ˜¯ B é“¾è¡¨
- ç›¸äº¤èŠ‚ç‚¹å¼€å§‹åˆ°ç»“å°¾çš„èŠ‚ç‚¹éƒ½ç›¸åŒï¼Œæ‰€ä»¥**ç¬¬ä¸€ä¸ªç›¸åŒçš„èŠ‚ç‚¹**å°±æ˜¯ A é“¾è¡¨å’Œ B é“¾è¡¨çš„äº¤ç‚¹

 ![image-20250630105036574](pic/image-20250630105036574.png)



~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {

        ListNode* curA = headA;
        ListNode* curB = headB;
        
        // curA èµ° A->B, curB èµ° B->Aï¼Œç›´åˆ° curA = curB
        while (curA != curB)
        {  
            curA = curA  ? curA->next : headB;// curAèµ°åˆ°nullï¼Œå†ç»§ç»­èµ°Bï¼Œç›¸å½“äºæ‹¼æ¥ A->B           
            curB = curB  ? curB->next : headA;// curBèµ°åˆ°nullï¼Œå†ç»§ç»­èµ°Aï¼Œç›¸å½“äºæ‹¼æ¥ B->A
        }
        
        return curA; // æœ€åä¸¤ä¸ªæŒ‡é’ˆé‡åˆ curA = curB
        
        // æœ‰äº¤ç‚¹ï¼Œè¿”å›äº¤ç‚¹
        // æ— äº¤ç‚¹ï¼ŒcurA å’Œ curB ä¼šä¸€èµ·èµ°åˆ°nullptrï¼Œè¿”å›çš„ä¹Ÿå°±æ˜¯ curA = nullptr  
    }
};
~~~



### 2ã€å¯¹é½å°¾éƒ¨ï¼ˆå¸¸è§„ï¼‰

![image-20250906155422786](./pic/image-20250906155422786.png)

<img src="pic/image-20250630104237243.png" alt="image-20250630104237243" style="zoom:30%;" />

![image-20250630104252589](pic/image-20250630104252589.png)

<img src="pic/image-20250630104257026.png" alt="image-20250630104257026" style="zoom:33%;" />

![image-20250630104329816](pic/image-20250630104329816.png)



**æ³¨æ„æœ€åæ¯”è¾ƒçš„ä¸€å®šæ˜¯ `curA == curB` ï¼Œ<span style="color:#CC0000;">èŠ‚ç‚¹ç›¸ç­‰ï¼ŒåŒ…æ‹¬æ•°å€¼ç›¸ç­‰ï¼Œå†…å­˜ä½ç½®ç›¸åŒ</span>**

~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {

        ListNode* curA = headA;
        ListNode* curB = headB;

        // æ±‚é“¾è¡¨Aå’Œé“¾è¡¨Bçš„é•¿åº¦
        int lenA = 0, lenB = 0;
        while (curA != nullptr)
        {
            lenA++;
            curA = curA->next;
        }
        while (curB != nullptr)
        {
            lenB++;
            curB = curB->next;
        }

        // curå†ç§»å›å¤´èŠ‚ç‚¹
        curA = headA;
        curB = headB;

        // è®©curAç§°ä¸ºè¾ƒé•¿é“¾è¡¨çš„å¤´ï¼ŒlenAä¸ºå…¶é•¿åº¦
        if (lenB > lenA)
        {
            swap(lenA, lenB);
            swap(curA, curB);
        }

        // æœ«å°¾å¯¹é½ï¼Œç§»åŠ¨curAåˆ°ä¸curBç›¸å¯¹åº”çš„ä½ç½®
        int gap = lenA - lenB;
        while (gap--)	curA = curA->next;

        // ç„¶å curA curB åŒæ—¶å‘åç§»åŠ¨ï¼Œé‡åˆ°ç›¸åŒèŠ‚ç‚¹å³ç›¸äº¤èŠ‚ç‚¹
        while (curA != nullptr)
        {
            if (curA == curB)   return curA; // æ³¨æ„æ˜¯æŒ‡é’ˆç›¸ç­‰ï¼Œä¸æ˜¯æ•°å€¼ç›¸ç­‰ï¼ï¼ï¼

            curA = curA->next;
            curB = curB->next;
        }

        return nullptr; // æ— ç›¸äº¤èŠ‚ç‚¹
    }
};
~~~



### ACM

~~~C++
#include <iostream>

using namespace std;

struct ListNode
{
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* getIntersectionNode(ListNode* headA, ListNode* headB)
{
    
    ListNode* curA = headA;
    ListNode* curB = headB;

    // æ±‚é“¾è¡¨Aå’Œé“¾è¡¨Bçš„é•¿åº¦
    int lenA = 0, lenB = 0;
    while (curA != nullptr)
    {
        lenA++;
        curA = curA->next;
    }
    while (curB != nullptr)
    {
        lenB++;
        curB = curB->next;
    }

    // curå†ç§»å›å¤´èŠ‚ç‚¹
    curA = headA;
    curB = headB;

    // è®©curAç§°ä¸ºè¾ƒé•¿é“¾è¡¨çš„å¤´ï¼ŒlenAä¸ºå…¶é•¿åº¦
    if (lenB > lenA)
    {
        swap(lenA, lenB);
        swap(curA, curB);
    }

    // æœ«å°¾å¯¹é½ï¼Œç§»åŠ¨curAåˆ°ä¸curBç›¸å¯¹åº”çš„ä½ç½®
    int gap = lenA - lenB;
    while (gap--)
    {
        curA = curA->next;
    }

    // ç„¶å curA curB åŒæ—¶å‘åç§»åŠ¨ï¼Œé‡åˆ°ç›¸åŒèŠ‚ç‚¹å³ç›¸äº¤èŠ‚ç‚¹
    while (curA != nullptr)
    {
        if (curA == curB)   return curA; // æ³¨æ„æ˜¯æŒ‡é’ˆç›¸ç­‰ï¼Œä¸æ˜¯æ•°å€¼ç›¸ç­‰ï¼ï¼ï¼

        curA = curA->next;
        curB = curB->next;
    }

    return nullptr; // æ— ç›¸äº¤èŠ‚ç‚¹
        
}


int main()
{
    // æ„å»ºé“¾è¡¨ A: 4 -> 1 -> [8 -> 4 -> 5]
    ListNode* a1 = new ListNode(4);
    ListNode* a2 = new ListNode(1);
    ListNode* a3 = new ListNode(8);
    ListNode* a4 = new ListNode(4);
    ListNode* a5 = new ListNode(5);
    a1->next = a2;
    a2->next = a3;
    a3->next = a4;
    a4->next = a5;


    // æ„å»ºé“¾è¡¨ B: 5 -> 0 -> 1 -> [8 -> 4 -> 5]
    ListNode* b1 = new ListNode(5);
    ListNode* b2 = new ListNode(0);
    ListNode* b3 = new ListNode(1);
    b1->next = b2;
    b2->next = b3;
    b3->next = a3; // ç›´æ¥è¿åœ¨Aä¸­çš„èŠ‚ç‚¹ ä¸é“¾è¡¨ A ç›¸äº¤äºèŠ‚ç‚¹å€¼ 8

    ListNode* result = getIntersectionNode(a1, b1);

    if (result) cout << result->val << endl; // è¾“å‡ºç›¸äº¤èŠ‚ç‚¹å€¼
    else        cout << "null" << endl;

    
    return 0;
}
~~~

è¾“å‡ºï¼š

~~~C++
8
~~~





## 206 [åè½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250701104653159](pic/image-20250701104653159.png)

### 1ã€åŒæŒ‡é’ˆ

<img src="pic/image-20250701104705438.png" alt="image-20250701104705438" style="zoom:50%;" />

~~~C++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        
        // åŒæŒ‡é’ˆ

        ListNode* tmp;
        ListNode* cur = head;
        ListNode* pre = nullptr;

        while (cur)
        {
            tmp = cur->next;
            cur->next = pre; // æ–­å¼€curå’Œcur->nextï¼Œåè½¬

            // åç§»preå’Œcur
            pre = cur;
            cur = tmp;
        }

        return pre;// æ–°çš„å¤´èŠ‚ç‚¹
        
    }
};
~~~



### 2ã€é€’å½’

![image-20250701111833504](pic/image-20250701111833504.png)

![image-20250701112439377](pic/image-20250701112439377.png)

~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // é€’å½’ æ„å»ºreverseå‡½æ•°
    ListNode* reverse(ListNode* pre, ListNode* cur)
    {
        if (cur == nullptr) return pre; // ç›´åˆ°cur = nullptrï¼Œè¿”å›preå°±æ˜¯æ–°çš„å¤´èŠ‚ç‚¹

        ListNode* tmp = cur->next;
        cur->next = pre; // åè½¬

        return reverse(cur, tmp); // ç›¸å½“äº pre = cur, cur = tmp
    }


    ListNode* reverseList(ListNode* head) {
        return reverse(nullptr, head); // åˆå§‹ cur = head, pre = nullpt  
    }
};
~~~





### ACM

~~~C++
#include <cstddef>
#include <iostream>
using namespace std;

// é“¾è¡¨ç»“æ„
struct ListNode
{
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// åè½¬é“¾è¡¨
ListNode* reverseList(ListNode* head)
{
    // åŒæŒ‡é’ˆ
    ListNode* tmp;
    ListNode* cur = head;
    ListNode* pre = nullptr;

    while (cur)
    {
        tmp = cur->next;
        cur->next = pre;

        pre = cur;
        cur = tmp;
    }

    return pre;
}


int main()
{
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);

    ListNode* result = reverseList(head);

    while (result)
    {
        cout << result->val << endl;
        result = result->next;
    }


    return 0;

}
~~~

è¾“å‡ºï¼š

~~~C++
4
3
2
1
~~~





## [234 å›æ–‡é“¾è¡¨](https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250702100234589](pic/image-20250702100234589.png)

### 1ã€åˆ©ç”¨æ•°ç»„

~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        
        // é“¾è¡¨å€¼æ”¾å…¥æ•°ç»„ï¼Œå†åˆ¤æ–­æ•°ç»„æ˜¯å¦å›æ–‡
        vector<int> vec;
        ListNode* cur = head;
        while (cur)
        {
            vec.push_back(cur->val);
            cur = cur->next;
        }

        for (int i = 0, j = vec.size() - 1; i < j; i++, j--)
        {
            if (vec[i] != vec[j])   return false;
        }

        return true;    
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ï¼š*O*(*n*)ï¼Œå…¶ä¸­ *n* æŒ‡çš„æ˜¯é“¾è¡¨çš„å…ƒç´ ä¸ªæ•°ã€‚

ç©ºé—´å¤æ‚åº¦ï¼š*O*(*n*)ï¼Œå…¶ä¸­ *n* æŒ‡çš„æ˜¯é“¾è¡¨çš„å…ƒç´ ä¸ªæ•°ï¼Œä½¿ç”¨äº†ä¸€ä¸ªæ•°ç»„åˆ—è¡¨å­˜æ”¾é“¾è¡¨çš„å…ƒç´ å€¼ã€‚



### 2ã€*O*(*1*)ç©ºé—´åšæ³•ï¼š

> [**çµèŒ¶å±±è‰¾åºœ O(1) ç©ºé—´åšæ³•ï¼šå¯»æ‰¾ä¸­é—´èŠ‚ç‚¹+åè½¬é“¾è¡¨**](https://leetcode.cn/problems/palindrome-linked-list/solutions/2952645/o1-kong-jian-zuo-fa-xun-zhao-zhong-jian-rv0f3/?envType=study-plan-v2&envId=top-100-liked) 

![image-20250702102934665](pic/image-20250702102934665.png)

æ—¶é—´å¤æ‚åº¦ï¼šO(*n*)ï¼Œå…¶ä¸­ *n* æ˜¯é“¾è¡¨çš„é•¿åº¦ï¼ˆèŠ‚ç‚¹ä¸ªæ•°ï¼‰ã€‚

ç©ºé—´å¤æ‚åº¦ï¼šO(1)ã€‚

~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 876 é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹
    ListNode* middleNode(ListNode* head)
    {
        ListNode* slow = head, *fast = head;
        while (fast && fast->next)
        {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }

    // 206 åè½¬é“¾è¡¨
    ListNode* reverseList(ListNode* head)
    {
        ListNode* tmp;
        ListNode* cur = head;
        ListNode* pre = nullptr;
        while (cur)
        {
            tmp = cur->next;
            cur->next = pre;

            pre = cur;
            cur = tmp;
        }
        return pre;
    }


    bool isPalindrome(ListNode* head) {

        // æ‰¾ä¸­é—´èŠ‚ç‚¹ï¼Œåè½¬æ¯”è¾ƒ

        ListNode* mid = middleNode(head);
        ListNode* head2 = reverseList(mid); // æ³¨æ„ï¼Œmidå’ŒåŸé“¾è¡¨å‰é¢çš„èŠ‚ç‚¹æ²¡æœ‰æ–­å¼€

        //                                  head                 head2
        // 1 -> 2 -> 3 -> 4 -> 5        =>  1 -> 2 -> 3          5 -> 4 -> 3
        // 1 -> 2 -> 3 -> 4 -> 5 -> 6   =>  1 -> 2 -> 3 - > 4    6 -> 5 -> 4 

        while (head2) // å¶æ•°èŠ‚ç‚¹æ—¶ï¼Œhead2è¦æ¯”headå°‘ä¸€ä¸ªèŠ‚ç‚¹
        {
            if (head->val != head2->val)    return false;

            head = head->next;
            head2 = head2->next;
        }

        return true;     
    }
};
~~~



### ACM

~~~C++
#include <cstddef>
#include <iostream>
using namespace std;

// 234 å›æ–‡é“¾è¡¨ï¼šä¸­é—´èŠ‚ç‚¹ + åè½¬
// æ—¶é—´å¤æ‚åº¦: O(n)
// ç©ºé—´å¤æ‚åº¦: O(1)

// é“¾è¡¨ç»“æ„å®šä¹‰
struct ListNode
{
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {};
};


// 876 æ‰¾ä¸­é—´èŠ‚ç‚¹
ListNode* middleNode(ListNode* head)
{
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast && fast->next)
    {
        slow = slow->next;
        fast = fast->next->next;
    }

    return slow;
}

// 206 åè½¬é“¾è¡¨
ListNode* reverseList(ListNode* head)
{
    ListNode* tmp;
    ListNode* cur = head;
    ListNode* pre = nullptr;

    while (cur)
    {
        tmp = cur->next;
        cur->next = pre;

        pre = cur;
        cur = tmp;
    }

    return pre;
}


// å›æ–‡
bool isPalindrome(ListNode* head)
{
    ListNode* mid = middleNode(head);
    ListNode* head2 = reverseList(mid);

    while(head2)
    {
        if (head->val != head2->val)    return false;
        head = head->next;
        head2 = head2->next;
    }

    return true;
}



int main()
{
    int n;
    cin >> n; // é“¾è¡¨é•¿åº¦
    if (n <= 0)
    {
        cout << "false" << endl;
        return 0;
    }

    // æ„å»ºé“¾è¡¨
    int x;
    cin >> x;
    ListNode* head = new ListNode(x);
    ListNode* cur = head;
    for (int i = 1; i < n; i++)
    {
        cin >> x;
        cur->next = new ListNode(x);
        cur = cur->next;
    }

    bool result = isPalindrome(head);
    cout << (result ? "true" : "false") << endl;

    
    return 0;
}
~~~

è¾“å…¥ï¼š

~~~C++
5
1 2 3 2 1
~~~

è¾“å‡ºï¼š

~~~C++
true
~~~





## 141 [ç¯å½¢é“¾è¡¨](https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-100-liked)

@åˆ¤æ–­æœ‰æ²¡æœ‰ç¯   @å¿«æ…¢æŒ‡é’ˆ

![image-20250702105023599](pic/image-20250702105023599.png)

![image-20250702105039365](pic/image-20250702105039365.png)

<img src="pic/image-20250703111628478.png" alt="image-20250703111628478" style="zoom: 33%;" />



![image-20250702105122723](pic/image-20250702105122723.png)

<img src="pic/image-20250702105136005.png" alt="image-20250702105136005" style="zoom: 50%;" />



- æ—¶é—´å¤æ‚åº¦ï¼šO(*n*)ï¼Œå…¶ä¸­ *n* ä¸ºé“¾è¡¨çš„é•¿åº¦ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ï¼Œä»…ç”¨åˆ°è‹¥å¹²é¢å¤–å˜é‡ã€‚

~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {

        // å¿«æ…¢æŒ‡é’ˆ
        ListNode* fast = head;
        ListNode* slow = head;

        while (fast && fast->next)
        {
            slow = slow->next;      // slow èµ°ä¸€æ­¥
            fast = fast->next->next;// fast èµ°ä¸¤æ­¥

            if (slow == fast)   return true; // ç›¸é‡ï¼Œè¯´æ˜æœ‰ç¯
        }

        return false;
        
    }
};
~~~



ACM

~~~C++
#include <iostream>
using namespace std;

// 141 ç¯å½¢é“¾è¡¨ ï¼ˆå¿«æ…¢æŒ‡é’ˆç›¸é‡ï¼‰
// æ—¶é—´å¤æ‚åº¦: O(n)
// ç©ºé—´å¤æ‚åº¦: O(1)

// å®šä¹‰é“¾è¡¨èŠ‚ç‚¹ç»“æ„
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// åˆ¤æ–­é“¾è¡¨æ˜¯å¦æœ‰ç¯
bool hasCycle(ListNode* head) 
{
    ListNode* fast = head;
    ListNode* slow = head;
    while (fast && fast->next) 
    {
        slow = slow->next;       // slow èµ°ä¸€æ­¥
        fast = fast->next->next; // fast èµ°ä¸¤æ­¥
        if (slow == fast) return true; // å¿«æ…¢æŒ‡é’ˆç›¸é‡è¯´æ˜æœ‰ç¯
    }

    return false;
}


int main() {
    // æ„å»ºé“¾è¡¨ 3 -> 2 -> 0 -> -4
    ListNode* n1 = new ListNode(3);
    ListNode* n2 = new ListNode(2);
    ListNode* n3 = new ListNode(0);
    ListNode* n4 = new ListNode(4);

    n1->next = n2;
    n2->next = n3;
    n3->next = n4;
    n4->next = n2;  // åˆ¶é€ ç¯ï¼Œä½¿å¾— -4 æŒ‡å‘ 2ï¼Œå½¢æˆç¯

    if (hasCycle(n1)) {
        cout << "true" << endl;
    } else {
        cout << "false" << endl;
    }

    return 0;
}
~~~

è¾“å‡ºï¼š

~~~C++
true
~~~





## 142 [ç¯å½¢é“¾è¡¨II](https://leetcode.cn/problems/linked-list-cycle-ii/description/?envType=study-plan-v2&envId=top-100-liked)

@ æ‰¾åˆ°å…¥ç¯çš„èŠ‚ç‚¹

![image-20250703110210183](pic/image-20250703110210183.png)

**1ã€åˆ¤æ–­æ˜¯å¦æœ‰ç¯ slow fast**

- slowèµ°1ï¼Œfastèµ°2
- å¦‚æœæœ‰ç¯ï¼Œslowä¼šå’Œfastç›¸é‡ï¼ˆå¹¶ç›¸é‡åœ¨ç¯ä¸­ï¼‰
- æ— ç¯ï¼Œfastèµ°åˆ°nullptrå³ç»“æŸ

**2ã€slow = fastæœ‰ç¯ï¼ŒæŸ¥æ‰¾å…¥å£**

- index1 ä»ç›¸é‡ç‚¹èµ°ï¼Œèµ°z + nåœˆ
- index2 ä»headèµ°ï¼Œèµ°x
- ä¼šåœ¨å…¥å£ç›¸é‡

![image-20250703113759595](pic/image-20250703113759595.png)

![image-20250703115139195](pic/image-20250703115139195.png)

![image-20250703114035170](pic/image-20250703114035170.png)



![image-20250703114047706](pic/image-20250703114047706.png)



![image-20250703114815004](pic/image-20250703114815004.png)



~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {

        // 1 æ˜¯å¦æœ‰ç¯
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next)
        {
            slow = slow->next;
            fast = fast->next->next;

            // å¦‚æœæ²¡ç¯ï¼Œfastèµ°åˆ°nullç»“æŸ

            // 2 æœ‰ç¯ï¼Œfast = slow  æŸ¥æ‰¾å…¥å£
            if (slow == fast)
            {
                ListNode* index1 = fast; // ä»ç›¸é‡ç‚¹å¼€å§‹
                ListNode* index2 = head; // ä»å¤´å¼€å§‹

                // index1 å’Œ index2 æ¯æ¬¡èµ°ä¸€æ­¥ï¼Œç›´åˆ°ç›¸é‡ï¼Œå³å…¥ç¯å£
                while (index1 != index2)
                {
                    index1 = index1->next;// åªä¸è¿‡index1ä¼šæ¯”index2å¤šèµ°å‡ åœˆ
                    index2 = index2->next; 
                }

                return index2; // è¿”å›ç›¸é‡ç‚¹ï¼Œå³å…¥å£
            }
        }

        return nullptr;
    }
};
~~~









## 21 [åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250704100529835](pic/image-20250704100529835.png)



![image-20250704101318932](pic/image-20250704101318932.png)



![image-20250704101434522](pic/image-20250704101434522.png)



~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {

        ListNode* dummyHead = new ListNode(0);
        ListNode* cur = dummyHead;
        while (list1 && list2)
        {
            if (list1->val < list2->val)
            {
                cur->next = list1; // å–å°çš„èŠ‚ç‚¹æ‹¼æ¥åœ¨curåé¢
                list1 = list1->next;
            }
            else
            {
                cur->next = list2;
                list2 = list2->next;
            }

            cur = cur->next;
        }

        // ä¸Šé¢whileç»ˆæ­¢ï¼Œæ˜¯ç”±äºlist1æˆ–list2ä¸ºnullptr
        // åˆ¤æ–­æ˜¯å“ªä¸ªç»ˆæ­¢äº†ï¼Œå°†å¦ä¸€ä¸ªé“¾è¡¨çš„å‰©ä¸‹éƒ¨åˆ†ä¹Ÿæ‹¼æ¥ä¸Š
        cur->next = (list1 != nullptr) ? list1 : list2;

        return dummyHead->next; // è¿”å›çœŸæ­£çš„å¤´èŠ‚ç‚¹
        
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ O(M+N) ï¼šMï¼ŒNæ˜¯ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ï¼Œåˆå¹¶æ“ä½œéœ€è¦æ“ä½œä¸¤é“¾è¡¨

ç©ºé—´å¤æ‚åº¦ O(1)ï¼šèŠ‚ç‚¹å¼•ç”¨dummyHeadï¼Œcurä½¿ç”¨å¸¸æ•°å¤§å°çš„é¢å¤–ç©ºé—´



ACM

~~~C++
#include <iostream>
using namespace std;

// 21 åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨
// æ—¶é—´å¤æ‚åº¦ï¼šO(n + m)
// ç©ºé—´å¤æ‚åº¦ï¼šO(1)

struct ListNode
{
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// åˆå¹¶
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2)
{
    ListNode* dummyHead = new ListNode(0);
    ListNode* cur = dummyHead;

    while (list1 && list2)
    {
        if (list1->val < list2->val)
        {
            cur->next = list1;
            list1 = list1->next;
        }
        else 
        {
            cur->next = list2;
            list2 = list2->next;
        }
        
        cur = cur->next;
    }

    cur->next = (list1 != nullptr) ? list1 : list2;

    return dummyHead->next;
}


int main()
{
    // æ„å»ºé“¾è¡¨ list1: 1 -> 2 -> 4
    ListNode* list1 = new ListNode(1);
    list1->next = new ListNode(2);
    list1->next->next = new ListNode(4);

    // æ„å»ºé“¾è¡¨ list2: 1 -> 3 -> 4
    ListNode* list2 = new ListNode(1);
    list2->next = new ListNode(3);
    list2->next->next = new ListNode(4);

    // åˆå¹¶é“¾è¡¨
    ListNode* mergeNode = mergeTwoLists(list1, list2);

    // æ‰“å°
    while (mergeNode)
    {
        cout << mergeNode->val << " ";
        mergeNode = mergeNode->next;
    }
    cout << endl;

    return 0;
}
~~~





## 2 [ä¸¤æ•°ç›¸åŠ ](https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250704104153847](pic/image-20250704104153847.png)

é¢˜è§£ï¼š[å°†é“¾è¡¨åè¿‡æ¥çœ‹](https://leetcode.cn/problems/add-two-numbers/solutions/2826226/jiang-lian-biao-fan-guo-lai-kan-jiu-bu-b-mfhh/?envType=study-plan-v2&envId=top-100-liked)

<img src="pic/image-20250704105742420.png" alt="image-20250704105742420" style="zoom:50%;" />

~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

        ListNode* dummyHead = new ListNode(0);
        ListNode* node = dummyHead;

        int carrier = 0; // è¿›ä½

        // åªè¦2ä¸ªé“¾è¡¨ä¸­æœ‰æ²¡èµ°åˆ°å°½å¤´çš„ï¼Œæˆ–è€…è¿›ä½ä¸ä¸º0ï¼Œå°±ä¸€ç›´å‰è¿›
        while (l1 || l2 || carrier)
        {
            // æ±‚å’Œ 
            int sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carrier;

            // åœ¨å°¾éƒ¨æ·»åŠ æ–°èŠ‚ç‚¹
            node->next = new ListNode(sum % 10); // å¯¹10å–ä½™ï¼ˆå–ä¸ªä½ï¼‰
            
            // æ›´æ–°è¿›ä½
            carrier = sum / 10;

            // å¾€ä¸‹èµ°ï¼ŒåŠ ä¸‹ä¸€ä½
            node = node->next;
            if (l1) l1 = l1->next;
            if (l2) l2 = l2->next;
        }

        return dummyHead->next;        
    }
};
~~~



ACM

~~~C++
#include <iostream>
using namespace std;

// 2 ä¸¤æ•°ä¹‹å’Œ
// æ—¶é—´å¤æ‚åº¦ï¼šO(m + n)
// ç©ºé—´å¤æ‚åº¦ï¼šO(1)

struct ListNode
{
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};


ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)
{
    ListNode* dummyHead = new ListNode(0);
    ListNode* node = dummyHead;

    int carrier = 0;
    while (l1 || l2 || carrier)
    {
        int sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carrier;

        node->next = new ListNode(sum % 10);
        carrier = sum / 10;

        node = node->next;
        if (l1)     l1 = l1->next;
        if (l2)     l2 = l2->next;
    }

    return dummyHead->next;
}


int main()
{
    // æ„å»ºé“¾è¡¨ l1: 2 -> 4 -> 3 ï¼ˆè¡¨ç¤ºæ•°å­—342ï¼‰æ³¨æ„é¡ºåº
    ListNode* l1 = new ListNode(2);
    l1->next = new ListNode(4);
    l1->next->next = new ListNode(3);

    // æ„å»ºé“¾è¡¨ l2: 5 -> 6 -> 4 ï¼ˆè¡¨ç¤ºæ•°å­—465ï¼‰
    ListNode* l2 = new ListNode(5);
    l2->next = new ListNode(6);
    l2->next->next = new ListNode(4);

    // ç›¸åŠ  
    //      3 <- 4 <- 2 
    // +    4 <- 6 <- 5
    // =    8 <- 0 <- 7
    ListNode* result = addTwoNumbers(l1, l2);

    // è¾“å‡º
    while (result)
    {
        cout << result->val;
        if (result->next)   cout << "->";
        result = result->next;
    }

    cout << endl;


    return  0;
}
~~~

è¾“å‡ºï¼š

~~~C++
7->0->8
~~~





## 19 [åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250706102933531](pic/image-20250706102933531.png)

![image-20250908112442221](./pic/image-20250908112442221.png)

![image-20250908113223869](./pic/image-20250908113223869.png)

![image-20250908113105100](./pic/image-20250908113105100.png)



~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {

        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;

        ListNode* slow = dummyHead;
        ListNode* fast = dummyHead;

        // fast å…ˆèµ° n æ­¥ï¼Œä¸ºäº†ä¿è¯ fast å’Œ slow ä¹‹é—´éš”ç€ n 
        while (n--)	fast = fast->next;
            

        // slow å’Œ fast ä¸€èµ·åç§»ï¼Œfast->next æŒ‡å‘nullï¼Œslowæ­£å¥½æŒ‡å‘å€’æ•°ã€ç¬¬nä¸ªèŠ‚ç‚¹çš„å‰ä¸€ä¸ªã€‘
        while (fast->next != nullptr)
        {
            slow = slow->next;
            fast = fast->next;
        }

        // è·³è¿‡åŸæ¥çš„slow->next (å³å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹)
        ListNode* tmp = slow->next;
        slow->next = tmp->next;
        delete tmp;

        return dummyHead->next;
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ï¼šO(N) Nä¸ºé“¾è¡¨é•¿åº¦
ç©ºé—´å¤æ‚åº¦ï¼šO(1)



ACM

~~~C++
#include <iostream>
using namespace std;

// 19 åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹
// æ—¶é—´å¤æ‚åº¦ï¼šO(N) Nä¸ºé“¾è¡¨é•¿åº¦
// ç©ºé—´å¤æ‚åº¦ï¼šO(1)

struct ListNode
{
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};


ListNode* removeNthFromEnd(ListNode* head, int n)
{
    ListNode* dummyHead = new ListNode(0);
    dummyHead->next = head;

    ListNode* slow = dummyHead;
    ListNode* fast = dummyHead;

    // fast å…ˆèµ° n + 1 æ­¥
    while (n-- && fast)
    {
        fast = fast->next;
    }
    fast = fast->next;
    // for (int i = 0; i <= n; ++i) {
    //    fast = fast->next;
    // }

    // slow å’Œ fast ä¸€èµ·ç§»åŠ¨
    while (fast)
    {
        slow = slow->next;
        fast = fast->next;
    }

    // åˆ é™¤ slow->next
    ListNode* tmp = slow->next;
    slow->next = tmp->next;
    delete tmp;

    return dummyHead->next;
}


int main()
{
    // æ„å»ºé“¾è¡¨ï¼š1 -> 2 -> 3 -> 4 -> 5
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    int n = 2;// åˆ é™¤å€’æ•°ç¬¬2ä¸ª

    ListNode* result = removeNthFromEnd(head, n);

    // è¾“å‡º
    while (result)
    {
        cout << result->val;
        if (result->next)   cout << "->";
        result = result->next;
    }
    cout << endl;


    return 0;
}
~~~

è¾“å‡ºï¼š

~~~C++
1->2->3->5
~~~





## [24 ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹](https://leetcode.cn/problems/swap-nodes-in-pairs/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250706172342027](pic/image-20250706172342027.png)



![image-20250706172326114](pic/image-20250706172326114.png)



![image-20250706172407330](pic/image-20250706172407330.png)



~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {

        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;

        ListNode* cur = dummyHead; 

        while (cur->next && cur->next->next)
        {
            ListNode* tmp = cur->next; // ä¿å­˜åŸ cur->next
            ListNode* tmp1 = cur->next->next->next; // ä¿å­˜åŸcur->next->next->next

            // äº¤æ¢curåçš„ä¸¤ä¸ªèŠ‚ç‚¹
            cur->next = cur->next->next;
            cur->next->next = tmp;
            cur->next->next->next = tmp1;

            // cur åç§»ä¸¤ä½
            cur = cur->next->next;
        }

        return dummyHead->next;
        
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ï¼šO(N) Nä¸ºé“¾è¡¨é•¿åº¦
ç©ºé—´å¤æ‚åº¦ï¼šO(1)



ACM

~~~C++
#include <iostream>
using namespace std;

// 24 ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹
// æ—¶é—´å¤æ‚åº¦ï¼šO(N) Nä¸ºé“¾è¡¨é•¿åº¦
// ç©ºé—´å¤æ‚åº¦ï¼šO(1)

struct ListNode
{
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};


ListNode* swapPairs(ListNode* head)
{
    ListNode* dummyHead = new ListNode(0);
    dummyHead->next = head;

    ListNode* cur = dummyHead;

    while (cur->next && cur->next->next)
    {
        ListNode* tmp = cur->next;
        ListNode* tmp1 = cur->next->next->next;

        // äº¤æ¢curåçš„ä¸¤ä¸ªèŠ‚ç‚¹
        cur->next = cur->next->next;
        cur->next->next = tmp;
        cur->next->next->next = tmp1;

        // cur åç§»ä¸¤ä¸ªä½ç½®
        cur = cur->next->next;
    }

    return dummyHead->next;
}


int main()
{
    // æ„å»ºé“¾è¡¨: 1 -> 2 -> 3 -> 4
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);

    ListNode* newHead = swapPairs(head);

    while (newHead)
    {
        cout << newHead->val << " ";
        newHead = newHead->next;
    }
    cout << endl;

    return 0;
}
~~~

è¾“å‡ºï¼š
~~~
2 1 4 3 
~~~





## [25 Kä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250707112416481](pic/image-20250707112416481.png)

[é¢˜è§£ï¼šçµèŒ¶å±±è‰¾åºœ](https://www.bilibili.com/video/BV1sd4y1x7KN/?vd_source=7369d5f08520f2fc3601caee93963ffa)

![image-20250816223459245](./pic/image-20250816223459245.png)

![image-20250816223530333](./pic/image-20250816223530333.png)

![image-20250707112411008](pic/image-20250707112411008.png)

~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {

        // ç»Ÿè®¡èŠ‚ç‚¹ä¸ªæ•°
        int n = 0;
        ListNode* node = head;
        while (node)
        {
            n++;
            node = node->next;
        }
        
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        
        ListNode* p0 = dummyHead; // p0 ä½œä¸º [ä¸‹ä¸€ç»„è¦åè½¬çš„kä¸ªèŠ‚ç‚¹çš„] ä¸Šä¸€ä¸ªèŠ‚ç‚¹
        ListNode* pre = nullptr;
        ListNode* cur = head;

        // å‰©ä½™èŠ‚ç‚¹è¶³å¤Ÿ k ä¸ª
        while (n >= k)
        {
            // k ä¸ªä¸€ç»„å¤„ç†
            for (int i = 0; i < k; i++) // 206 æ™®é€šåè½¬é“¾è¡¨
            {
                ListNode* tmp = cur->next;
                cur->next = pre;
                pre = cur;
                cur = tmp;
            }

            // è¿æ¥å¤´å°¾
            ListNode* nxt = p0->next;
            p0->next->next = cur;
            p0->next = pre;
            p0 = nxt; // æ›´æ–°p0

            // n æ›´æ–°
            n -= k;
            
            pre = nullptr; // å¯ä»¥ä¸é‡ç½®ï¼Œé‡ç½®å¥½ç†è§£ä¸€äº›
        }

        return dummyHead->next;

    }
};
~~~

- æ—¶é—´å¤æ‚åº¦ï¼šO(*n*)ï¼Œå…¶ä¸­ *n* ä¸ºé“¾è¡¨èŠ‚ç‚¹ä¸ªæ•°ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ï¼Œä»…ç”¨åˆ°è‹¥å¹²é¢å¤–å˜é‡ã€‚



ACM

~~~C++
#include <iostream>
using namespace std;

// 25 kä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨
// æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œå…¶ä¸­ n ä¸ºé“¾è¡¨èŠ‚ç‚¹ä¸ªæ•°ã€‚
// ç©ºé—´å¤æ‚åº¦ï¼šO(1)ï¼Œä»…ç”¨åˆ°è‹¥å¹²é¢å¤–å˜é‡ã€‚

struct ListNode
{
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};


ListNode* reverseKGroup(ListNode* head, int k)
{
    // ç»Ÿè®¡é“¾è¡¨é•¿åº¦
    int n = 0;
    ListNode* node = head;
    while (node)
    {
        n++;
        node = node->next;
    }

    ListNode* dummyHead = new ListNode(0);
    dummyHead->next = head;

    ListNode* p0 = dummyHead; // p0 ä½œä¸º [ä¸‹ä¸€ç»„è¦åè½¬çš„kä¸ªèŠ‚ç‚¹çš„] ä¸Šä¸€ä¸ªèŠ‚ç‚¹
    ListNode* pre = nullptr;
    ListNode* cur = head;

    while (n >= k)
    {
        // åè½¬å½“å‰è¿™kä¸ªèŠ‚ç‚¹
        for (int i = 0; i < k; i++)
        {
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }

        // è¿æ¥å‰å
        ListNode* nxt = p0->next;
        p0->next->next = cur;
        p0->next = pre;
        p0 = nxt; // æ›´æ–°p0

        // æ›´æ–° n
        n -= k;

        pre = nullptr; // å¯ä»¥ä¸é‡ç½®ï¼Œé‡ç½®å¥½ç†è§£ä¸€äº›
    
    }

    return dummyHead->next;
}


int main()
{
    // æ„å»ºé“¾è¡¨: 1 -> 2 -> 3 -> 4 -> 5
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    int k = 2;

    // æ‰§è¡ŒKä¸ªä¸€ç»„ç¿»è½¬
    ListNode* newHead = reverseKGroup(head, k);

    // è¾“å‡ºç»“æœé“¾è¡¨
    while (newHead) {
        cout << newHead->val << " ";
        newHead = newHead->next;
    }
    cout << endl;


    return 0;
}
~~~

è¾“å‡ºï¼š

~~~C++
2 1 4 3 5 
~~~





## [138 éšæœºé“¾è¡¨çš„å¤åˆ¶](https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250708100725736](pic/image-20250708100725736.png)

[é¢˜è§£ï¼šKrahets](https://leetcode.cn/problems/copy-list-with-random-pointer/solutions/2361362/138-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-b-6jeo/?envType=study-plan-v2&envId=top-100-liked)

### 1ã€å“ˆå¸Œ <åŸèŠ‚ç‚¹ï¼Œæ–°èŠ‚ç‚¹>

![image-20250708110857618](pic/image-20250708110857618.png)



<img src="pic/image-20250708110826487.png" alt="image-20250708110826487" style="zoom: 50%;" />

<img src="pic/image-20250708110844541.png" alt="image-20250708110844541" style="zoom:50%;" />

~~~C++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;  // random_indexï¼šéšæœºæŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹ç´¢å¼•
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) {

        if (head == nullptr)    return nullptr;

        Node* cur = head;
        unordered_map<Node*, Node*> umap; // <åŸèŠ‚ç‚¹ï¼Œæ–°èŠ‚ç‚¹>

        // å¤åˆ¶å„èŠ‚ç‚¹ï¼Œå¹¶å»ºç«‹ â€œåŸèŠ‚ç‚¹ -> æ–°èŠ‚ç‚¹â€ çš„ Map æ˜ å°„
        while (cur)
        {
            umap[cur] = new Node(cur->val);
            cur = cur->next;
        }

        // æ„å»ºæ–°é“¾è¡¨çš„ next å’Œ random æŒ‡å‘
        cur = head;
        while (cur)
        {
            umap[cur]->next = umap[cur->next];
            umap[cur]->random = umap[cur->random];
            cur = cur->next;
        }

        // æ–°çš„å¤´ç»“ç‚¹
        return umap[head];
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ O(N) ï¼š ä¸¤è½®éå†é“¾è¡¨ï¼Œä½¿ç”¨ O(N) æ—¶é—´ã€‚

ç©ºé—´å¤æ‚åº¦ O(N) ï¼š å“ˆå¸Œè¡¨ dic ä½¿ç”¨çº¿æ€§å¤§å°çš„é¢å¤–ç©ºé—´ã€‚



### 2ã€æ‹¼æ¥ + æ‹†åˆ†

![image-20250708111135198](pic/image-20250708111135198.png)

<img src="pic/image-20250708111154694.png" alt="image-20250708111154694" style="zoom:50%;" />



~~~C++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;  // random_indexï¼šéšæœºæŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹ç´¢å¼•
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) {

        if (head == nullptr)    return nullptr;

        // æ‹¼æ¥é“¾è¡¨ åŸèŠ‚ç‚¹ 1 -> æ–°èŠ‚ç‚¹ 1 -> åŸèŠ‚ç‚¹ 2 -> æ–°èŠ‚ç‚¹ 2 -> â€¦â€¦
        Node* cur = head;
        while (cur)
        {
            Node* tmp = new Node(cur->val);
            tmp->next = cur->next;
            cur->next = tmp;

            cur = tmp->next;
        }

        // æ„å»ºå„æ–°èŠ‚ç‚¹çš„ random æŒ‡å‘
        cur = head;
        while (cur)
        {
            if (cur->random)
            {
                // æ–°èŠ‚ç‚¹random = åŸèŠ‚ç‚¹random->next
                cur->next->random = cur->random->next;
            }
            cur = cur->next->next; 
        }

        // æ‹†åˆ†
        Node* pre = head;
        Node* nhead = head->next;
        cur = nhead;
        while (cur->next)
        {
            pre->next = pre->next->next;
            cur->next = cur->next->next;
            pre = pre->next;
            cur = cur->next;
        }

        pre->next = nullptr; // å•ç‹¬å¤„ç†åŸé“¾è¡¨å°¾èŠ‚ç‚¹
        return nhead;
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ O(N) ï¼š ä¸‰è½®éå†é“¾è¡¨ï¼Œä½¿ç”¨ O(N) æ—¶é—´ã€‚
ç©ºé—´å¤æ‚åº¦ O(1) ï¼š èŠ‚ç‚¹å¼•ç”¨å˜é‡ä½¿ç”¨å¸¸æ•°å¤§å°çš„é¢å¤–ç©ºé—´ã€‚



### ACM

~~~C++
#include <iostream>
#include <unordered_map>
using namespace std;

// é“¾è¡¨èŠ‚ç‚¹å®šä¹‰
struct Node {
    int val;
    Node* next;
    Node* random; // random_indexï¼šéšæœºæŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹ç´¢å¼•

    Node(int _val) : val(_val), next(nullptr), random(nullptr) {}
};


Node* copyRandomList(Node* head)
{
    if (head == nullptr)    return nullptr;

    // umap <åŸèŠ‚ç‚¹ï¼Œæ–°èŠ‚ç‚¹>
    unordered_map<Node*, Node*> umap;
    Node* cur = head;
    while (cur)
    {
        umap[cur] = new Node(cur->val);
        cur = cur->next;
    }

    // å¤åˆ¶ next å’Œ random æŒ‡é’ˆ
    cur = head;
    while (cur)
    {
        umap[cur]->next = umap[cur->next];
        umap[cur]->random = umap[cur->random];
        cur = cur->next;
    }

    return umap[head];
}


int main()
{
    // æ„å»ºé“¾è¡¨: 1 -> 2 -> 3
    Node* node1 = new Node(1);
    Node* node2 = new Node(2);
    Node* node3 = new Node(3);
    node1->next = node2;
    node2->next = node3;

    // è®¾ç½® random æŒ‡é’ˆ
    node1->random = node3; // 1->random->3
    node2->random = node1; // 2->random->1
    node3->random = node2; // 3->random->2

    Node* copiedHead = copyRandomList(node1);


    // æ‰“å°ç»“æœï¼ˆval å’Œ random->valï¼‰
    Node* p = copiedHead;
    while (p) 
    {
        cout << "val: " << p->val;
        if (p->random)
        {
            cout << ", random: " << p->random->val << endl;
        }
        else
        {
            cout << ", random: NULL" << endl;
        }
        p = p->next;
    }

    return 0;
}
~~~

è¾“å‡ºï¼š

~~~C++
val: 1, random: 3
val: 2, random: 1
val: 3, random: 2
~~~





## 148 [æ’åºé“¾è¡¨](https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250709102737022](pic/image-20250709102737022.png)

çµç¥é¢˜è§£ï¼š[ä¸¤ç§æ–¹æ³•ï¼šåˆ†æ²»/è¿­ä»£ï¼Œæ¨¡å—åŒ–è®¾è®¡ï¼Œä»£ç å¯è¯»æ€§é«˜ï¼ˆPython/Java/C++/C/Go/JS/Rustï¼‰](https://leetcode.cn/problems/sort-list/solutions/2993518/liang-chong-fang-fa-fen-zhi-die-dai-mo-k-caei/?envType=study-plan-v2&envId=top-100-liked)



### 1ã€å½’å¹¶æ’åº-åˆ†æ²»é€’å½’

æ¨è

![image-20250709110109200](pic/image-20250709110109200.png)

~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 876. æ‰¾é“¾è¡¨ä¸­é—´èŠ‚ç‚¹æ–­å¼€ï¼ˆå¿«æ…¢æŒ‡é’ˆï¼‰
    ListNode* middleNode(ListNode* head)
    {
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next && fast->next->next)
        {
            slow = slow->next;// ä¸­é—´èŠ‚ç‚¹çš„å‰ä¸€ä¸ª
            fast = fast->next->next;
        }

        ListNode* mid = slow->next;
        slow->next = nullptr; // æ–­å¼€
        return mid;
    }

    // 21 åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ï¼ˆå¿«æ…¢æŒ‡é’ˆï¼‰
    ListNode* mergerTwoLists(ListNode* list1, ListNode* list2)
    {
        ListNode* dummy = new ListNode(0);
        ListNode* cur = dummy;
        while (list1 && list2)
        {
            if (list1->val < list2->val)
            {
                cur->next = list1;
                list1 = list1->next;
            }
            else
            {
                cur->next = list2;
                list2 = list2->next;
            }

            cur = cur->next;
        }

        cur->next = (list1 != nullptr) ? list1 : list2;
        return dummy->next;
    }



    ListNode* sortList(ListNode* head) {

        if (head == nullptr || head->next == nullptr)   return head;

        // æ‰¾ä¸­ç‚¹æ–­å¼€
        // æ¯”å¦‚ head=[4,2,1,3]ï¼Œé‚£ä¹ˆ middleNode è°ƒç”¨ç»“æŸå head=[4,2] head2=[1,3]
        ListNode* head2 = middleNode(head);

        // åˆ†æ²» é€’å½’ åˆ†åˆ«æ’åº headå’Œhead2
        head = sortList(head);
        head2 = sortList(head2);
        
        // åˆå¹¶
        return mergerTwoLists(head, head2);
       
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)ï¼Œå…¶ä¸­ n æ˜¯é“¾è¡¨é•¿åº¦ã€‚é€’å½’å¼ T(n)=2T(n/2)+O(n)ï¼Œç”±ä¸»å®šç†å¯å¾—æ—¶é—´å¤æ‚åº¦ä¸º O(nlogn)ã€‚
ç©ºé—´å¤æ‚åº¦ï¼šO(logn)ã€‚é€’å½’éœ€è¦ O(logn) çš„æ ˆå¼€é”€ã€‚





### 2ã€å½’å¹¶æ’åº-è¿­ä»£

![image-20250709113112996](pic/image-20250709113112996.png)

ä¸¤ä¸¤åˆå¹¶ï¼Œå››å››åˆå¹¶ï¼Œå…«å…«åˆå¹¶â€¦â€¦

**ç”»å›¾å§**



~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // è·å–é“¾è¡¨é•¿åº¦
    int getLength(ListNode* head)
    {
        int length = 0;
        while (head)
        {
            length++;
            head = head->next;
        }
        return length;
    }

    // åˆ†å‰²é“¾è¡¨ï¼Œåˆ†å‰²å‰sizeä¸ªï¼Œè¿”å›å‰©ä½™é“¾è¡¨çš„å¤´ç»“ç‚¹
    ListNode* splitList(ListNode* head, int size)
    {
        ListNode* cur = head;

        // curèµ°sizeæ­¥ï¼Œåœåœ¨å‰sizeä¸ªèŠ‚ç‚¹çš„æœ€åä¸€ä¸ª
        for (int i = 0; i < size - 1 && cur; i++)   cur = cur->next;

        // é“¾è¡¨é•¿åº¦ <= size, ä¸æ“ä½œï¼Œè¿”å›null
        if (cur == nullptr || cur->next == nullptr) return nullptr;

        // é“¾è¡¨é•¿åº¦ >  sizeï¼ŒæŠŠé“¾è¡¨çš„å‰sizeä¸ªèŠ‚ç‚¹åˆ†å‰²å‡ºæ¥ï¼ˆæ–­å¼€ï¼‰ï¼Œè¿”å›å‰©ä½™é“¾è¡¨çš„å¤´ç»“ç‚¹
        ListNode* next_head = cur->next;
        cur->next = nullptr; // æ–­å¼€

        return next_head; 
    }

    
    // 21.åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ï¼Œè¿”å›åˆå¹¶åçš„ <å¤´ç»“ç‚¹ï¼Œå°¾èŠ‚ç‚¹>
    pair<ListNode*, ListNode*> mergeTwoLists(ListNode* l1, ListNode* l2)
    {
        ListNode* dummy = new ListNode(0);
        ListNode* cur = dummy;
        while (l1 && l2)
        {
            if (l1->val < l2->val)
            {
                cur->next = l1;
                l1 = l1->next;
            }
            else 
            {
                cur->next = l2;
                l2 = l2->next;
            }
            cur = cur->next;
        }
        cur->next = l1 ? l1 : l2;

        while (cur->next)   cur = cur->next; // ç§»åŠ¨curåˆ°å°¾èŠ‚ç‚¹
        return {dummy->next, cur}; // è¿”å›åˆå¹¶åçš„ <å¤´ç»“ç‚¹ï¼Œå°¾èŠ‚ç‚¹>
    }


    ListNode* sortList(ListNode* head) {

        int length = getLength(head);

        ListNode* dummy = new ListNode(0);
        dummy->next = head;

        // step ä¸ºæ­¥é•¿ï¼Œå³å‚ä¸åˆå¹¶çš„é“¾è¡¨é•¿åº¦ï¼Œstep = 1, 2, 4, 8, ...
        for (int step = 1; step < length; step *= 2)
        {
            // ä» step = 1 å¼€å§‹ï¼šstep = 1, 2, 4, 8, ...
            // æ¯2ä¸ªã€1èŠ‚ç‚¹ã€‘ä¸€ç»„åˆå¹¶ï¼Œåˆ°æ¯2ä¸ªã€2èŠ‚ç‚¹ã€‘ä¸€ç»„åˆå¹¶ï¼Œå†åˆ°æ¯2ä¸ªã€4èŠ‚ç‚¹ã€‘...

            ListNode* new_list_tail = dummy; // æ–°é“¾è¡¨çš„æœ«å°¾
            ListNode* cur = dummy->next;

            // é“¾è¡¨æ¯2ä¸ªstepé•¿çš„éƒ¨åˆ†ï¼Œåˆ†åˆ«åˆå¹¶ï¼Œå†æ‹¼æ¥ï¼Œç›´åˆ°cur=null
            while (cur) 
            {
                // ä»curå¼€å§‹ï¼Œåˆ†å‰²å‡ºä¸¤æ®µé•¿ä¸ºstepçš„é“¾è¡¨
                ListNode* head1 = cur;
                ListNode* head2 = splitList(head1, step);
                cur = splitList(head2, step); // ä¸‹ä¸€è½®å¾ªç¯çš„èµ·ç‚¹ï¼Œhead2ä¹Ÿæ–­å¼€äº†

                // åˆå¹¶ä¸¤æ®µé•¿ä¸ºstepçš„é“¾è¡¨
                auto [merge_head, merge_tail] = mergeTwoLists(head1, head2);

                // åˆå¹¶åçš„å¤´ç»“ç‚¹headï¼Œæ¥åˆ°new_list_tailçš„åé¢ï¼Œæ›´æ–°æœ«å°¾
                new_list_tail->next = merge_head; 
                new_list_tail = merge_tail;
            }

            // cur == nullptrï¼Œstep = 2 * stepï¼Œå¼€å§‹ä¸‹ä¸€è½®åˆå¹¶            
        }
        

        return dummy->next;
    }
};
~~~

- æ—¶é—´å¤æ‚åº¦ï¼šO(*n*log*n*)ï¼Œå…¶ä¸­ *n* æ˜¯é“¾è¡¨é•¿åº¦ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ã€‚



### ACM

~~~C++
#include <iostream>
using namespace std;

// 148 æ’åºé“¾è¡¨
// æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)
// ç©ºé—´å¤æ‚åº¦ï¼šO(logn)


struct ListNode 
{
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};



// æ‰¾é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹å¹¶æ–­å¼€ï¼Œè¿”å›åä¸€åŠçš„å¤´èŠ‚ç‚¹
ListNode* middleNode(ListNode* head) 
{
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast->next && fast->next->next) 
    {
        slow = slow->next;
        fast = fast->next->next;
    }

    ListNode* mid = slow->next;
    slow->next = nullptr; // æ–­å¼€å‰åŠéƒ¨åˆ†
    return mid;
}

// åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨
ListNode* mergerTwoLists(ListNode* list1, ListNode* list2) 
{
    ListNode* dummy = new ListNode(0);
    ListNode* cur = dummy;
    while (list1 && list2) 
    {
        if (list1->val < list2->val) 
        {
            cur->next = list1;
            list1 = list1->next;
        } 
        else 
        {
            cur->next = list2;
            list2 = list2->next;
        }
        cur = cur->next;
    }

    cur->next = list1 ? list1 : list2;
    return dummy->next;
}


// æ’åºé“¾è¡¨
ListNode* sortList(ListNode* head) 
{
    if (!head || !head->next) return head;

    ListNode* head2 = middleNode(head);
    head = sortList(head);
    head2 = sortList(head2);

    return mergerTwoLists(head, head2);
}


int main() 
{
    // æ„å»ºé“¾è¡¨ï¼š4 -> 2 -> 1 -> 3
    ListNode* head = new ListNode(4);
    head->next = new ListNode(2);
    head->next->next = new ListNode(1);
    head->next->next->next = new ListNode(3);

    // æ’åº
    head = sortList(head);

    // è¾“å‡ºç»“æœ
    while (head) 
    {
        cout << head->val << " ";
        head = head->next;
    }
    cout << endl;

    return 0;
}

~~~

è¾“å‡ºï¼š

~~~C++
1 2 3 4 
~~~





## 23 [åˆå¹¶Kä¸ªå‡åºé“¾è¡¨](https://leetcode.cn/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked)

@æœ€å°å †

![image-20250710124249246](pic/image-20250710124249246.png)

### 1ã€æœ€å°å †ï¼ˆæ¨èï¼‰

![image-20250710124255992](pic/image-20250710124255992.png)

![image-20250710124303307](pic/image-20250710124303307.png)

<img src="pic/image-20250710113320140.png" alt="image-20250710113320140" style="zoom:40%;" />

<img src="pic/image-20250710113342369.png" alt="image-20250710113342369" style="zoom:40%;" />



~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {

        auto cmp = [](const ListNode* a, const ListNode* b)
        {
            return a->val > b->val; // æœ€å°å †
            
            // å¦‚æœ cmp(a, b) ä¸º trueï¼Œåˆ™è®¤ä¸º a çš„ä¼˜å…ˆçº§ä½äº bï¼Œæ‰€ä»¥ a ä¼šåœ¨ b çš„åé¢ã€‚
            // return a->val > b->val; å³å¤§çš„æ•°æ’åœ¨åé¢ï¼Œå°çš„åœ¨å‰
        };

        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq;
        for (auto head : lists)
        {
            if (head)   pq.push(head); // å…ˆæŠŠæ‰€æœ‰éç©ºé“¾è¡¨çš„å¤´èŠ‚ç‚¹å…¥å †
        }
        

        ListNode* dummy = new ListNode(0);// å“¨å…µèŠ‚ç‚¹ï¼Œä½œä¸ºåˆå¹¶åé“¾è¡¨å¤´ç»“ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
        ListNode* cur = dummy;
        
        while (!pq.empty()) // å¾ªç¯ç›´åˆ°å †ä¸ºç©º
        {
            auto node = pq.top(); // å¼¹å‡ºå‰©ä½™èŠ‚ç‚¹ä¸­çš„æœ€å°èŠ‚ç‚¹
            pq.pop();
            
            if (node->next) // å¦‚æœä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ä¸ºç©ºï¼Œæœ‰å¯èƒ½æ˜¯æœ€å°èŠ‚ç‚¹ï¼Œå…¥å †è‡ªåŠ¨æ’åº
            {
                pq.push(node->next); 
            }

            cur->next = node; // nodeæ·»åŠ åˆ°æ–°é“¾è¡¨çš„æœ«å°¾
            cur = cur->next;  // å‡†å¤‡åˆå¹¶ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        }

        return dummy->next;
    }
};
~~~

- æ—¶é—´å¤æ‚åº¦ï¼šO(*L*log*m*)ï¼Œå…¶ä¸­ *m* ä¸º *lists* çš„é•¿åº¦ï¼Œ*L* ä¸ºæ‰€æœ‰é“¾è¡¨çš„é•¿åº¦ä¹‹å’Œã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šO(*m*)ã€‚å †ä¸­è‡³å¤šæœ‰ *m* ä¸ªå…ƒç´ ã€‚



##### å°é¡¶å †

~~~C++
auto cmp = [](const ListNode* a, const ListNode* b) {
    return a->val > b->val;  // å°çš„ä¼˜å…ˆ
};
~~~

`cmp` æ˜¯ä¸€ä¸ª lambdaè¡¨è¾¾å¼ï¼Œå®ƒæ¥å—ä¸¤ä¸ª `ListNode*` ç±»å‹çš„å‚æ•° `a` å’Œ `b`ã€‚

è¿”å› `a->val > b->val`ï¼Œæ„æ€æ˜¯ï¼š

> åœ¨ C++ STL çš„ `priority_queue` ä¸­ï¼Œ**æ¯”è¾ƒå‡½æ•° `cmp(a, b)` çš„è¯­ä¹‰æ˜¯**ï¼š
>
> â€‹	â€œ å¦‚æœ `cmp(a, b)` ä¸º `true`ï¼Œåˆ™è®¤ä¸º `a` çš„ä¼˜å…ˆçº§**ä½äº** `b`ï¼Œæ‰€ä»¥ `a` ä¼šåœ¨ `b` çš„**åé¢**ã€‚â€
>
> æ‰€ä»¥ `return a > b;` è¡¨ç¤º `a > b`æ—¶ï¼Œè¿”å›trueï¼Œå¤§çš„æ•°åœ¨åé¢ï¼Œå°çš„æ•°åœ¨å‰ï¼ˆtopï¼‰ã€‚



å¯¹äºè‡ªå®šä¹‰ç±»å‹å¦‚ `ListNode*`ï¼Œæˆ‘ä»¬ç”¨ lambda æ¥å®šåˆ¶æ¯”è¾ƒé€»è¾‘ï¼š

~~~C++
priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);
~~~

å½“ä½ å‘ `pq` æ’å…¥å¤šä¸ª `ListNode*` æ—¶ï¼Œå®ƒä¼šæ ¹æ® `cmp(a, b)` çš„å€¼æ¥ç»´æŠ¤å †åºï¼š

- è‹¥ `a->val > b->val` è¿”å› `true` â†’ `a` æ¯” `b` ä¼˜å…ˆçº§ä½ï¼ˆ `a` åº”è¯¥åœ¨åï¼Œå³å¤§çš„èŠ‚ç‚¹åœ¨åï¼‰
- æœ€ç»ˆå †é¡¶å°±æ˜¯ **å½“å‰æœ€å°çš„èŠ‚ç‚¹**



##### dummy èŠ‚ç‚¹çš„åˆ›å»º

~~~C++
ListNode dummy{};           // å“¨å…µèŠ‚ç‚¹ï¼Œä½œä¸ºåˆå¹¶åé“¾è¡¨å¤´ç»“ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
auto cur = &dummy;        // æŒ‡é’ˆ cur æŒ‡å‘ dummy 
~~~

`{}`ï¼šè¿™æ˜¯ C++11 å¼•å…¥çš„å€¼åˆå§‹åŒ–è¯­æ³•ï¼Œè¡¨ç¤ºå°†æŒ‡é’ˆåˆå§‹åŒ–ä¸º `nullptr`ï¼ˆç©ºæŒ‡é’ˆï¼‰ã€‚

| å†™æ³•              | è¯´æ˜                                                         |
| ----------------- | ------------------------------------------------------------ |
| `ListNode dummy;` | åˆ›å»ºäº†ä¸€ä¸ªå®é™…çš„ **`ListNode` å®ä¾‹**ï¼ˆé»˜è®¤å€¼ä¸º0, nullptrï¼‰ âœ…<br />`dummy` æ˜¯ä¸€ä¸ªå®é™…å­˜åœ¨äº**æ ˆä¸Š**çš„ `ListNode` å®ä¾‹<br />è®¿é—®ï¼š`dummy.next`  `dummy.val` |



å’Œå¸¸è§å†™æ³•çš„åŒºåˆ«ï¼š

~~~C++
ListNode* dummy = new ListNode(0); // ä½¿ç”¨ new åœ¨å †ä¸Šåˆ›å»ºäº†ä¸€ä¸ªå€¼ä¸º 0 çš„ ListNode èŠ‚ç‚¹
ListNode* cur = dummy;
~~~

`ListNode* dummy`ï¼šå£°æ˜ä¸€ä¸ª**æŒ‡é’ˆå˜é‡ `dummy`ï¼Œç±»å‹æ˜¯ `ListNode*`**ï¼Œå³æŒ‡å‘ `ListNode` ç±»å‹çš„æŒ‡é’ˆã€‚

åŠŸèƒ½ç­‰ä»·ï¼š**é€»è¾‘ä¸Šç­‰ä»·**

- ä¸¤è€…æœ€ç»ˆç›®çš„å®Œå…¨ä¸€è‡´ï¼šä½¿ç”¨ä¸€ä¸ªâ€œå“¨å…µèŠ‚ç‚¹â€ä½œä¸ºåˆå¹¶åé“¾è¡¨çš„èµ·ç‚¹ï¼ˆå ä½å¤´ç»“ç‚¹ï¼‰ï¼Œä¾¿äºæ„é€ å’Œè¿”å›ã€‚
- åç»­éƒ½æ˜¯æ“ä½œ `cur` æŒ‡é’ˆï¼Œæ— è®ºå®ƒæŒ‡å‘æ ˆä¸Šçš„ `dummy` è¿˜æ˜¯å †ä¸Šçš„ `*dummy`ï¼Œé€»è¾‘æ— å·®åˆ«ã€‚

ä½†**è¯­ä¹‰å’Œå†…å­˜ç®¡ç†ä¸Šä¸å®Œå…¨ç­‰ä»·**ï¼š

| å†™æ³•                                 | å­˜å‚¨ä½ç½® | æ˜¯å¦éœ€è¦æ‰‹åŠ¨é‡Šæ”¾      | æ˜¯å¦æ›´æ¨è   |
| ------------------------------------ | -------- | --------------------- | ------------ |
| `ListNode dummy;`                    | æ ˆå†…å­˜   | âŒ ä¸éœ€è¦              | âœ… æ¨è       |
| `ListNode* dummy = new ListNode(0);` | å †å†…å­˜   | âœ… éœ€è¦ `delete dummy` | âš ï¸ æ˜“å†…å­˜æ³„æ¼ |

å¦‚æœä½ æ˜¯åœ¨å‡½æ•°ä½“å†…éƒ¨æ„é€ é“¾è¡¨ï¼Œä¸è·¨ä½œç”¨åŸŸã€ä¸éœ€è¦å…±äº«é“¾è¡¨å¤´ï¼Œæ¨èä½¿ç”¨ **æ ˆä¸Š dummy èŠ‚ç‚¹å†™æ³•**ï¼š

```
ListNode dummy;
ListNode* cur = &dummy;
```

æ›´å®‰å…¨ï¼Œä¸éœ€è¦è€ƒè™‘ `delete`ï¼Œä¸ä¼šé€ æˆå†…å­˜æ³„æ¼ï¼Œè¯­ä¹‰æ¸…æ™°ã€‚





### 2ã€åˆ†æ²»é€’å½’

![image-20250711110632667](pic/image-20250711110632667.png)

~~~C++
class Solution {
public:

    // 21 åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨(å‡åº)
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2)
    {
        ListNode* dummy = new ListNode(0);
        ListNode* cur = dummy;
        while (list1 && list2)
        {
            if (list1->val < list2->val)  
            {
                cur->next = list1;
                list1 = list1->next;
            }
            else
            {
                cur->next = list2;
                list2 = list2->next;
            }

            cur = cur->next;
        }

        cur->next = list1 ? list1 :  list2;
        return dummy->next;
    }


    // åˆå¹¶ä» lists[i] åˆ° lists[j-1] çš„é“¾è¡¨ï¼Œå·¦é—­å³å¼€
    ListNode* mergeRange(vector<ListNode*>& lists, int i, int j) 
    {
        int m = j - i; // [i, j)
        if (m == 0) return nullptr;  // è¾“å…¥çš„ lists å¯èƒ½æ˜¯ç©ºçš„
        if (m == 1) return lists[i]; // æ— éœ€åˆå¹¶ï¼Œç›´æ¥è¿”å›
        
        auto left  = mergeRange(lists, i, i + m / 2); // é€’å½’åˆå¹¶å·¦åŠéƒ¨åˆ†
        auto right = mergeRange(lists, i + m / 2, j); // é€’å½’åˆå¹¶å³åŠéƒ¨åˆ†

        return mergeTwoLists(left, right); // æœ€åæŠŠå·¦å’Œå³ä¸¤åŠåˆå¹¶
    }



    ListNode* mergeKLists(vector<ListNode*>& lists) {

        return mergeRange(lists, 0, lists.size()); // é€’å½’åˆå¹¶
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ï¼šO(Llogm)

- å…¶ä¸­ m ä¸º lists çš„é•¿åº¦ï¼ŒL ä¸ºæ‰€æœ‰é“¾è¡¨çš„é•¿åº¦ä¹‹å’Œã€‚æ¯ä¸ªèŠ‚ç‚¹å‚ä¸é“¾è¡¨åˆå¹¶çš„æ¬¡æ•°ä¸º O(logm) æ¬¡ï¼Œä¸€å…±æœ‰ L ä¸ªèŠ‚ç‚¹ï¼Œæ‰€ä»¥æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º O(Llogm)ã€‚

ç©ºé—´å¤æ‚åº¦ï¼šO(logm)

- é€’å½’æ·±åº¦ä¸º O(logm)ï¼Œéœ€è¦ O(logm) çš„æ ˆç©ºé—´ã€‚Python å¿½ç•¥åˆ‡ç‰‡äº§ç”Ÿçš„é¢å¤–ç©ºé—´ã€‚





### ACM

~~~C++
#include <iostream>
#include <vector>
using namespace std;

// 23 åˆå¹¶kä¸ªæœ‰åºé“¾è¡¨
// æœ€å°å †ï¼š
//      æ—¶é—´å¤æ‚åº¦ï¼šO(Llogm)ï¼Œå…¶ä¸­ m ä¸º lists çš„é•¿åº¦ï¼ŒL ä¸ºæ‰€æœ‰é“¾è¡¨çš„é•¿åº¦ä¹‹å’Œã€‚
//      ç©ºé—´å¤æ‚åº¦ï¼šO(m)ã€‚å †ä¸­è‡³å¤šæœ‰ m ä¸ªå…ƒç´ 
// åˆ†æ²»é€’å½’ï¼š
//      æ—¶é—´å¤æ‚åº¦ï¼šO(Llogm)ï¼Œå…¶ä¸­ m ä¸º lists çš„é•¿åº¦ï¼ŒL ä¸ºæ‰€æœ‰é“¾è¡¨çš„é•¿åº¦ä¹‹å’Œã€‚
//      ç©ºé—´å¤æ‚åº¦ï¼šO(logm)ã€‚é€’å½’æ·±åº¦ä¸º O(logm)ï¼Œéœ€è¦ O(logm) çš„æ ˆç©ºé—´ã€‚


struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// 21 åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨(å‡åº)
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2)
{
    ListNode* dummy = new ListNode(0);
    ListNode* cur = dummy;
    while (list1 && list2)
    {
        if (list1->val < list2->val)  
        {
            cur->next = list1;
            list1 = list1->next;
        }
        else
        {
            cur->next = list2;
            list2 = list2->next;
        }

        cur = cur->next;
    }

    cur->next = list1 ? list1 :  list2;
    return dummy->next;
}

// åˆå¹¶ä» lists[i] åˆ° lists[j-1] çš„é“¾è¡¨
ListNode* mergeRange(vector<ListNode*>& lists, int i, int j) 
{
    int m = j - i; // [i, j)
    if (m == 0) return nullptr;  // è¾“å…¥çš„ lists å¯èƒ½æ˜¯ç©ºçš„
    if (m == 1) return lists[i]; // æ— éœ€åˆå¹¶ï¼Œç›´æ¥è¿”å›
    
    auto left  = mergeRange(lists, i, i + m / 2); // åˆå¹¶å·¦åŠéƒ¨åˆ†
    auto right = mergeRange(lists, i + m / 2, j); // åˆå¹¶å³åŠéƒ¨åˆ†

    return mergeTwoLists(left, right); // æœ€åæŠŠå·¦åŠå’Œå³åŠåˆå¹¶
}


// åˆå¹¶kä¸ªå‡åºé“¾è¡¨
ListNode* mergeKLists(vector<ListNode*>& lists) 
{
    return mergeRange(lists, 0, lists.size()); // é€’å½’åˆå¹¶
}


int main() 
{
    // æ„å»ºä¸‰ä¸ªæœ‰åºé“¾è¡¨
    ListNode* l1 = new ListNode(1); // 1->4->5
    l1->next = new ListNode(4);
    l1->next->next = new ListNode(5);

    ListNode* l2 = new ListNode(1); // 1->3->4
    l2->next = new ListNode(3);
    l2->next->next = new ListNode(4);

    ListNode* l3 = new ListNode(2); // 2->6
    l3->next = new ListNode(6);

    vector<ListNode*> lists = {l1, l2, l3};
    ListNode* merged = mergeKLists(lists); // åˆå¹¶

    while (merged)
    {
        cout << merged->val;
        if (merged->next)   cout << "->";
        merged = merged->next;
    }
    cout << endl;

    return 0;
}
~~~

è¾“å‡ºï¼š

~~~C++
1->1->2->3->4->4->5->6
~~~





## [146 LRUç¼“å­˜](https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250711161258116](pic/image-20250711161258116.png)

<img src="pic/image-20250711162032122.png" alt="image-20250711162032122" style="zoom:40%;" />

<img src="pic/image-20250711164304110.png" alt="image-20250711164304110" style="zoom:40%;" />



![image-20250711162359701](pic/image-20250711162359701.png)

~~~C++
// æ„é€ åŒå‘é“¾è¡¨ï¼ˆå­˜keyï¼Œvalueï¼Œå‰åå‘æŒ‡é’ˆï¼‰
// åˆ é™¤èŠ‚ç‚¹ remove() + æœ€ä¸Šé¢æ·»åŠ èŠ‚ç‚¹ push_front() + æŠ½å‡ºkeyèŠ‚ç‚¹ï¼Œç§»åˆ°å¤´éƒ¨ get_node()

class Node // æ„é€ åŒå‘é“¾è¡¨
{
public:
    int key;
    int value;
    Node* prev;
    Node* next;

    Node(int k = 0, int v = 0) : key(k), value(v) {}
};


class LRUCache {
private:
    int capacity;
    Node* dummy; 
    unordered_map<int, Node*> key_to_node; // <key, node>

    // åˆ é™¤ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆæŠ½å‡ºä¸€æœ¬ä¹¦ï¼‰
    void remove(Node* x)
    {
        x->prev->next = x->next;
        x->next->prev = x->prev; 
    }


    // æ’å…¥èŠ‚ç‚¹åˆ°é“¾è¡¨å¤´éƒ¨ï¼ˆdummyåé¢ï¼‰ï¼ˆæŠŠä¸€æœ¬ä¹¦æ”¾åœ¨æœ€ä¸Šé¢ï¼‰
    void push_front(Node* x)
    {
        x->prev = dummy;
        x->next = dummy->next;
        x->prev->next = x;
        x->next->prev = x;
    }


    // è·å– key å¯¹åº”çš„èŠ‚ç‚¹è¿”å›ï¼Œå¹¶ç§»åˆ°é“¾è¡¨å¤´éƒ¨ï¼ˆæŠ½å‡ºä¸€æœ¬ä¹¦æ”¾åœ¨æœ€ä¸Šé¢ï¼‰
    Node* get_node(int key)
    {
        auto it = key_to_node.find(key);

        // æ²¡æœ‰è¿™æœ¬ä¹¦
        if (it == key_to_node.end())    return nullptr; 

        // æœ‰è¿™æœ¬ä¹¦
        Node* node = it->second; 
        remove(node);     // æŠ½å‡ºè¿™æœ¬ä¹¦
        push_front(node); // æ”¾åœ¨æœ€ä¸Šé¢

        return node;
    }



public:
    LRUCache(int capacity) 
        : capacity(capacity), dummy(new Node())
    {
        dummy->prev = dummy;
        dummy->next = dummy;// åˆå§‹éƒ½æŒ‡å‘è‡ªå·±
    }
    

    int get(int key) {
        // å¦‚æœå…³é”®å­— key å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è¿”å›å…³é”®å­—çš„å€¼ï¼Œå¦åˆ™è¿”å› -1 
        Node* node = get_node(key);
        return node ? node->value : -1;
    }
    
    
    void put(int key, int value) {
        // å¦‚æœå…³é”®å­— key å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼ value 
        // å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™å‘ç¼“å­˜ä¸­æ’å…¥è¯¥ç»„ key-value 
        // å¦‚æœæ’å…¥æ“ä½œå¯¼è‡´å…³é”®å­—æ•°é‡è¶…è¿‡ capacity ï¼Œåˆ™åº”è¯¥ é€å‡º æœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—
        
        Node* node = get_node(key);// get_node ä¼šæŠŠå¯¹åº”èŠ‚ç‚¹ç§»åˆ°é“¾è¡¨å¤´éƒ¨
        // èŠ‚ç‚¹å­˜åœ¨ï¼Œæ›´æ–°valueï¼Œç§»åˆ°å¤´éƒ¨ï¼ˆæœ‰è¿™æœ¬ä¹¦ï¼‰
        if (node) 
        {
            node->value = value; 
            return;
        }

        // èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°èŠ‚ç‚¹æ’å…¥å¤´éƒ¨ï¼ˆæ–°ä¹¦ï¼‰
        Node* newnode = new Node(key, value);
        key_to_node[key] = newnode;
        push_front(newnode); 

        // èŠ‚ç‚¹æ’å…¥åï¼Œå®¹é‡çˆ†äº†ï¼Œç§»é™¤æœ€åèŠ‚ç‚¹ï¼ˆç§»é™¤æœ€ä¸‹é¢çš„ä¹¦ï¼‰
        if (key_to_node.size() > capacity) 
        {
            Node* back_node = dummy->prev; // ç¯å½¢åŒå‘é“¾è¡¨ï¼Œç›´æ¥æ‰¾åˆ°æœ€ä¸‹é¢èŠ‚ç‚¹
            
            key_to_node.erase(back_node->key); // mapä¸­åˆ é™¤ <key, back_node>
            remove(back_node); 				   // é“¾è¡¨åˆ é™¤èŠ‚ç‚¹
            
            delete back_node; // é‡Šæ”¾å†…å­˜
        }
    }
    
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
~~~

- æ—¶é—´å¤æ‚åº¦ï¼šæ‰€æœ‰æ“ä½œå‡ä¸º O(1)ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šO(min(*p*,*capacity*))ï¼Œå…¶ä¸­ *p* ä¸º put çš„è°ƒç”¨æ¬¡æ•°ã€‚



ACM

~~~C++
#include <iostream>
#include <unordered_map>
using namespace std;

// 146 LRUç¼“å­˜
// æ—¶é—´å¤æ‚åº¦ï¼šæ‰€æœ‰æ“ä½œå‡ä¸º O(1)
// ç©ºé—´å¤æ‚åº¦ï¼šO(min(p,capacity))ï¼Œå…¶ä¸­ p ä¸º put çš„è°ƒç”¨æ¬¡æ•°


// åŒå‘é“¾è¡¨ç»“æ„
class Node
{
public:
    int key;
    int value;
    Node* prev;
    Node* next;

    Node(int k = 0, int v = 0) : key(k), value(v), prev(nullptr), next(nullptr) {}
};


class LRUCache
{
private:
    int capacity; // å®¹é‡
    unordered_map<int, Node*> key_to_node; // <key, node>
    Node* dummy;


    // åˆ é™¤ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆæŠ½å‡ºä¸€æœ¬ä¹¦ï¼‰
    void removeNode(Node* x)
    {
        x->prev->next = x->next;
        x->next->prev = x->prev;
    }

    // æ’å…¥èŠ‚ç‚¹åˆ°é“¾è¡¨å¤´éƒ¨ï¼ˆdummyåé¢ï¼‰ï¼ˆæŠŠä¸€æœ¬ä¹¦æ”¾åœ¨æœ€ä¸Šé¢ï¼‰
    void push_front(Node* x)
    {
        x->prev = dummy;
        x->next = dummy->next;
        x->prev->next = x;
        x->next->prev = x;
    }

    // è·å– key èŠ‚ç‚¹è¿”å›ï¼Œå¹¶ç§»åŠ¨åˆ°å¤´éƒ¨ï¼ˆæŠ½å‡ºä¸€æœ¬ä¹¦æ”¾åœ¨æœ€ä¸Šé¢ï¼‰
    Node* get_node_push(int key)
    {
        auto it = key_to_node.find(key);

        if (it == key_to_node.end())   return nullptr;

        Node* node = it->second;
        removeNode(node);
        push_front(node);
        return node;
    }


public:
    LRUCache(int capacity) 
        : capacity(capacity), dummy(new Node()) // åˆå§‹åŒ–åˆ—è¡¨
    {
        dummy->prev = dummy;
        dummy->next = dummy;
    }


    // get() å¦‚æœå…³é”®å­— key å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è¿”å›å…³é”®å­—çš„å€¼ï¼Œå¦åˆ™è¿”å› -1 
    int get(int key)
    {
        Node* node = get_node_push(key);
        return node ? node->value : -1;
    }


    // å¦‚æœå…³é”®å­— key å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼ value 
    // å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™å‘ç¼“å­˜ä¸­æ’å…¥è¯¥ç»„ key-value 
    // å¦‚æœæ’å…¥æ“ä½œå¯¼è‡´å…³é”®å­—æ•°é‡è¶…è¿‡ capacity ï¼Œåˆ™åº”è¯¥ é€å‡º æœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—
    void put(int key, int value)
    {
        Node* node = get_node_push(key);

        // èŠ‚ç‚¹å­˜åœ¨
        if (node)
        {
            node->value = value;
            return;
        }

        // èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°èŠ‚ç‚¹æ’å…¥å¤´éƒ¨
        Node* new_node = new Node(key, value);
        push_front(new_node);
        key_to_node[key] = new_node;

        // èŠ‚ç‚¹æ’å…¥åï¼Œå®¹é‡çˆ†äº†ï¼Œç§»é™¤æœ€åèŠ‚ç‚¹
        if (key_to_node.size() > capacity)
        {
            Node* back_node = dummy->prev;
            key_to_node.erase(back_node->key); // åœ¨mapåˆ é™¤
            removeNode(back_node);             // åœ¨é“¾è¡¨åˆ é™¤

            delete back_node; // é‡Šæ”¾å†…å­˜
        }
    }

};


int main()
{
    LRUCache lru(2); // capacity = 2

    lru.put(1, 1); // {1=1}
    lru.put(2, 2); // {1=1, 2=2}

    cout << "get(1)" << lru.get(1) << endl; // è¾“å‡º1  {2=2ï¼Œ1=1}

    lru.put(3, 3); // è¶…å‡ºcapacityï¼Œæ·˜æ±°key=2  {1=1ï¼Œ3=3}

    cout << "get(2)" << lru.get(2) << endl; // è¾“å‡º-1

    lru.put(4, 4); // è¶…å‡ºcapacityï¼Œæ·˜æ±°key=1  {3=3, 4=4}
    
    cout << "get(1)" << lru.get(1) << endl; // è¾“å‡º-1
    cout << "get(3)" << lru.get(3) << endl; // è¾“å‡º 3
    cout << "get(4)" << lru.get(4) << endl; // è¾“å‡º 4


    return 0;
}
~~~





# äºŒå‰æ ‘ âœ…

## [94 ä¸­åºéå†](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250712105200783](pic/image-20250712105200783.png)



### é€’å½’

~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // é€’å½’
    void traversal(TreeNode* cur, vector<int>& vec)
    {
        if (cur == nullptr) return;

        traversal(cur->left, vec);  // å·¦
        vec.push_back(cur->val);    // ä¸­
        traversal(cur->right, vec); // å³
    }


    vector<int> inorderTraversal(TreeNode* root) {
        
        vector<int> result;
        traversal(root, result);

        return result;
        
    }
};
~~~





### è¿­ä»£

![image-20250713111238309](pic/image-20250713111238309.png)

ç”»å›¾å§ï¼ï¼ï¼

~~~C++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {

        vector<int> result;

        stack<TreeNode*> st;
        TreeNode* cur = root;

        while (cur || !st.empty())
        {
            if (cur)
            {
                // æŒ‡é’ˆæ¥è®¿é—®èŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹æ”¾å…¥æ ˆï¼Œå…ˆå·¦è¾¹ï¼Œä¸€ç›´åˆ°å·¦è¾¹æœ€åº•å±‚
                st.push(cur);
                cur = cur->left;
            }
            else // cur = nullptr èµ°åˆ°å·¦è¾¹æœ€ä½
            {
                cur = st.top(); // è¦å¤„ç†çš„èŠ‚ç‚¹
                st.pop();

                // å½“å‰èŠ‚ç‚¹å€¼æ”¾è¿›result
                result.push_back(cur->val); // ä¸­
                
                // è½¬å‘å½“å‰èŠ‚ç‚¹çš„å³èŠ‚ç‚¹
                cur = cur->right;           // å³
            }
        }

        return result;        
    }
};
~~~





### ACM

~~~C++
#include <iostream>
#include <vector>
using namespace std;

// 93 äºŒå‰æ ‘ä¸­åºéå†

// ç»“æ„æ ‘
struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// é€’å½’ä¸­åºéå† å·¦-ä¸­-å³
void inorderTraversal(TreeNode* cur, vector<int>& vec)
{
    if (!cur)   return;

    inorderTraversal(cur->left, vec);  // å·¦
    vec.push_back(cur->val);           // ä¸­
    inorderTraversal(cur->right, vec); // å³
}



int main()
{
    // æ„å»ºå¦‚ä¸‹äºŒå‰æ ‘ï¼š
    //           1
    //         /   \
    //        2     3
    //       / \     \
    //      4   5     8
    //         / \   /
    //        6   7 9

    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);

    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    root->left->right->left = new TreeNode(6);
    root->left->right->right = new TreeNode(7);

    root->right->right = new TreeNode(8);
    root->right->right->left = new TreeNode(9);

    vector<int> result;
    inorderTraversal(root, result); // 4 2 6 5 7 1 3 9 8

    // è¾“å‡º
    for (int val : result)
    {
        cout << val << " ";
    }
    cout << endl;


    return 0;
}

~~~





## [äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250714101413336](pic/image-20250714101413336.png)



### è‡ªåº•å‘ä¸Šï¼ˆé€’å½’ï¼‰

<img src="pic/image-20250717112431891.png" alt="image-20250717112431891" style="zoom:50%;" />

<img src="pic/image-20250717112517596.png" alt="image-20250717112517596" style="zoom:50%;" />

<img src="pic/image-20250717112627734.png" alt="image-20250717112627734" style="zoom:50%;" />



~~~C++
class Solution {
public:

    // é€’å½’ 
    int getdepth(TreeNode* node)
    {
        if (node == nullptr)    return 0;

        int leftdepth = getdepth(node->left); // å·¦
        int rightdepth = getdepth(node->right); // å³

        // å–å·¦å³å­æ ‘æ·±åº¦çš„æœ€å¤§å€¼ + 1
        int depth = max(leftdepth, rightdepth) + 1; // åŠ ä¸Šè‡ªå·±
        return depth;
    }


    int maxDepth(TreeNode* root) {
        return getdepth(root);
    }
};
~~~

ç²¾ç®€ï¼š

~~~C++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        // è‡ªåº•å‘ä¸Š
        if (!root)  return 0;
        return 1 + max(maxDepth(root->left), maxDepth(root->right));
    }
};
~~~



### è‡ªé¡¶å‘ä¸‹ï¼ˆé€’å½’ï¼‰

æŠŠç»è¿‡çš„èŠ‚ç‚¹æ•°ä¼ ä¸‹å»ï¼ˆä¹Ÿå°±æ˜¯æ·±åº¦ depthï¼‰ï¼Œå¾€ä¸‹èµ°ï¼Œ+1

~~~C++
class Solution {
public:
    int maxDepth(TreeNode* root) {

        // è‡ªé¡¶å‘ä¸‹
        int ans = 0;

        auto dfs = [&](this auto&& dfs, TreeNode* node, int depth)->void 
        {
            if (node == nullptr)     return;

            depth++; // ä»ä¸Šå¾€ä¸‹å¸¦å‚æ•°ï¼ˆèŠ‚ç‚¹æ•°ï¼‰
            
            ans = max(ans, depth); // æ¯å¾€ä¸‹èµ°ä¸€å±‚ï¼Œæ›´æ–°æ·±åº¦

            dfs(node->left, depth);
            dfs(node->right, depth);  
        };

        dfs(root, 0);
        return ans;        
    }
};
~~~

> è¿™é‡Œ `auto dfs = [&](this auto&& dfs, TreeNode* node, int depth)->void {}`ä¼ çš„æ˜¯ `int depth`ï¼Œ**å€¼ä¼ é€’ï¼Œè€Œä¸æ˜¯å¼•ç”¨ä¼ é€’ï¼Œä¸ºä»€ä¹ˆï¼Ÿ**
>
> å€¼ä¼ é€’ï¼š
>
> - æ¯æ¬¡ `dfs` è¢«è°ƒç”¨æ—¶ï¼Œ`depth` æ˜¯**ä¸€ä»½æ–°çš„å€¼**
>
> - `depth++` æ˜¯åœ¨å½“å‰è·¯å¾„ä¸­ä¿®æ”¹ï¼Œä¸å½±å“å…„å¼ŸèŠ‚ç‚¹ï¼›
>
> - ä¾‹å¦‚ `left` åˆ†æ”¯çš„é€’å½’ `depth++` åï¼Œ`right` åˆ†æ”¯ä»ç„¶æ˜¯åŸæ¥çš„ `depth+1`ï¼›
>
>   <img src="pic/image-20250723151754521.png" alt="image-20250723151754521" style="zoom:50%;" />
>
> å¼•ç”¨ä¼ é€’ï¼š
>
> - å¦‚æœæ”¹æˆå¼•ç”¨ä¼ é€’ï¼Œæ¯æ¬¡é€’å½’éƒ½æ˜¯å¯¹åŒä¸€ä¸ªå˜é‡ `depth` çš„å¼•ç”¨ï¼Œæ¯æ¬¡ `depth++`éƒ½ä¼šæ°¸ä¹…ä¿®æ”¹è¿™ä¸ªå˜é‡
>
>   <img src="pic/image-20250723152046755.png" alt="image-20250723152046755" style="zoom:50%;" />
>
> - å¼•ç”¨ä¼ é€’ä¼šè®©æ‰€æœ‰é€’å½’è·¯å¾„å…±äº«ä¸€ä¸ªå˜é‡ï¼Œä¸€æ—¦åœ¨æŸä¸€æ”¯ä¸­è¢«ä¿®æ”¹ï¼Œåç»­æ‰€æœ‰è·¯å¾„éƒ½ä¼šâ€œç»§æ‰¿â€è¿™ä¸ªå€¼ï¼Œæ— æ³•åæ˜ æ¯æ¡è·¯å¾„æœ¬åº”æœ‰çš„ç‹¬ç«‹æ·±åº¦ã€‚





### å±‚åº

æœ€å¤§æ·±åº¦ï¼Œå°±æ˜¯æœ€å¤§å±‚æ•°ï¼Œæ¯èµ°ä¸€å±‚æ·±åº¦ + 1

~~~C++	
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {

        if (root == nullptr)   return 0;
        int depth = 0;

        queue<TreeNode*> que;
        que.push(root);

        while (!que.empty())
        {
            int size = que.size();
            depth++; // æ¯èµ°ä¸€å±‚ï¼Œæ·±åº¦+1

            for (int i = 0; i < size; i++)
            {
                TreeNode* node = que.front();
                que.pop(); // æ±‚æ·±åº¦ï¼Œä¸ç”¨æ”¶é›†èŠ‚ç‚¹å€¼äº†

                if (node->left)     que.push(node->left);
                if (node->right)    que.push(node->right);
            }
        }

        return depth;        
    }
};
~~~



### ACM

~~~C++	
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

// 104 äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
// æ—¶é—´å¤æ‚åº¦ï¼šO(n)
// ç©ºé—´å¤æ‚åº¦ï¼šO(n)


struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


int maxDepth(TreeNode* root)
{
    if (!root)  return 0;

    queue<TreeNode*> que;
    que.push(root);

    int depth = 0;

    while (!que.empty())
    {
        int size = que.size();
        depth++;

        for (int i = 0; i < size; i++)
        {
            TreeNode* node = que.front();
            que.pop();
            if (node->left)     que.push(node->left);
            if (node->right)    que.push(node->right);
        }
    }

    return depth;
}



int main()
{
    TreeNode* root = new TreeNode(3);
    root->left = new TreeNode(9);
    root->right = new TreeNode(20);

    root->right->left = new TreeNode(15);
    root->right->right = new TreeNode(7);


    int depth = maxDepth(root); // 3
    cout << depth << endl;


    return 0;
}
~~~





## [226 ç¿»è½¬äºŒå‰æ ‘](https://leetcode.cn/problems/invert-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250715104054759](pic/image-20250715104054759.png)

![image-20250715104114171](pic/image-20250715104114171.png)

**æ³¨æ„äº¤æ¢çš„æ˜¯èŠ‚ç‚¹ï¼Œä¸æ˜¯å€¼**



### 1ã€é€’å½’ï¼ˆå‰åºï¼‰æ¨è

swap ç›´æ¥äº¤æ¢å½“å‰èŠ‚ç‚¹çš„å·¦å³å­æ ‘

~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {

        if (root == nullptr)    return root;

        // ç›´æ¥äº¤æ¢å½“å‰èŠ‚ç‚¹çš„å·¦å³å­æ ‘
        swap(root->left, root->right);  // ä¸­
        invertTree(root->left);         // å·¦
        invertTree(root->right);        // å³

        // äº¤æ¢å·¦å³è¯­å¥çš„é¡ºåºï¼Œå°±æ˜¯ååº

        return root;
    }
};
~~~



### 2ã€è¿­ä»£ï¼ˆå‰åºï¼‰

~~~C++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {

        // è¿­ä»£ å‰åº
        if (root == nullptr)    return root;

        stack<TreeNode*> st;
        st.push(root);
        while (!st.empty())
        {
            TreeNode* node = st.top();                // ä¸­
            st.pop();
            swap(node->left, node->right);

            if (node->right)    st.push(node->right); // å³
            if (node->left)     st.push(node->left);  // å·¦
        }

        return root;
    }
};
~~~



### 3ã€å±‚åº

~~~C++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {

        // å±‚åº
        queue<TreeNode*> que;
        if (root)  que.push(root);

        while (!que.empty())
        {
            int size = que.size();

            for (int i = 0; i < size; i++)
            {
                TreeNode* node = que.front();
                que.pop();
                swap(node->left, node->right); // äº¤æ¢

                if (node->left)     que.push(node->left);
                if (node->right)    que.push(node->right);
            }
        }

        return root;
    }
};
~~~



### ACM 

~~~C++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

// 226 åè½¬äºŒå‰æ ‘
// æ—¶é—´å¤æ‚åº¦ï¼š O(n)
// ç©ºé—´å¤æ‚åº¦ï¼š O(h)ï¼Œæœ€åæƒ…å†µä¸‹é€’å½’æ ˆæ·±åº¦ä¸ºæ ‘é«˜ hï¼Œæœ€å O(n)ï¼Œå¹³å‡ O(log n)ï¼ˆå¹³è¡¡æ ‘ï¼‰ã€‚

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


// é€’å½’ å‰åº
TreeNode* invertTree(TreeNode* root) 
{
    if (root == nullptr)    return root;

    swap(root->left, root->right);      // ä¸­
    invertTree(root->left);             // å·¦
    invertTree(root->right);            // å³

    return root;
}



// å±‚åºéå†ï¼ˆç”¨äºè¾“å‡ºï¼‰
vector<int> levelOrder(TreeNode* root) 
{
    vector<int> result;
    if (!root) return result;

    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        TreeNode* node = q.front(); 
        q.pop();
        result.push_back(node->val);

        if (node->left)  q.push(node->left);
        if (node->right) q.push(node->right);
    }

    return result;
}



int main()
{
    // æ„å»ºæµ‹è¯•æ ‘ç»“æ„
    TreeNode* root = new TreeNode(4);
    root->left = new TreeNode(2);
    root->right = new TreeNode(7);

    root->left->left = new TreeNode(1);
    root->left->right = new TreeNode(3);

    root->right->left = new TreeNode(6);
    root->right->right = new TreeNode(9);

    invertTree(root); // åè½¬
    vector<int> output = levelOrder(root);

    // è¾“å‡º
    for (auto val : output)
    {
        cout << val << " ";
    }

    cout << endl;


    return 0;
}
~~~



è¾“å‡º

~~~C++
4 7 2 9 6 3 1 
~~~







## 101 [å¯¹ç§°äºŒå‰æ ‘](https://leetcode.cn/problems/symmetric-tree/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250715105852244](pic/image-20250715105852244.png)

![image-20250715105954842](pic/image-20250715105954842.png)



<img src="pic/image-20250715110248345.png" alt="image-20250715110248345" style="zoom:50%;" />

![image-20250715110306408](pic/image-20250715110306408.png)



### é€’å½’

<img src="pic/image-20250715112948526.png" alt="image-20250715112948526" style="zoom:50%;" />

<img src="pic/image-20250715113000842.png" alt="image-20250715113000842" style="zoom:50%;" />

![image-20250715113039827](pic/image-20250715113039827.png)



~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // é€’å½’
    bool compare(TreeNode* left, TreeNode* right)
    {
        // æ’é™¤èŠ‚ç‚¹ç©ºçš„æƒ…å†µ
        if      (left == nullptr && right == nullptr)       return true;
    	else if (left == nullptr || right == nullptr)       return false;
        // æ’é™¤èŠ‚ç‚¹ä¸ç©ºï¼Œä½†å€¼ä¸åŒçš„æƒ…å†µ
        else if (left->val != right->val)   return false;

        // å·¦å³éƒ½ä¸ç©ºï¼Œä¸”å€¼ç›¸åŒï¼Œå†åšé€’å½’ä¸‹ä¸€å±‚        
        // å†…å¤–å±‚éƒ½ç›¸åŒï¼Œæ‰å¯¹ç§°
        return compare(left->left, right->right) && // å¤–å±‚æ¯”è¾ƒï¼Œå·¦æ ‘->å·¦ï¼Œå³æ ‘->å³
               compare(left->right, right->left);	// å†…å±‚æ¯”è¾ƒï¼šå·¦æ ‘->å³ï¼Œå³æ ‘->å·¦      
    }

    bool isSymmetric(TreeNode* root) {
        if (root == nullptr)    return true;
        return compare(root->left, root->right); // å·¦å³èŠ‚ç‚¹ä¼ å…¥compareï¼Œè¿›è¡Œé€’å½’æ¯”è¾ƒ
    }
};
~~~



### ACM

~~~C++
#include <iostream>

using namespace std;


// 101 å¯¹ç§°äºŒå‰æ ‘
// æ—¶é—´å¤æ‚åº¦ï¼š O(n)
// ç©ºé—´å¤æ‚åº¦ï¼š
// 		æœ€åæƒ…å†µä¸‹ä¸ºé€’å½’æ ˆæ·±åº¦ O(h)ï¼Œh ä¸ºæ ‘é«˜ï¼›
// 		å¹³è¡¡äºŒå‰æ ‘æ—¶ O(log n)ï¼Œæœ€åé€€åŒ–ä¸º O(n)ã€‚

struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


// é€’å½’æ¯”è¾ƒä¸¤æ£µå­æ ‘æ˜¯å¦é•œåƒå¯¹ç§°
bool compare(TreeNode* left, TreeNode* right)
{
    // æ’é™¤èŠ‚ç‚¹ç©º
    if      (left == nullptr && right == nullptr)       return true;
    else if (left == nullptr || right == nullptr)       return false;
    // æ’é™¤èŠ‚ç‚¹ä¸ç©ºï¼Œä½†å€¼ä¸åŒçš„æƒ…å†µ
    else if (left->val != right->val)                   return false;

    // æ¯”è¾ƒå¤–ä¾§å’Œå†…ä¾§
    return compare(left->left, right->right) && compare(left->right, right->left);
}

// åˆ¤æ–­æ•´æ£µæ ‘æ˜¯å¦å¯¹ç§°
bool isSymmetric(TreeNode* root) 
{
    if (!root) return true;
    return compare(root->left, root->right);
}



int main()
{
    // æ„å»ºå¯¹ç§°äºŒå‰æ ‘ï¼š
    //         1
    //       /   \
    //      2     2
    //     / \   / \
    //    3   4 4   3
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(2);

    root->left->left = new TreeNode(3);
    root->left->right = new TreeNode(4);

    root->right->left = new TreeNode(4);
    root->right->right = new TreeNode(3);

    bool result = isSymmetric(root);
    cout << (result ? "true" : "false") << endl;

    return 0;
}
~~~





## 543 [äºŒå‰æ ‘çš„ç›´å¾„](https://leetcode.cn/problems/diameter-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

@ é€’å½’

![image-20250716101939880](pic/image-20250716101939880.png)

[æ ‘å½¢ DPï¼šæ ‘çš„ç›´å¾„ã€åŸºç¡€ç®—æ³•ç²¾è®² 23ã€‘](https://www.bilibili.com/video/BV17o4y187h1/?vd_source=7369d5f08520f2fc3601caee93963ffa)

<img src="pic/image-20250716172648683.png" alt="image-20250716172648683" style="zoom:60%;" />

<img src="pic/image-20250716172734061.png" alt="image-20250716172734061" style="zoom:60%;" />

![image-20250716172800038](pic/image-20250716172800038.png)

~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) {

        int ans = 0;

        // é€’å½’
        auto dfs = [&](this auto&& dfs, TreeNode* node) ->int {
            if (node == nullptr)    return -1; // å¶å­èŠ‚ç‚¹ï¼Œé“¾é•¿å°±æ˜¯-1 + 1 = 0
            
            int l_len = dfs(node->left) + 1;  // å·¦å­æ ‘æœ€å¤§é“¾é•¿ + 1 ï¼ˆåŠ 1è¿åˆ°è‡ªå·±ï¼‰
            int r_len = dfs(node->right) + 1; // å³å­æ ‘æœ€å¤§é“¾é•¿ + 1

            // ä¸¤æ¡é“¾æ‹¼æˆè·¯å¾„ï¼ˆç›´å¾„ï¼‰
            ans = max(ans, l_len + r_len); 
            
            return max(l_len, r_len); // é€’å½’è¿”å›çš„æ˜¯å½“å‰å­æ ‘çš„æœ€å¤§é“¾é•¿
        };

        dfs(root);
        return ans;
    }
};
~~~

 `this auto&& dfs`

- **C++20 èµ·æ”¯æŒ**ï¼šlambda å‚æ•°ä¸­ä½¿ç”¨ `this auto&&` å…è®¸ lambda **é€’å½’è°ƒç”¨è‡ªèº«**ã€‚
- `this` è¯´æ˜å®ƒæ˜¯ **é€’å½’ lambda** çš„ç‰¹æ®Šç”¨æ³•ï¼Œç¼–è¯‘å™¨ä¼šåœ¨è°ƒç”¨æ—¶æŠŠå½“å‰ lambda è‡ªå·±ä¼ è¿›æ¥ã€‚
- `dfs` æ˜¯ lambda çš„â€œè‡ªèº«å¼•ç”¨â€ï¼Œç›¸å½“äºç»™è‡ªå·±èµ·äº†ä¸ªåå­—ï¼Œå¯ä»¥åœ¨å†…éƒ¨é€’å½’è°ƒç”¨ã€‚

~~~C++
auto dfs = [&](this auto&& dfs, TreeNode* node) -> int{...};
~~~

å®šä¹‰äº†ä¸€ä¸ª**å¯ä»¥é€’å½’è°ƒç”¨è‡ªèº«çš„æ·±åº¦ä¼˜å…ˆæœç´¢å‡½æ•°**ï¼Œåœ¨å‡½æ•°ä½“ä¸­é€’å½’åœ°è®¿é—®å·¦å³å­æ ‘ï¼Œå¹¶è®¡ç®—â€œä»¥è¯¥èŠ‚ç‚¹ä¸ºä¸­å¿ƒçš„æœ€é•¿è·¯å¾„â€ã€‚

ç­‰ä»·äºï¼š

~~~C++
auto dfs = [&](auto&& dfs, TreeNode* node) -> int { ... };
~~~

è°ƒç”¨æ—¶éœ€è¦æ‰‹åŠ¨ä¼ å…¥è‡ªå·±`dfs`

~~~C++
dfs(dfs, root);
~~~

è€Œ`this auto&&` ç›´æ¥å¸®ä½ æŠŠ`dfs`ä¼ ç»™è‡ªå·±äº†ï¼Œè°ƒç”¨æ—¶åªç”¨å†™ï¼š

~~~C++
dfs(root);
~~~





æ™®é€šå†™æ³•ï¼š

~~~C++
class Solution {
public:
    int maxDiameter = 0;

    int dfs(TreeNode* node) {
        if (node == nullptr) return -1;

        int left = dfs(node->left) + 1;
        int right = dfs(node->right) + 1;

        maxDiameter = max(maxDiameter, left + right); // ä¸¤æ¡é“¾æ‹¼æˆè·¯å¾„ï¼ˆç›´å¾„ï¼‰

        return max(left, right); // é€’å½’è¿”å›çš„æ˜¯å½“å‰å­æ ‘çš„æœ€å¤§é“¾é•¿
    }


    int diameterOfBinaryTree(TreeNode* root) {

        dfs(root);
        return maxDiameter;
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <algorithm>
using namespace std;

// 543 äºŒå‰æ ‘çš„ç›´å¾„


struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


int diameterOfBinaryTree(TreeNode* root)
{
    int ans = 0;

    // é€’å½’ lambdaå†™æ³•ï¼Œthis auto&& å…è®¸é€’å½’è°ƒç”¨è‡ªèº« ï¼ˆéœ€è¦ C++23 æ”¯æŒï¼‰
    auto dfs = [&](this auto&& dfs, TreeNode* node) ->int {
        if (node == nullptr)    return -1; // å¶å­èŠ‚ç‚¹ï¼Œé“¾é•¿å°±æ˜¯ -1 + 1 = 0
        
        int l_len = dfs(node->left) + 1;  // å·¦æ ‘æœ€å¤§é“¾é•¿ + 1
        int r_len = dfs(node->right) + 1; // å³æ ‘æœ€å¤§é“¾é•¿ + 1

        // æœ€å¤§å·¦é“¾ + æœ€å¤§å³é“¾
        ans = max(ans, l_len + r_len);

        return max(l_len, r_len); // é€’å½’è¿”å›çš„æ˜¯å½“å‰å­æ ‘çš„æœ€å¤§é“¾é•¿
    };

    dfs(root);
    return ans;
}


int main()
{
    // æ„å»ºå¦‚ä¸‹äºŒå‰æ ‘ï¼š
    //           1
    //         /   \
    //        2     3
    //       / \     
    //      4   5     

    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);

    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    int ans = diameterOfBinaryTree(root); // 3
    cout << ans << endl;


    return 0;
}
~~~



æ™®é€šå†™æ³•ï¼š

~~~C++
#include <iostream>
#include <algorithm>
using namespace std;

// 543 äºŒå‰æ ‘çš„ç›´å¾„


struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


int dfs (TreeNode* node, int& maxDiameter)
{
    if (node == nullptr) return -1;
    int left = dfs(node->left, maxDiameter) + 1;
    int right = dfs(node->right, maxDiameter) + 1;

    maxDiameter = max(maxDiameter, left + right); // ä¸¤æ¡é“¾æ‹¼æˆè·¯å¾„ï¼ˆç›´å¾„ï¼‰

    return max(left, right); // é€’å½’è¿”å›çš„æ˜¯å½“å‰å­æ ‘çš„æœ€å¤§é“¾é•¿
}


int main()
{
    // æ„å»ºå¦‚ä¸‹äºŒå‰æ ‘ï¼š
    //           1
    //         /   \
    //        2     3
    //       / \     
    //      4   5     

    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);

    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    int maxDiameter = 0;
    dfs(root, maxDiameter);

    cout << maxDiameter << endl;

    return 0;
}
~~~





## 124 [äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked)

@ é€’å½’

![image-20250717102900078](pic/image-20250717102900078.png)



åœ¨ ã€543 äºŒå‰æ ‘çš„ç›´å¾„ã€‘çš„åŸºç¡€ä¸Šï¼Œæ”¹æˆæ±‚èŠ‚ç‚¹å’Œ

<img src="pic/image-20250717110338582.png" alt="image-20250717110338582" style="zoom:60%;" />

![image-20250717110355666](pic/image-20250717110355666.png)

![image-20250717110401891](pic/image-20250717110401891.png)



~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxPathSum(TreeNode* root) {

        int ans = INT_MIN;
        auto dfs = [&] (this auto&& dfs, TreeNode* node) ->int {
            if (node == nullptr)    return 0;// æ²¡æœ‰èŠ‚ç‚¹ï¼Œå’Œä¸º0

            int l_val = dfs(node->left); // å·¦æ ‘æœ€å¤§é“¾å’Œ
            int r_val = dfs(node->right); // å³æ ‘æœ€å¤§é“¾å’Œ

            ans = max(ans, l_val + r_val + node->val); // ä¸¤æ¡é“¾æ‹¼æˆè·¯å¾„ï¼ˆåŠ ä¸Šå½“å‰èŠ‚ç‚¹ï¼‰
            
            return max( max(l_val, r_val) + node->val, 0 ); // å½“å‰å­æ ‘æœ€å¤§é“¾å’Œ
                                                            // å’Œ0æ¯”è¾ƒï¼Œä¸å–è´Ÿæ•°
        };

        dfs(root);
        return ans;
        
    }
};
~~~



ä¸ç”¨lambdaçš„å†™æ³•

~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans = INT_MIN;

    int dfs(TreeNode* node) 
    {
        if (node == nullptr)    return 0;// æ²¡æœ‰èŠ‚ç‚¹ï¼Œå’Œä¸º0

        int l_val = dfs(node->left);  // å·¦æ ‘æœ€å¤§é“¾å’Œ
        int r_val = dfs(node->right); // å³æ ‘æœ€å¤§é“¾å’Œ

        ans = max(ans, l_val + r_val + node->val); // ä¸¤æ¡é“¾æ‹¼æˆè·¯å¾„ï¼ˆåŠ ä¸Šå½“å‰èŠ‚ç‚¹ï¼‰
        
        return max( max(l_val, r_val) + node->val, 0 ); // å½“å‰å­æ ‘æœ€å¤§é“¾å’Œ
                                                      // å’Œ0æ¯”è¾ƒï¼Œä¸å–è´Ÿæ•°
    };

    int maxPathSum(TreeNode* root) {
        dfs(root);
        return ans; 
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <algorithm>
using namespace std;

// 124 äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ


struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


int maxPathSum(TreeNode* root) 
{
    int ans = INT_MIN;

    auto dfs = [&] (this auto&& dfs, TreeNode* node) ->int {

        if (node == nullptr)    return 0;// æ²¡æœ‰èŠ‚ç‚¹ï¼Œå’Œä¸º0

        int l_val = dfs(node->left); // å·¦æ ‘æœ€å¤§é“¾å’Œ
        int r_val = dfs(node->right); // å³æ ‘æœ€å¤§é“¾å’Œ

        ans = max(ans, l_val + r_val + node->val); // ä¸¤æ¡é“¾æ‹¼æˆè·¯å¾„ï¼ˆåŠ ä¸Šå½“å‰èŠ‚ç‚¹ï¼‰
        return max(max(l_val, r_val) + node->val, 0); // å½“å‰å­æ ‘æœ€å¤§é“¾å’Œ
                                                        // å’Œ0æ¯”è¾ƒï¼Œä¸å–è´Ÿæ•°
    };

    dfs(root);
    return ans;
}


int main()
{
    /* æ„å»ºå¦‚ä¸‹äºŒå‰æ ‘ï¼š  
        -10
        /   \
       9     20
             / \     
           15    7    
    */ 
    

    TreeNode* root = new TreeNode(-10);
    root->left = new TreeNode(9);
    root->right = new TreeNode(20);

    root->right->left = new TreeNode(15);
    root->right->right = new TreeNode(7);

    int ans = maxPathSum(root); // 42
    cout << ans << endl;


    return 0;
}
~~~





## [108 å°†æœ‰åºæ•°ç»„è½¬ä¸ºäºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250718102019473](pic/image-20250718102019473.png)

![image-20250718103907990](pic/image-20250718103907990.png)

<img src="pic/image-20250718103913432.png" alt="image-20250718103913432" style="zoom:30%;" />

<img src="pic/image-20250718103925534.png" alt="image-20250718103925534" style="zoom: 70%;" />

<img src="pic/image-20250718103955950.png" alt="image-20250718103955950" style="zoom:50%;" />



<img src="pic/image-20250718104007279.png" alt="image-20250718104007279" style="zoom: 50%;" />

![image-20250718104033278](pic/image-20250718104033278.png)



~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // nums[left] åˆ° nums[right] è½¬æˆå¹³è¡¡äºŒå‰æœç´¢æ ‘ (å·¦é—­å³é—­)
    TreeNode* traversal(vector<int>& nums, int left, int right)
    {
        if (left > right)   return nullptr;

        int mid = left + ((right - left) / 2); 
        TreeNode* root = new TreeNode(nums[mid]); // å–ä¸­é—´å€¼ä½œä¸ºroot

        root->left = traversal(nums, left, mid - 1);  // root->left æ¥å·¦åŒºé—´æ„é€ çš„ä¸‹ä¸€å±‚root
        root->right = traversal(nums, mid + 1, right);// root->right æ¥å³åŒºé—´æ„é€ çš„ä¸‹ä¸€å±‚root
        
        return root;
    }


    TreeNode* sortedArrayToBST(vector<int>& nums) {

        TreeNode* root = traversal(nums, 0, nums.size() - 1);
        return root;
        
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <queue>
#include <iostream>

using namespace std;

// 108 å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘

struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

TreeNode* ArrayToBstTraversal(vector<int>& nums, int left, int right)
{
    if (left > right)   return nullptr;

    int mid = left + ((right - left) / 2);
    TreeNode* root = new TreeNode(nums[mid]);

    root->left = ArrayToBstTraversal(nums, left, mid - 1);
    root->right = ArrayToBstTraversal(nums, mid + 1, right);

    return root;
}


// å±‚åºéå†ï¼ˆç”¨äºè¾“å‡ºï¼‰
vector<int> levelOrder(TreeNode* root) 
{
    vector<int> result;
    if (!root)  return result;

    queue<TreeNode*> q;
    q.push(root);
    while (!q.empty())
    {
        TreeNode* node = q.front();
        q.pop();
        result.push_back(node->val);

        if (node->left)     q.push(node->left);
        if (node->right)    q.push(node->right);

    }

    return result;
}



int main()
{
    // nums = [-10,-3,0,5,9]
    vector<int> nums = {-10, -3, 0, 5, 9};

    TreeNode* root = ArrayToBstTraversal(nums, 0, nums.size() - 1);

    // å±‚åºè¾“å‡º
    vector<int> output = levelOrder(root);
    for (auto val : output) 
    {
        cout << val << " "; // 0 -10 5 -3 9
    }
    cout << endl;


    return 0;
}
~~~





## 98 [éªŒè¯äºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250718111419031](pic/image-20250718111419031.png)

**æ³¨æ„ï¼š**

- è¦æ¯”è¾ƒçš„æ˜¯ **å·¦å­æ ‘**æ‰€æœ‰èŠ‚ç‚¹å°äºä¸­é—´èŠ‚ç‚¹ï¼Œ**å³å­æ ‘**æ‰€æœ‰èŠ‚ç‚¹å¤§äºä¸­é—´èŠ‚ç‚¹

- ä¸èƒ½å•çº¯çš„æ¯”è¾ƒå·¦èŠ‚ç‚¹å°äºä¸­é—´èŠ‚ç‚¹ï¼Œå³èŠ‚ç‚¹å¤§äºä¸­é—´èŠ‚ç‚¹



### 1ã€ä¸­åºé€’å½’ + æ•°ç»„

æœç´¢æ ‘ï¼Œå·¦å°å³å¤§ï¼Œä¸­åºå­˜ä¸‹æ¥çš„å€¼åº”è¯¥æ˜¯å‡åº

~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:

    // å­˜å‚¨èŠ‚ç‚¹å€¼ (é€’å½’ä¸­åº)
    vector<int> vec; 
    void traversal(TreeNode* root)
    {
        if (root == nullptr)    return;
        traversal(root->left);      // å·¦
        vec.push_back(root->val);   // ä¸­
        traversal(root->right);     // å³
    }

    // æœç´¢æ ‘ï¼Œå·¦å°å³å¤§ï¼Œä¸­åºå­˜ä¸‹æ¥çš„å€¼åº”è¯¥æ˜¯å‡åº

public:
    bool isValidBST(TreeNode* root) {
        vec.clear();
        traversal(root);

        // åˆ¤æ–­vecæ˜¯ä¸æ˜¯å‡åº
        for (int i = 1; i < vec.size(); i++)
        {
            // æœç´¢æ ‘é‡Œä¸èƒ½æœ‰ç›¸ç­‰çš„å…ƒç´ ï¼Œæ‰€ä»¥è¦ <=
            if (vec[i] <= vec[i - 1])   return false;
        }

        return true;
        
    }
};
~~~



### 2ã€ä¸­åºé€’å½’ +  preä¿å­˜å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ¯”è¾ƒæ˜¯å¦å‡åº

~~~C++
class Solution {
public:

    TreeNode* pre = nullptr; // pre è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹

    bool isValidBST(TreeNode* root) {

        if (root == nullptr)    return true;

        bool left = isValidBST(root->left);     // å·¦

        if (pre != nullptr && pre->val >= root->val)    return false;
        pre = root; // è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹            // ä¸­

        bool right = isValidBST(root->right);   // å³
        
        return left && right;
    }
};
~~~



### 3ã€å‰åº + åˆ¤æ–­èŠ‚ç‚¹èŒƒå›´ 

> [çµç¥](https://leetcode.cn/problems/validate-binary-search-tree/solutions/2020306/qian-xu-zhong-xu-hou-xu-san-chong-fang-f-yxvh/?envType=study-plan-v2&envId=top-100-liked)ï¼Œè¿™æ€ä¹ˆèƒ½æƒ³å‡ºæ¥çš„ï¼Ÿ

![image-20250718165259599](pic/image-20250718165259599.png)

<img src="pic/image-20250718165325010.png" alt="image-20250718165325010" style="zoom:60%;" />

**å‰åºï¼šå…ˆè®¿é—®èŠ‚ç‚¹å€¼ï¼Œå†é€’å½’å­æ ‘**

**æ ¹æ®ä¸Šä¸€å±‚æ¥æ›´æ–°ä¸‹ä¸€å±‚çš„èŠ‚ç‚¹å€¼åº”è¯¥åœ¨çš„èŒƒå›´ï¼Œèµ°åˆ°ä¸‹ä¸€å±‚åˆ¤æ–­æ˜¯å¦åˆæ³•**

**å¾€å·¦èµ°ï¼Œæ›´æ–°å³è¾¹ç•Œï¼Œå¾€å³èµ°ï¼Œæ›´æ–°å·¦è¾¹ç•Œ**



~~~C++
class Solution {
public:
    bool isValidBST(TreeNode* root, long long left = LLONG_MIN, long long right = LLONG_MAX) {

        // å‰åº + è¾¹ç•Œ 
        // æœ€å¼€å§‹rootæ‰€å¤„èŒƒå›´æ˜¯ ï¼ˆ-æ— ç©·ï¼Œ+æ— ç©·ï¼‰

        if (root == nullptr)    return true;

        long long x = root->val; // å‰åºï¼Œå…ˆè®¿é—®èŠ‚ç‚¹å€¼ï¼Œå†é€’å½’å­æ ‘

        return left < x && x < right && // åˆ¤æ–­èŠ‚ç‚¹å€¼è¦å¤„äºæ­£ç¡®çš„è¾¹ç•ŒèŒƒå›´å†…
               isValidBST(root->left, left, x) && // æ›´æ–°å³è¾¹ç•Œ
               isValidBST(root->right, x, right); // æ›´æ–°å·¦è¾¹ç•Œ
    }
};
~~~



### ACM

~~~C++
#include <iostream>
#include <algorithm>
using namespace std;

// 98 éªŒè¯äºŒå‰æœç´¢æ ‘

struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


// åˆ¤æ–­æ˜¯å¦ä¸ºåˆæ³• BST
bool isValidBST(TreeNode* root, TreeNode* pre) 
{
    if (!root) return true;

    if (!isValidBST(root->left, pre)) return false;

    if (pre && pre->val >= root->val) return false;
    pre = root;

    if (!isValidBST(root->right, pre)) return false;

    return true;
}




int main()
{
    /* æ„å»ºå¦‚ä¸‹äºŒå‰æ ‘ï¼š  
          5
        /   \
       1     4
            / \     
           3   6    
    */ 
    

    TreeNode* root = new TreeNode(5);
    root->left = new TreeNode(1);
    root->right = new TreeNode(4);

    root->right->left = new TreeNode(3);
    root->right->right = new TreeNode(6);

    TreeNode* pre = nullptr;
    cout << (isValidBST(root, pre) ? "true" : "false") << endl;

    return 0;
}
~~~



## [230 äºŒå‰æœç´¢æ ‘ç§ç¬¬kå°çš„å…ƒç´ ](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250719225021378](pic/image-20250719225021378.png)

![image-20250719225340770](pic/image-20250719225340770.png)

### 1ã€ä¸­åºé€’å½’ + æ•°ç»„

ä¸­åºå­˜ä¸‹æ¥ `vec` æ­£å¥½æ˜¯å‡åºï¼Œç¬¬kå°çš„æ•°ï¼Œå°±æ˜¯ vec ç¬¬ [k-1] ä¸ªæ•° `vec[k-1]`

~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    // å­˜å‚¨èŠ‚ç‚¹å€¼ (é€’å½’ä¸­åº)
    vector<int> vec; 
    void traversal(TreeNode* root)
    {
        if (root == nullptr)    return;
        traversal(root->left);      // å·¦
        vec.push_back(root->val);   // ä¸­
        traversal(root->right);     // å³
    }

    int kthSmallest(TreeNode* root, int k) {

        vec.clear();
        traversal(root); // ä¸­åºå­˜ä¸‹æ¥æ­£å¥½æ˜¯å‡åºï¼Œç¬¬kå°çš„æ•°ï¼Œå°±æ˜¯ vec ç¬¬ [k-1] ä¸ªæ•°

        return vec[k - 1];
        
    }
};
~~~



### 2ã€ä¸­åºé€’å½’ + ç›´æ¥æ‰¾ç¬¬kä¸ª

![image-20250719225310165](pic/image-20250719225310165.png)

~~~C++
class Solution {
public:

    int ans = 0;
    int k = 1; // ç›´æ¥ç”¨ k è®¡æ•°

    // ä¸­åºé€’å½’
    void dfs(TreeNode* root)
    {
        if (root == nullptr)    return;

        dfs(root->left);
        
        if (k == 0)     return; // å·²ç»èµ°è¿‡kä¸ªï¼Œåé¢ä¸ç”¨éå†äº†ï¼Œç›´æ¥return
        if (--k == 0)   ans = root->val; // è®°å½•é€’å½’åˆ°çš„ç¬¬kä¸ªï¼Œä¸” k-- è®¡æ•°

        dfs(root->right);
    }


    int kthSmallest(TreeNode* root, int k) {

        this->k = k;
        dfs(root);
        return ans;  
    }
};
~~~



### ACM

~~~C++
#include <iostream>
using namespace std;

// 230 äºŒå‰æœç´¢æ ‘ä¸­ç¬¬ K å°çš„å…ƒç´ 

struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


// ä¸­åºé€’å½’
void dfs(TreeNode* root, int& k, int& ans)
{
    if (root == nullptr)    return;

    dfs(root->left, k, ans);
    
    if (k == 0)     return; // å·²ç»èµ°è¿‡kä¸ªï¼Œåé¢ä¸ç”¨éå†äº†ï¼Œç›´æ¥return
    if (--k == 0)   ans = root->val; // è®°å½•é€’å½’åˆ°çš„ç¬¬kä¸ªï¼Œä¸” k-- è®¡æ•°

    dfs(root->right, k, ans);
}


int main()
{
    /* æ„å»ºå¦‚ä¸‹äºŒå‰æ ‘ï¼š  
                    5
                  /   \
                 3     6
                / \        
               2   4   
              /
             1   
    */ 
    

    TreeNode* root = new TreeNode(5);
    root->left = new TreeNode(3);
    root->right = new TreeNode(6);

    root->left->left = new TreeNode(2);
    root->left->right = new TreeNode(4);

    root->left->left->left = new TreeNode(1);

    int k = 3;
    int ans = 0;
    dfs(root, k, ans);

    cout << ans << endl; // 3

    return 0;
}
~~~



## 199 [äºŒå‰æ ‘çš„å³è§†å›¾](https://leetcode.cn/problems/binary-tree-right-side-view/description/?envType=study-plan-v2&envId=top-100-liked)

@ å±‚åºéå†æ”¶é›†æ¯å±‚æœ€åä¸€ä¸ªå…ƒç´ 

![image-20250720103837102](pic/image-20250720103837102.png)

![image-20250720103904112](pic/image-20250720103904112.png)

~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        
        vector<int> result;

        // å±‚åº
        queue<TreeNode*> que;
        if (root != nullptr)    que.push(root);
        while (!que.empty())
        {
            int size = que.size();
            for (int i = 0; i < size; i++)
            {
                TreeNode* node = que.front();
                que.pop();

                // å°†æ¯å±‚çš„æœ€åä¸€ä¸ªå…ƒç´ æ”¾å…¥result
                if (i == (size - 1))    result.push_back(node->val);

                if (node->left)     que.push(node->left);
                if (node->right)    que.push(node->right);

            }
        }

        return result;
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <queue>
#include <iostream>

using namespace std;


struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


vector<int> rightSideView(TreeNode* root)
{
    vector<int> result;

    queue<TreeNode*> que;
    if (root != nullptr)    que.push(root);
    while (!que.empty())
    {
        int size = que.size();
        for (int i = 0; i < size; i++)
        {
            TreeNode* node = que.front();
            que.pop();

            // å°†æ¯å±‚æœ€åä¸€ä¸ªå…ƒç´ æ”¾è¿›result
            if (i == (size - 1))    result.push_back(node->val);

            if (node->left)     que.push(node->left);
            if (node->right)    que.push(node->right);
        }
    }

    return result;
}


int main()
{
    /* æ„å»ºå¦‚ä¸‹äºŒå‰æ ‘ï¼š  
                1
              /   \
             2     3
            /        
           4      
          /
         5   
    */

    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);

    root->left->left = new TreeNode(4);
    root->left->left->left = new TreeNode(5);

    vector<int> result = rightSideView(root); // 1 3 4 5
    for (int val : result)
    {
        cout << val << " ";
    }

    cout << endl;


    return 0;
}
~~~







## 114 [äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250720170140684](pic/image-20250720170140684.png)



### 1ã€å¤´æ’æ³•

![image-20250720170153091](pic/image-20250720170153091.png)



~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    TreeNode* head;

    void flatten(TreeNode* root) {

        if (root == nullptr)    return;
        
        // éå†é¡ºåºæ˜¯ å³ - å·¦ - ä¸­
        flatten(root->right); 
        flatten(root->left);

        // ä¸­ï¼šå¤„ç†èŠ‚ç‚¹ï¼Œå·¦ç½®ç©ºï¼Œå³æ¥ä¸Šä¸€ä¸ªhead
        root->left = nullptr;
        root->right = head; // å¤´æ’æ³•ï¼Œç›¸å½“äºé“¾è¡¨çš„ root->next = head

        head = root; // æ›´æ–°headï¼Œç°åœ¨é“¾è¡¨å¤´èŠ‚ç‚¹æ˜¯ root

        
    }
};
~~~



### 2ã€åˆ†æ²»

![image-20250720173301994](pic/image-20250720173301994.png)

~~~C++
class Solution {
public:

    TreeNode* dfs(TreeNode* root)
    {
        if (root == nullptr)    return nullptr;

        TreeNode* left_tail = dfs(root->left);   // å·¦æ ‘é“¾è¡¨å°¾èŠ‚ç‚¹
        TreeNode* right_tail = dfs(root->right); // å³æ ‘é“¾è¡¨å°¾èŠ‚ç‚¹

        if (left_tail)
        {
            left_tail->right = root->right; // å·¦å­æ ‘é“¾è¡¨ -> å³å­æ ‘é“¾è¡¨
            root->right = root->left; // å½“å‰èŠ‚ç‚¹ -> å·¦å³åˆå¹¶åçš„é“¾è¡¨

            root->left = nullptr; // root->left ç½®ç©º
        }

        // è¿”å›çš„æ˜¯å°¾èŠ‚ç‚¹
        if (right_tail)     return right_tail;
        else if (left_tail) return left_tail;
        else                return root;
    }

    void flatten(TreeNode* root) {
        dfs(root);
    }
};
~~~



### ACM

~~~C++
#include <iostream>

using namespace std;

// 114 äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨

struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};



void flatten(TreeNode* root, TreeNode*& head) {

    if (root == nullptr)    return;
    
    // éå†é¡ºåºæ˜¯ å³ - å·¦ - ä¸­
    flatten(root->right, head); 
    flatten(root->left, head);

    // ä¸­ï¼šå¤„ç†èŠ‚ç‚¹ï¼Œå·¦ç½®ç©ºï¼Œå³æ¥ä¸Šä¸€ä¸ªhead
    root->left = nullptr;
    root->right = head; // å¤´æ’æ³•ï¼Œç›¸å½“äºé“¾è¡¨çš„ root->next = head

    head = root; // æ›´æ–°headï¼Œç°åœ¨é“¾è¡¨å¤´èŠ‚ç‚¹æ˜¯ root
}

int main()
{
    /* æ„å»ºå¦‚ä¸‹äºŒå‰æ ‘ï¼š  
                1
              /   \
             2     5
            / \     \   
           3   4     6
   
    */

    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(5);

    root->left->left = new TreeNode(3);
    root->left->right = new TreeNode(4);

    root->right->right = new TreeNode(6);


    TreeNode* head = nullptr;
    flatten(root, head); // 1 2 3 4 5 6
    while (root)
    {
        cout << root->val << " ";
        root = root->right;
    }
    cout << endl;


    return 0;
}

~~~





## [105 ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked)

å‚è€ƒ[106 ä»ä¸­åºä¸ååºéå†æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)

![image-20250721105825086](pic/image-20250721105825086.png)

å’Œ106 ä»ä¸­åºä¸ååºéå†æ„é€ äºŒå‰æ ‘ ä¸€ä¸ªæ„æ€

<img src="pic/image-20250721150320570.png" alt="image-20250721150320570" style="zoom:50%;" />

~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    TreeNode* traversal(vector<int>& inorder, int inorderBegin, int inorderEnd, 
                        vector<int>& preorder, int preorderBegin, int preorderEnd) {
        
        if (preorderBegin == preorderEnd)   return nullptr;

        // æ ¹èŠ‚ç‚¹
        int rootValue = preorder[preorderBegin]; // æ³¨æ„ç”¨preorderBeginï¼Œä¸è¦ç”¨0
        TreeNode* root = new TreeNode(rootValue);

        if (preorderEnd - preorderBegin == 1)   return root; // å¶å­èŠ‚ç‚¹

        // æ‰¾ä¸­åºçš„åˆ‡å‰²ç‚¹
        int delimiterIndex = inorderBegin;
        for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++)
        {
            if (inorder[delimiterIndex] == rootValue)   break;
        }

        // ä¸­åºåˆ‡å‰² å·¦é—­å³å¼€
        // å·¦ä¸­åº [inorderBegin, delimiterIndex)
        int leftInorderBegin = inorderBegin, leftInorderEnd = delimiterIndex;
        // å³ä¸­åº [delimiterIndex, inorderEnd]
        int rightInorderBegin = delimiterIndex + 1, rightInorderEnd = inorderEnd;

        // å‰åºåˆ‡å‰² å·¦é—­å³å¼€
        // å·¦å‰åº
        int leftPreorderBegin = preorderBegin + 1; // åˆ†ç¦»å‡ºroot
        int leftPreorderEnd = preorderBegin + 1 + (delimiterIndex - inorderBegin);
        // å³å‰åº
        int rightPreorderBegin = preorderBegin + 1 + (delimiterIndex - inorderBegin);
        int rightPreorderEnd = preorderEnd;
        
        
        // é€’å½’ æ›´æ–°åŒºé—´ç´¢å¼•
        root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,
                               preorder, leftPreorderBegin, leftPreorderEnd);
        root->right = traversal(inorder, rightInorderBegin, rightInorderEnd,
                                preorder, rightPreorderBegin, rightPreorderEnd);

        return root;
    }


public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if (inorder.size() == 0 || preorder.size() == 0)    return nullptr;
        // å·¦é—­å³å¼€
        return traversal(inorder, 0, inorder.size(),  
                         preorder, 0, preorder.size());
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

// 105 ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


TreeNode* traversal(vector<int>& inorder, int inorderBegin, int inorderEnd, 
                    vector<int>& preorder, int preorderBegin, int preorderEnd) 
{
    
    if (preorderBegin == preorderEnd)   return nullptr;

    // æ ¹èŠ‚ç‚¹
    int rootValue = preorder[preorderBegin]; // æ³¨æ„ç”¨preorderBeginï¼Œä¸è¦ç”¨0
    TreeNode* root = new TreeNode(rootValue);

    if (preorderEnd - preorderBegin == 1)   return root; // å¶å­èŠ‚ç‚¹

    // æ‰¾ä¸­åºçš„åˆ‡å‰²ç‚¹
    int delimiterIndex = inorderBegin;
    for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++)
    {
        if (inorder[delimiterIndex] == rootValue)   break;
    }

    // ä¸­åºåˆ‡å‰² å·¦é—­å³å¼€
    // å·¦ä¸­åº [inorderBegin, delimiterIndex)
    int leftInorderBegin = inorderBegin, leftInorderEnd = delimiterIndex;
    // å³ä¸­åº [delimiterIndex, inorderEnd]
    int rightInorderBegin = delimiterIndex + 1, rightInorderEnd = inorderEnd;

    // å‰åºåˆ‡å‰² å·¦é—­å³å¼€
    // å·¦å‰åº
    int leftPreorderBegin = preorderBegin + 1; // åˆ†ç¦»å‡ºroot
    int leftPreorderEnd = preorderBegin + 1 + (delimiterIndex - inorderBegin);
    // å³å‰åº
    int rightPreorderBegin = preorderBegin + 1 + (delimiterIndex - inorderBegin);
    int rightPreorderEnd = preorderEnd;
    
    
    // é€’å½’ æ›´æ–°åŒºé—´ç´¢å¼•
    root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,
                            preorder, leftPreorderBegin, leftPreorderEnd);
    root->right = traversal(inorder, rightInorderBegin, rightInorderEnd,
                            preorder, rightPreorderBegin, rightPreorderEnd);

    return root;
}


TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) 
{
    if (inorder.size() == 0 || preorder.size() == 0)    return nullptr;
    // å·¦é—­å³å¼€
    return traversal(inorder, 0, inorder.size(),  
                        preorder, 0, preorder.size());
}



// å±‚åºéå†ï¼ˆç”¨äºè¾“å‡ºï¼‰
vector<int> levelOrder(TreeNode* root) 
{
    vector<int> result;
    if (!root) return result;

    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        TreeNode* node = q.front(); 
        q.pop();
        result.push_back(node->val);

        if (node->left)  q.push(node->left);
        if (node->right) q.push(node->right);
    }

    return result;
}




int main()
{
    vector<int> preorder = {3, 9, 20, 15, 7};
    vector<int> inorder = {9, 3, 15, 20, 7};

    TreeNode* root = buildTree(preorder, inorder);

    // è¾“å‡ºæ‰“å°
    vector<int> output = levelOrder(root); // 3 9 20 15 7
    for (auto val : output)
    {
        cout << val << " ";
    }


    return 0;
}

~~~





## [437 è·¯å¾„æ€»å’ŒIII](https://leetcode.cn/problems/path-sum-iii/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250722102114429](pic/image-20250722102114429.png)

![image-20250722103417959](pic/image-20250722103417959.png)

~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int pathSum(TreeNode* root, int targetSum) {

        int ans = 0;
        unordered_map<long long, int> cntmap{{0, 1}}; // <è·¯å¾„å’Œï¼Œå‡ºç°æ¬¡æ•°>

        auto dfs = [&](this auto&& dfs, TreeNode* node, long long s)
        {
            if (node == nullptr)    return;

            s += node->val; // å½“å‰èŠ‚ç‚¹çš„è·¯å¾„å’Œï¼ˆå‰ç¼€å’Œï¼‰

            // æŠŠnodeå½“åšè·¯å¾„ç»ˆç‚¹ï¼Œç»Ÿè®¡æœ‰å¤šå°‘ä¸ªèµ·ç‚¹ (560é‡Œçš„si = sj - kå‡ºç°çš„æ¬¡æ•°)
            ans += cntmap[s - targetSum]; 

            cntmap[s]++; // è·¯å¾„å’Œså‡ºç°æ¬¡æ•°++
            dfs(node->left, s);
            dfs(node->right, s);

            // å›æº¯ æ¢å¤ç°åœºï¼ˆå»æ‰å½“å‰èŠ‚ç‚¹è‡ªèº«çš„ä¿¡æ¯ï¼‰
            cntmap[s]--; 
            // å½“å‰èŠ‚ç‚¹åªèƒ½å½±å“å®ƒä¸‹å±‚çš„èŠ‚ç‚¹ï¼Œè¿™äº›æƒ…å†µåœ¨ä¸Šé¢çš„é€’å½’ä¸­å·²ç»å¤„ç†å®Œæ¯•
            // åœ¨é€€å‡ºæœ¬å±‚é€’å½’æ—¶ï¼Œå½“å‰èŠ‚ç‚¹å‰ç¼€å’Œä¸å…¶ä»–åˆ†æ”¯æ— å…³ï¼Œåˆ é™¤è®°å½•æ¶ˆé™¤å¯¹å…¶ä»–åˆ†æ”¯çš„å½±å“

            return;
        };

        dfs(root, 0);// ä¼ å…¥å½“å‰node = root, å‰ç¼€å’Œ 0
        return ans;
    }
};
~~~

å…³äºæœ€åçš„å›æº¯ï¼š `cntmap[s]--; `

å½“å‰å±‚é€’å½’æ˜¯ä»¥å½“å‰nodeä½œä¸ºrootçš„ï¼Œé€€å‡ºæœ¬å±‚é€’å½’çš„æ—¶å€™ï¼Œå½“å‰èŠ‚ç‚¹åŠå…¶ä»¥ä¸‹çš„èŠ‚ç‚¹éƒ½åœ¨æœ¬å±‚é€’å½’å®Œæˆäº†ã€‚

æ¥ä¸‹æ¥è¦è½¬å‘çš„æ˜¯nodeä¸Šä¸€å±‚çš„å…¶ä»–åˆ†æ”¯ï¼Œè‡ªç„¶è¦å»é™¤nodeçš„ä¿¡æ¯ã€‚

ä¸ºä»€ä¹ˆè¦åœ¨é€’å½’å®Œå³å­æ ‘åæ‰èƒ½æ¢å¤ç°åœºï¼Ÿèƒ½å¦åœ¨é€’å½’å®Œå·¦å­æ ‘åå°±æ¢å¤ç°åœºå‘¢ï¼Ÿ

ä¸å¯ä»¥ï¼Œå› ä¸ºé€’å½’å·¦å³å­æ ‘éƒ½æ˜¯nodeä½œä¸ºrootçš„éƒ¨åˆ†ï¼Œé€’å½’nodeå³å­æ ‘ä¹Ÿéœ€è¦nodeçš„ä¿¡æ¯ã€‚



ACM

~~~C++
#include <iostream>
#include <unordered_map>
using namespace std;

// 437 è·¯å¾„æ€»å’ŒIII

struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


// è·¯å¾„å’Œ
int pathSum(TreeNode* root, int targetSum) {

    int ans = 0;
    unordered_map<long long, int> cntmap{{0, 1}}; // <è·¯å¾„å’Œï¼Œå‡ºç°æ¬¡æ•°>

    // é€’å½’
    auto dfs = [&](this auto&& dfs, TreeNode* node, long long s)
    {
        if (node == nullptr)    return;

        s += node->val; // å½“å‰èŠ‚ç‚¹çš„è·¯å¾„å’Œï¼ˆå‰ç¼€å’Œï¼‰

        // æŠŠnodeå½“åšè·¯å¾„ç»ˆç‚¹ï¼Œç»Ÿè®¡æœ‰å¤šå°‘ä¸ªèµ·ç‚¹ (560é‡Œçš„si = sj - kå‡ºç°çš„æ¬¡æ•°)
        ans += cntmap[s - targetSum]; 

        cntmap[s]++; // è·¯å¾„å’Œså‡ºç°æ¬¡æ•°++

        // é€’å½’å·¦å³
        dfs(node->left, s);
        dfs(node->right, s);


        // å›æº¯ æ¢å¤ç°åœºï¼ˆå»æ‰å½“å‰èŠ‚ç‚¹è‡ªèº«çš„ä¿¡æ¯ï¼‰
        cntmap[s]--; 
        // å½“å‰èŠ‚ç‚¹åªèƒ½å½±å“å®ƒä¸‹å±‚çš„èŠ‚ç‚¹ï¼Œè¿™äº›æƒ…å†µåœ¨ä¸Šé¢çš„é€’å½’ä¸­å·²ç»å¤„ç†å®Œæ¯•
        // åœ¨é€€å‡ºæœ¬å±‚é€’å½’æ—¶ï¼Œå½“å‰èŠ‚ç‚¹å‰ç¼€å’Œä¸å…¶ä»–åˆ†æ”¯æ— å…³ï¼Œåˆ é™¤è®°å½•æ¶ˆé™¤å¯¹å…¶ä»–åˆ†æ”¯çš„å½±å“

        return;
    };


    dfs(root, 0);// ä¼ å…¥å½“å‰node = root, å‰ç¼€å’Œ 0
    return ans;
}



int main()
{
    /* æ„å»ºå¦‚ä¸‹äºŒå‰æ ‘ï¼š  
                 10
               /    \
              5      -3
            /   \      \   
           3     2      11
          / \     \
         3  -2     1   
    */

    TreeNode* root = new TreeNode(10);
    root->left = new TreeNode(5);
    root->right = new TreeNode(-3);

    root->left->left = new TreeNode(3);
    root->left->right = new TreeNode(2);
    root->right->right = new TreeNode(11);
 
    root->left->left->left = new TreeNode(3);
    root->left->left->right = new TreeNode(-2);
    root->left->right->right = new TreeNode(1);

    int targetSum = 8;
    int ans = pathSum(root, targetSum);
    cout << ans << endl;

    return 0;
}

~~~





## 236 [äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250723101851927](pic/image-20250723101851927.png)

![image-20250723102634720](pic/image-20250723102634720.png)

![image-20250723103635617](pic/image-20250723103635617.png)

<img src="pic/image-20250723102143025.png" alt="image-20250723102143025" style="zoom:40%;" />

ä¸¤ç§æƒ…å†µï¼š

1ã€æ‰¾åˆ°ä¸€ä¸ªèŠ‚ç‚¹ï¼Œ**å…¶å·¦æ ‘å‡ºç°pï¼Œå³æ ‘å‡ºç°q**ï¼Œæˆ–è€…åè¿‡æ¥ï¼Œé‚£ä¹ˆè¿™ä¸ªèŠ‚ç‚¹å°±æ˜¯q p æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œè¿”å›è¿™ä¸ªèŠ‚ç‚¹

- é€’å½’éå†ï¼Œå¦‚æœå­æ ‘é‡åˆ°pï¼Œå°±è¿”å›pï¼Œé‡åˆ°qï¼Œå°±è¿”å›q
- æ­£å¥½å·¦å³æ ‘å„è‡ªé‡åˆ°q pï¼Œå°±è¿”å›å½“æ—¶çš„rootï¼Œå³æœ€è¿‘å…¬å…±ç¥–å…ˆï¼›

<img src="pic/image-20250723102451273.png" alt="image-20250723102451273" style="zoom:33%;" />

2ã€éå†çš„æ—¶å€™ï¼Œ**æ‰¾åˆ°èŠ‚ç‚¹å°±æ˜¯p æˆ– q æœ¬èº«ï¼Œé‡åˆ°å°±ç›´æ¥è¿”å›è¿™ä¸ªèŠ‚ç‚¹**ï¼ˆå…¶å®ä¹ŸåŒ…å«åœ¨æƒ…å†µ1é‡Œé¢ï¼‰

<img src="pic/image-20250723102547943.png" alt="image-20250723102547943" style="zoom:33%;" />



~~~C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

        if (root == p || root == q || root == nullptr)  return root;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);   // å¾€å·¦æ‰¾
        TreeNode* right = lowestCommonAncestor(root->right, p, q); // å¾€å³æ‰¾

        // è¿”å›
        if (left && right)  return root;          // å·¦å³æ ‘éƒ½æ‰¾åˆ°ï¼Œè¿”å›å½“å‰çš„root
        else if (!left && right)    return right; // åªæœ‰å³æ ‘æ‰¾åˆ°
        else if (left && !right)    return left;  // åªæœ‰å·¦æ ‘æ‰¾åˆ°
        else                        return nullptr; // éƒ½æ²¡æ‰¾åˆ°
        // return left ? left : right;
        
    }
};
~~~



> **å¦‚æœé€’å½’å‡½æ•°æœ‰è¿”å›å€¼ï¼Œå¦‚ä½•åŒºåˆ†è¦æœç´¢ä¸€æ¡è¾¹ï¼Œè¿˜æ˜¯æ•´æ£µæ ‘ï¼Ÿï¼Ÿ**
>
> ![image-20250723105523587](pic/image-20250723105523587.png)
>
> ![image-20250723105530711](pic/image-20250723105530711.png)





ACM

~~~C++
#include <iostream>
#include <unordered_map>
using namespace std;

// 236 äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) 
{
    if (root == p || root == q || root == nullptr)  return root;

    TreeNode* left = lowestCommonAncestor(root->left, p, q);   // å¾€å·¦æ‰¾
    TreeNode* right = lowestCommonAncestor(root->right, p, q); // å¾€å³æ‰¾

    // è¿”å›
    if (left && right)  return root;          // å·¦å³æ ‘éƒ½æ‰¾åˆ°ï¼Œè¿”å›å½“å‰çš„root
    else if (!left && right)    return right; // åªæœ‰å³æ ‘æ‰¾åˆ°
    else if (left && !right)    return left;  // åªæœ‰å·¦æ ‘æ‰¾åˆ°
    else                        return nullptr; // éƒ½æ²¡æ‰¾åˆ°
    // return left ? left : right;
}



int main()
{
    /* æ„å»ºå¦‚ä¸‹äºŒå‰æ ‘ï¼š  
                  3
                /    \
              5        1
            /  \      /  \   
           6    2    0    8
               / \    
              7   4        
    */

    TreeNode* root = new TreeNode(3);
    root->left = new TreeNode(5);
    root->right = new TreeNode(1);

    root->left->left = new TreeNode(6);
    root->left->right = new TreeNode(2);
    root->right->left = new TreeNode(0);
    root->right->right = new TreeNode(8);
 
    root->left->right->left = new TreeNode(7);
    root->left->right->right = new TreeNode(4);


    TreeNode* p = root->left;  // 5
    TreeNode* q = root->right; // 1

    TreeNode* node = lowestCommonAncestor(root, p, q);
    cout << node->val << endl;

    return 0;
}

~~~





# å›æº¯ âœ…



## 78 [å­é›†](https://leetcode.cn/problems/subsets/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250730155814806](pic/image-20250730155814806.png)

æ•°ç»„çš„ **å­é›†** æ˜¯ä»æ•°ç»„ä¸­é€‰æ‹©ä¸€äº›å…ƒç´ ï¼ˆå¯èƒ½ä¸ºç©ºï¼‰ã€‚

å¦‚æœæŠŠ å­é›†é—®é¢˜ã€ç»„åˆé—®é¢˜ã€åˆ†å‰²é—®é¢˜éƒ½æŠ½è±¡ä¸ºä¸€æ£µæ ‘çš„è¯ï¼Œé‚£ä¹ˆ**ç»„åˆé—®é¢˜å’Œåˆ†å‰²é—®é¢˜éƒ½æ˜¯æ”¶é›†æ ‘çš„å¶å­èŠ‚ç‚¹**ï¼Œè€Œ**å­é›†é—®é¢˜æ˜¯æ‰¾æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹**

è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹éƒ½æ˜¯å­é›†ã€‚

![image-20250730155923923](pic/image-20250730155923923.png)

~~~C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;

    void backtracking(vector<int>& nums, int startIndex)
    {
        if (startIndex > nums.size())  return;

        for (int i = startIndex; i < nums.size(); i++)
        {
            path.push_back(nums[i]);
            result.push_back(path); // å¤„ç†èŠ‚ç‚¹çš„æ—¶å€™ç›´æ¥æ”¾è¿›result

            backtracking(nums, i + 1);

            path.pop_back();
        }
    }


    vector<vector<int>> subsets(vector<int>& nums) {

        result.push_back(path); // æå‰æ”¾ä¸€ä¸ªç©ºpathè¿›å»
        backtracking(nums, 0);
        return result; 
    }
};
~~~



æˆ–è€…åœ¨ backtracking é‡Œå…ˆæ”¶é›†pathå†ç»“æŸï¼Œä¸ä¼šæ¼æ‰ç»“æœï¼Œä¹Ÿä¸ç”¨æå‰æ”¾ä¸€ä¸ªç©ºpathäº†ï¼ˆå¥½åƒç¬¬ä¸€ç§å¥½ç†è§£ï¼‰

~~~C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;

    void backtracking(vector<int>& nums, int startIndex)
    {
        result.push_back(path); // è¿›ä¸‹ä¸€å±‚çš„æ—¶å€™ï¼Œå…ˆæ”¶é›†path
        if (startIndex > nums.size())   return;

        for (int i = startIndex; i < nums.size(); i++)
        {
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }

    vector<vector<int>> subsets(vector<int>& nums) {

        backtracking(nums, 0);
        return result;     
    }
};
~~~







## 39 [ç»„åˆæ€»å’Œ](https://leetcode.cn/problems/combination-sum/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250730151124538](pic/image-20250730151124538.png)

æ•°ç»„ä¸­æ•°å­—éƒ½ä¸åŒï¼Œä½†æ˜¯å¯ä»¥é‡å¤é€‰ï¼Œæ¯ä¸€å±‚æ ‘å¾€ä¸‹èµ°ï¼Œéå†çš„æ•°ç»„éƒ½æ˜¯ä¸€æ ·çš„

è¿”å›æ¡ä»¶å°±æ˜¯å–åˆ°çš„å’Œï¼Œè¾¾åˆ°targetç›´æ¥è¿”å›

![image-20250730151359149](pic/image-20250730151359149.png)

![image-20250730151453688](pic/image-20250730151453688.png)

~~~C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex)
    {
        if (sum > target)   return;
        if (sum == target)
        {
            result.push_back(path);
            return;
        }

        for (int i = startIndex; i < candidates.size(); i++)
        {
            sum += candidates[i];
            path.push_back(candidates[i]);

            backtracking(candidates, target, sum, i); // æ³¨æ„å¯ä»¥é‡å¤å–å½“å‰çš„æ•°

            sum -= candidates[i];
            path.pop_back();
        }
    }

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        // candidates = [2,3,6,7], target = 7
        // [[2,2,3],[7]]

        backtracking(candidates, target, 0, 0);
        return result;  
    }
};
~~~



**å‰ªæï¼š**

> **åœ¨æ±‚å’Œé—®é¢˜ä¸­ï¼Œæ’åºä¹‹ååŠ å‰ªææ˜¯å¸¸è§çš„å¥—è·¯ï¼**

![image-20250730152552090](pic/image-20250730152552090.png)

![image-20250730152607877](pic/image-20250730152607877.png)

~~~C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex)
    {
        if (sum > target)   return;
        if (sum == target)
        {
            result.push_back(path);
            return;
        }

        for (int i = startIndex; 
             i < candidates.size() && sum + candidates[i] <= target; // å‰ªæ
             i++)
        {
            sum += candidates[i];
            path.push_back(candidates[i]);

            backtracking(candidates, target, sum, i); // æ³¨æ„å¯ä»¥é‡å¤å–å½“å‰çš„æ•°

            sum -= candidates[i];
            path.pop_back();
        }
    }

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {

        sort(candidates.begin(), candidates.end()); // å…ˆæ’åº

        backtracking(candidates, target, 0, 0);
        return result;
        
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 39 ç»„åˆæ€»å’Œ


vector<int> path;
vector<vector<int>> result;

void backtracking(vector<int>& candidates, int target, int sum, int startIndex)
{
    if (sum > target)   return;
    if (sum == target)
    {
        result.push_back(path);
        return;
    }

    for (int i = startIndex; i < candidates.size(); i++)
    {
        sum += candidates[i];
        path.push_back(candidates[i]);

        backtracking(candidates, target, sum, i); // æ³¨æ„å¯ä»¥é‡å¤å–å½“å‰çš„æ•°

        sum -= candidates[i];
        path.pop_back();
    }
}


vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
    // candidates = [2,3,6,7], target = 7
    // [[2,2,3],[7]]

    backtracking(candidates, target, 0, 0);
    return result;  
}



int main()
{
    vector<int> candidates = {2, 3, 6, 7};
    int target = 7;
    vector<vector<int>> result = combinationSum(candidates, target);
    for (int i = 0; i < result.size(); i++)
    {
        for (int val : result[i])
        {
            cout << val << " ";
        }
        cout << endl;
    }


    return 0;
}
~~~





## 17 [ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250731101546604](pic/image-20250731101546604.png)

![image-20250731101617321](pic/image-20250731101617321.png)

![image-20250731101623180](pic/image-20250731101623180.png)



~~~C++
class Solution {
public:

    const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs",// 7
        "tuv", // 8
        "wxyz" // 9
    };


    string path;
    vector<string> result;

    void backtracking(const string& digits, int digitsIndex)
    {
        // digitsIndex æ˜¯digitsçš„ä¸‹æ ‡ï¼Œè¿™é‡Œå¾€ä¸‹èµ°å°±æ˜¯å–digitsçš„ä¸‹ä¸€ä¸ªæ•°ï¼Œä¸‹ä¸€ä¸ªå­—ç¬¦ç»„åˆ

        if (digitsIndex == digits.size()) // digitså–åˆ°æœ€åä¸€ä¸ªï¼Œç»ˆæ­¢
        {
            result.push_back(path);
            return;
        }

        int digit = digits[digitsIndex] - '0'; // æŠŠindexæŒ‡å‘çš„æ•°å­—ï¼ˆå­—ç¬¦å‹ï¼‰è½¬ä¸ºint
        string letters = letterMap[digit]; // å–å‡ºå¯¹åº”çš„å­—ç¬¦é›†

        // å¤„ç†å•å±‚çš„å­—ç¬¦ç»„åˆ
        for (int i = 0; i < letters.size(); i++)
        {
            path.push_back(letters[i]);
            backtracking(digits, digitsIndex + 1);
            path.pop_back();
        }
    }

    
    vector<string> letterCombinations(string digits) {

        if (digits.size() == 0)  return result; // è¿™é‡Œè¦å†™ï¼Œä¸ç„¶digits = ""è¾“å‡ºçš„ä¸æ˜¯[] è€Œæ˜¯""

        backtracking(digits, 0);
        return result;        
    }
};
~~~



ACM

~~~C++
#include <string>
#include <vector>
#include <iostream>
using namespace std;

// 17 ç”µè¯å·ç çš„å­—æ¯ç»„åˆ

const string letterMap[10] = {
    "", // 0
    "", // 1
    "abc", // 2
    "def", // 3
    "ghi", // 4
    "jkl", // 5
    "mno", // 6
    "pqrs",// 7
    "tuv", // 8
    "wxyz" // 9
};


string path;
vector<string> result;


void backtracking(const string& digits, int digitsIndex)
{
    // digitsIndex æ˜¯digitsçš„ä¸‹æ ‡ï¼Œè¿™é‡Œå¾€ä¸‹èµ°å°±æ˜¯å–digitsçš„ä¸‹ä¸€ä¸ªæ•°ï¼Œä¸‹ä¸€ä¸ªå­—ç¬¦ç»„åˆ
    if (digitsIndex == digits.size()) // digitså–åˆ°æœ€åä¸€ä¸ªï¼Œç»ˆæ­¢
    {
        result.push_back(path);
        return;
    }
    int digit = digits[digitsIndex] - '0'; // æŠŠindexæŒ‡å‘çš„æ•°å­—ï¼ˆå­—ç¬¦å‹ï¼‰è½¬ä¸ºint
    string letters = letterMap[digit]; // å–å‡ºå¯¹åº”çš„å­—ç¬¦é›†
    // å¤„ç†å•å±‚çš„å­—ç¬¦ç»„åˆ
    for (int i = 0; i < letters.size(); i++)
    {
        path.push_back(letters[i]);
        backtracking(digits, digitsIndex + 1);
        path.pop_back();
    }
}

vector<string> letterCombinations(string digits) 
{
    if (digits.size() == 0)  return result;
    backtracking(digits, 0);
    return result;        
}


int main()
{
    string digits = "23";
    vector<string> result = letterCombinations(digits);
    for (string s : result)
    {
        cout << s << ",";
    }
    cout << endl;


    return 0;
}
~~~













## 46 [å…¨æ’åˆ—](https://leetcode.cn/problems/permutations/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250730104329081](pic/image-20250730104329081.png)

![image-20250731105210473](pic/image-20250731105210473.png)



![image-20250731105252437](pic/image-20250731105252437.png)

~~~C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;

    // used[i]: å¾€ä¸‹èµ°ï¼Œused è®°å½•è¿™æ¡ä¹‹è·¯ä¸Šnums[i]å·²ç»å–è¿‡

    void backtracking(vector<int>& nums, vector<bool>& used) 
    {
        if (path.size() == nums.size()) // å…¨æ’åˆ—ï¼Œæ‰€æœ‰æ•°å­—éƒ½è¦å–åˆ°
        {
            result.push_back(path);
            return;
        }

        for (int i = 0; i < nums.size(); i++) // æ¯æ¬¡éƒ½ä»0å¼€å§‹å–
        {
            // å…ˆåˆ¤æ–­å½“å‰nums[i]æ˜¯å¦å·²ç»å–è¿‡äº†ï¼Œå–è¿‡äº†å°±è·³è¿‡
            if (used[i] == true)    continue;

            path.push_back(nums[i]);
            used[i] = true; 

            backtracking(nums, used);

            path.pop_back();
            used[i] = false; // usedä¹Ÿè¦å›æº¯
        }
    }


    vector<vector<int>> permute(vector<int>& nums) {

        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return result;        
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;


vector<int> path;
vector<vector<int>> result;

void backtracking(vector<int>& nums, vector<bool>& used)
{
    if (path.size() == nums.size())
    {
        result.push_back(path);
        return;
    }

    for (int i = 0; i < nums.size(); i++)
    {
        if (used[i])    continue;

        path.push_back(nums[i]);
        used[i] = true;

        backtracking(nums, used);

        path.pop_back();
        used[i] = false;
    }
}


int main()
{
    vector<int> nums = {1, 2, 3};
    vector<bool> used(nums.size(), false);
    backtracking(nums, used);

    for (int i = 0; i < result.size(); i++)
    {
        for (int val : result[i])
        {
            cout << val << " ";
        }
        cout << endl;
    }

    return 0;
}
~~~





## 131 [åˆ†å‰²å›æ–‡ä¸²](https://leetcode.cn/problems/palindrome-partitioning/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250801224310817](pic/image-20250801224310817.png)

![image-20250801224424477](pic/image-20250801224424477.png)

![image-20250801224455357](pic/image-20250801224455357.png)

![image-20250801224459434](pic/image-20250801224459434.png)

![image-20250801224717358](pic/image-20250801224717358.png)

~~~C++
class Solution {
public:

    // åˆ¤æ–­å›æ–‡
    bool isPalindrome(const string& s, int start, int end)
    {
        for (int i = start, j = end; i < j; i++, j--)
        {
            if (s[i] != s[j])   return false;
        }

        return true;
    }


    vector<string> path;
    vector<vector<string>> result;

    void backtracking(const string& s, int startIndex) 
    {
        // startIndex ä¸‹ä¸€è½®é€’å½’éå†çš„èµ·å§‹ä½ç½®
        // ç»ˆæ­¢ï¼šå¦‚æœèµ·å§‹ä½ç½®å·²ç»è¶…å‡ºsï¼Œè¯´æ˜å·²ç»æ‰¾åˆ°ä¸€ç»„åˆ†å‰²æ–¹æ¡ˆ
        if (startIndex >= s.size())
        {
            result.push_back(path);
            return;
        }

        for (int i = startIndex; i < s.size(); i++)
        {
            if (isPalindrome(s, startIndex, i)) // åˆ¤æ–­[startIndex, i]éƒ¨åˆ†æ˜¯å¦å›æ–‡
            {
                // æ˜¯å›æ–‡ï¼Œæˆªå–[startIndex, i]
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            }
            else    continue; // ä¸æ˜¯å›æ–‡ï¼Œç›´æ¥è·³è¿‡è¿™ä¸€åˆ†æ”¯

            backtracking(s, i + 1);
            path.pop_back();
        }

    }


    vector<vector<string>> partition(string s) {

        backtracking(s, 0);
        return result;        
    }
};
~~~





ACM

~~~C++
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// 131 åˆ†å‰²å›æ–‡ä¸²


// åˆ¤æ–­å›æ–‡
bool isPalindrome(const string& s, int start, int end)
{
    for (int i = start, j = end; i < j; i++, j--)
    {
        if (s[i] != s[j])   return false;
    }
    return true;
}


vector<string> path;
vector<vector<string>> result;

// é€’å½’
void backtracking(const string& s, int startIndex) 
{
    // startIndex ä¸‹ä¸€è½®é€’å½’éå†çš„èµ·å§‹ä½ç½®
    // ç»ˆæ­¢ï¼šå¦‚æœèµ·å§‹ä½ç½®å·²ç»è¶…å‡ºsï¼Œè¯´æ˜å·²ç»æ‰¾åˆ°ä¸€ç»„åˆ†å‰²æ–¹æ¡ˆ
    if (startIndex >= s.size())
    {
        result.push_back(path);
        return;
    }
    for (int i = startIndex; i < s.size(); i++)
    {
        if (isPalindrome(s, startIndex, i)) // åˆ¤æ–­[startIndex, i]éƒ¨åˆ†æ˜¯å¦å›æ–‡
        {
            // æ˜¯å›æ–‡ï¼Œæˆªå–[startIndex, i]
            string str = s.substr(startIndex, i - startIndex + 1);
            path.push_back(str);
        }
        else    continue; // ä¸æ˜¯å›æ–‡ï¼Œç›´æ¥è·³è¿‡è¿™ä¸€åˆ†æ”¯
        backtracking(s, i + 1);
        path.pop_back();
    }
}


vector<vector<string>> partition(string s) {
    backtracking(s, 0);
    return result;        
}


int main()
{
    string s = "aab";
    vector<vector<string>> ans = partition(s);
    for (int i = 0; i < ans.size(); i++)
    {
        for (string s : ans[i])     cout << s << " , ";
        cout << endl;
    }

    return 0;
}
~~~



## 51 [Nçš‡å](https://leetcode.cn/problems/n-queens/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250801233719344](pic/image-20250801233719344.png)

![image-20250801233800763](pic/image-20250801233800763.png)

![image-20250801233827062](pic/image-20250801233827062.png)

![image-20250801233833459](pic/image-20250801233833459.png)



![image-20250801233913833](pic/image-20250801233913833.png)

![image-20250801234013613](pic/image-20250801234013613.png)



![image-20250802000256173](pic/image-20250802000256173.png)



~~~C++
class Solution {
public:

    // éªŒè¯æ£‹ç›˜æ˜¯å¦åˆæ³•
    // ä¸èƒ½åŒè¡Œ åŒåˆ— åŒæ–œçº¿ï¼ˆ45åº¦å’Œ135åº¦è§’ï¼‰
    bool isValid(int row, int col, vector<string>& chessboard, int n)
    {
        // chessboard - n * n æ£‹ç›˜

        // æ£€æŸ¥åˆ—
        for (int i = 0; i < row; i++)
        {
            if (chessboard[i][col] == 'Q')  return false;
        }
        // æ£€æŸ¥ 45åº¦
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)
        {
            if (chessboard[i][j] == 'Q')    return false;
        }
        // æ£€æŸ¥ 135åº¦
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++)
        {
            if (chessboard[i][j] == 'Q')    return false;
        }
        
        return true;
    }


    vector<vector<string>> result;
    
    void backtracking(int n, int row, vector<string>& chessboard)
    {
        // n - æ£‹ç›˜å¤§å°
        // row - å½“å‰éå†åˆ°æ£‹ç›˜ç¬¬å‡ å±‚äº†
        // chessboard - n * n æ£‹ç›˜

        if (row == n) // ç»ˆæ­¢ï¼šéå†åˆ°æœ€åä¸€è¡Œ
        {
            result.push_back(chessboard);
            return;
        }

        for (int col = 0; col < n; col++) // col éå†æ¯ä¸€åˆ— å¾€å³èµ°
        {
            if (isValid(row, col, chessboard, n))// å½“å‰æ£‹ç›˜åˆæ³•ï¼Œç»§ç»­æ”¾ Q
            {
                chessboard[row][col] = 'Q';
                backtracking(n, row + 1, chessboard); // é€’å½’ å¾€ä¸‹èµ° row + 1
                chessboard[row][col] = '.'; // å›æº¯
            }

            // æ£‹ç›˜ä¸åˆæ³•ï¼Œæ”¾å¼ƒå½“å‰åˆ†æ”¯ï¼Œç›´æ¥å¾€å³èµ°
        }
    }


    vector<vector<string>> solveNQueens(int n) {

        vector<string> chessboard(n, string(n, '.')); // åˆå§‹æ£‹ç›˜
        backtracking(n, 0, chessboard);
        return result;        
    }
};
~~~



ACM 

~~~C++
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// 51 Nçš‡å

// éªŒè¯æ£‹ç›˜æ˜¯å¦åˆæ³•
// ä¸èƒ½åŒè¡Œ åŒåˆ— åŒæ–œçº¿ï¼ˆ45åº¦å’Œ135åº¦è§’ï¼‰
bool isValid(int row, int col, vector<string>& chessboard, int n)
{
    // chessboard - n * n æ£‹ç›˜
    // æ£€æŸ¥åˆ—
    for (int i = 0; i < row; i++)
    {
        if (chessboard[i][col] == 'Q')  return false;
    }
    // æ£€æŸ¥ 45åº¦
    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)
    {
        if (chessboard[i][j] == 'Q')    return false;
    }
    // æ£€æŸ¥ 135åº¦
    for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++)
    {
        if (chessboard[i][j] == 'Q')    return false;
    }
    
    return true;
}



vector<vector<string>> result;
// é€’å½’
void backtracking(int n, int row, vector<string>& chessboard)
{
    // n - æ£‹ç›˜å¤§å°
    // row - å½“å‰éå†åˆ°æ£‹ç›˜ç¬¬å‡ å±‚äº†
    // chessboard - n * n æ£‹ç›˜
    if (row == n) // ç»ˆæ­¢ï¼šéå†åˆ°æœ€åä¸€è¡Œ
    {
        result.push_back(chessboard);
        return;
    }
    for (int col = 0; col < n; col++) // col éå†æ¯ä¸€åˆ— å¾€å³èµ°
    {
        if (isValid(row, col, chessboard, n))// å½“å‰æ£‹ç›˜åˆæ³•ï¼Œç»§ç»­æ”¾ Q
        {
            chessboard[row][col] = 'Q';
            backtracking(n, row + 1, chessboard); // é€’å½’ å¾€ä¸‹èµ° row + 1
            chessboard[row][col] = '.'; // å›æº¯
        }

        // æ£‹ç›˜ä¸åˆæ³•ï¼Œæ”¾å¼ƒå½“å‰åˆ†æ”¯ï¼Œç›´æ¥å¾€å³èµ°
    }
}


vector<vector<string>> solveNQueens(int n) {
    vector<string> chessboard(n, string(n, '.')); // åˆå§‹æ£‹ç›˜
    backtracking(n, 0, chessboard);
    return result;        
}

int main()
{
    int n = 4;
    vector<vector<string>> ans = solveNQueens(n);
    for (int i = 0; i < ans.size(); i++)
    {
        for (string s : ans[i])     cout << s << endl;
        cout << endl;
    }

    return 0;
}
~~~









## 22 [æ‹¬å·ç”Ÿæˆ](https://leetcode.cn/problems/generate-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250731111344522](pic/image-20250731111344522.png)



==**é‡ç‚¹ï¼šå³æ‹¬å·ä¸ªæ•° <= å·¦æ‹¬å·ä¸ªæ•° ï¼ï¼ï¼ï¼ï¼ï¼**==



### 1ã€é€‰æˆ–ä¸é€‰

![image-20250801220213092](pic/image-20250801220213092.png)

![image-20250801223635506](pic/image-20250801223635506.png)

![image-20250801220030102](pic/image-20250801220030102.png)

è¿™é‡Œæ˜¯ç›´æ¥è¦†ç›–æ—§å€¼çš„ï¼Œç›¸å½“äºåŸæ¥çš„ã€æ’¤é”€ + æ’å…¥æ–°å€¼ã€‘äº†ã€‚



~~~C++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> ans;
        string path(n * 2, 0); // nå¯¹æ‹¬å·

        // left right æ˜¯å·¦å³æ‹¬å·çš„æ•°é‡
        auto dfs = [&](this auto&& dfs, int left, int right) ->void
        {
            // ç»ˆæ­¢ï¼šå³æ‹¬å·å¡«äº†nä¸ªï¼Œå·¦æ‹¬å·ä¸€å®šä¹Ÿå¡«äº†nä¸ªï¼Œæ‰€ä»¥æ­¤æ—¶å¡«å®Œ2nä¸ªæ‹¬å·
            if (right == n) 
            {
                ans.emplace_back(path);
                return;
            }
            
            if (left < n) // å·¦æ‹¬å·å°‘äºnä¸ªï¼Œå¯ä»¥å¡«å·¦æ‹¬å·
            {
                path[left + right] = '('; // ç›´æ¥è¦†ç›–
                dfs(left + 1, right);
            }
            if (right < left) // å¯ä»¥å¡«å³æ‹¬å·
            {
                path[left + right] = ')'; // ç›´æ¥è¦†ç›–
                dfs(left, right + 1);
            }
        };

        dfs(0, 0);
        return ans;
    }
};
~~~





### 2ã€æšä¸¾å³æ‹¬å·ä¸ªæ•°ï¼Œç¡®å®šä¸‹ä¸€ä¸ªå·¦æ‹¬å·ä½ç½®

![image-20250731114014059](pic/image-20250731114014059.png)

**é‡ç‚¹ï¼šå³æ‹¬å·ä¸ªæ•° <= å·¦æ‹¬å·ä¸ªæ•° ï¼ï¼ï¼ï¼ï¼ï¼**

balance =  å·²å¡«çš„å·¦æ‹¬å·çš„ä¸ªæ•° - å³æ‹¬å·çš„ä¸ªæ•°ï¼Œä¸ºäº†ä¿è¯**ã€å³æ‹¬å·ä¸ªæ•° <= å·¦æ‹¬å·ä¸ªæ•°ã€‘**

![image-20250801215836724](pic/image-20250801215836724.png)

~~~C++
class Solution {
public:
    vector<string> generateParenthesis(int n) {

        vector<string> ans;
        vector<int> leftIndex; // è®°å½•å·¦æ‹¬å·çš„ä¸‹æ ‡

        // i:       ç›®å‰å¡«äº† i ä¸ªæ‹¬å·
        // balance: è¿™ i ä¸ªæ‹¬å·ä¸­, å·¦æ‹¬å·ä¸ªæ•° - å³æ‹¬å·ä¸ªæ•° = balanceï¼Œä¸ºäº†ä¿è¯å·¦æ‹¬å· > å³
        auto dfs = [&](this auto&& dfs, int i, int balance)
        {
            // ç»ˆæ­¢ï¼šå·¦æ‹¬å·ä¸‹æ ‡çš„ä¸ªæ•° = nï¼Œå·¦æ‹¬å·ç¡®å®šäº† n ä¸ªä½ç½®ï¼Œå¡«å……å·¦æ‹¬å·
            if (leftIndex.size() == n) 
            {
                string s(n * 2, ')');
                for (int j : leftIndex)  s[j] = '('; // å·¦æ‹¬å·ä¸‹æ ‡å¤„æ”¹æˆ '('

                ans.emplace_back(s); // æ”¶é›†
                return;
            }


            // æšä¸¾å¡« right = 0,1,2,3...,balance ä¸ªå³æ‹¬å·
            // balance çº¦æŸ  å³æ‹¬å·çš„ä¸ªæ•°ï¼Œä¸€å®šè¦ <= å·¦æ‹¬å·ï¼Œ
            // åœ¨ balance çš„çº¦æŸä¸‹ï¼Œæšä¸¾å¡« 1 ä¸ª ')'ï¼Œå¡« 2 ä¸ª ')', ... ä¹‹åï¼Œå·¦æ‹¬å·çš„ä¸‹æ ‡
            for (int right = 0; right <= balance; right++)
            {
                // å…ˆå¡« right ä¸ªå³æ‹¬å·ï¼Œç„¶åå¡« 1 ä¸ªå·¦æ‹¬å·ï¼Œè®°å½•å·¦æ‹¬å·çš„ä¸‹æ ‡ i + right
                leftIndex.push_back(i + right);
                dfs(i + right + 1, balance + (1 - right));
                leftIndex.pop_back();
            }
        };

        dfs(0, 0);
        return ans;        
    }
};
~~~



### ACM

~~~C++
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// 22 æ‹¬å·ç”Ÿæˆ


vector<string> generateParenthesis(int n) 
{
    vector<string> ans;
    string path(n * 2, 0);

    // è¾“å…¥å·²å¡«çš„ å·¦å³æ‹¬å·æ•°é‡
    auto dfs = [&](this auto&& dfs, int left, int right) ->void 
    {
        // ç»ˆæ­¢
        if (right == n)
        {
            ans.emplace_back(path);
            return;
        }
        if (left < n)
        {
            path[left + right] = '(';
            dfs(left + 1, right);
        }
        if (right < left)
        {
            path[left + right] = ')';
            dfs(left, right + 1);
        }
    };

    dfs(0, 0);
    return ans;
}

int main()
{
    int n = 3;
    vector<string> ans = generateParenthesis(n);

    for (string s : ans)
    {
        cout << s  << " , ";
    }
    cout << endl;
    
    return 0;
}
~~~



## 79 [å•è¯æœç´¢](https://leetcode.cn/problems/word-search/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250803110156692](pic/image-20250803110156692.png)

![image-20250803110223074](pic/image-20250803110223074.png)



### dfs

![image-20250803165202409](pic/image-20250803165202409.png)



~~~C++	
class Solution {
public:
    // æ–¹å‘æ•°ç»„ ä¸‹ ä¸Š å³ å·¦
    static constexpr int DIRS[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    bool exist(vector<vector<char>>& board, string word) {
        int m = board.size();
        int n = board[0].size();
        
        auto dfs = [&](this auto&& dfs, int i, int j, int k)->bool{
            if (board[i][j] != word[k]) return false; // åŒ¹é…å¤±è´¥

            if (k + 1 == word.size())   return true;  // åŒ¹é…æˆåŠŸ

            board[i][j] = 0; // æ ‡è®°è®¿é—®è¿‡
            for (auto& [dx, dy] : DIRS) // å››ä¸ªæ–¹å‘çš„ç›¸é‚»æ ¼å­
            {
                int x = i + dx, y = j + dy; 
                // æ²¡è¶…è¿‡è¾¹ç•Œï¼Œå¹¶ä¸”ååºå­—æ¯éƒ½æˆåŠŸåŒ¹é…
                if (0 <= x && x < m && 0 <= y && y < n && dfs(x, y, k + 1))
                {
                    return true;
                }
            }

            board[i][j] = word[k]; // æ¢å¤
            
            return false; // æ²¡æœåˆ°
        };


        // æ¯ä¸ªæ ¼å­éƒ½å¯ä»¥ä½œä¸ºèµ·ç‚¹
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (dfs(i, j, 0))   return true;// æœåˆ°äº†
            }
        }

        return false; // æ²¡æœåˆ°
        
    }
};
~~~



### ä¼˜åŒ–å‰ªæ

![image-20250803171053612](pic/image-20250803171053612.png)



~~~C++	
class Solution {
public:
    static constexpr int DIRS[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    bool exist(vector<vector<char>>& board, string word) 
    {
        unordered_map<char, int> board_cnt; // æ”¶é›†boardä¸­æ¯ä¸ªå­—ç¬¦çš„ä¸ªæ•°
        for (int i = 0; i < board.size(); i++)
        {
            for (char c : board[i])  board_cnt[c]++;
        }

        // ä¼˜åŒ–ä¸€ï¼šwordä¸­æŸä¸ªå­—ç¬¦cçš„ä¸ªæ•°ï¼Œè¶…è¿‡boardä¸­è¿™ä¸ªå­—ç¬¦çš„ä¸ªæ•°ï¼Œç›´æ¥false
        unordered_map<char, int> word_cnt;
        for (char c : word)
        {
            if (++word_cnt[c] > board_cnt[c]) return false; 
        }

        // ä¼˜åŒ–äºŒï¼šå¦‚æœwordçš„æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œåœ¨boardä¸­çš„å‡ºç°æ¬¡æ•°è¾ƒå°‘ï¼Œåè½¬wordè¿›è¡Œæœç´¢
        if (board_cnt[word.back()] < board_cnt[word[0]])
        {
            ranges::reverse(word);
        }



        int m = board.size();
        int n = board[0].size();
        
        auto dfs = [&](this auto&& dfs, int i, int j, int k)->bool{
            if (board[i][j] != word[k]) return false; // åŒ¹é…å¤±è´¥

            if (k + 1 == word.size())   return true;  // åŒ¹é…æˆåŠŸ

            board[i][j] = 0; // æ ‡è®°è®¿é—®è¿‡
            for (auto& [dx, dy] : DIRS) // å››ä¸ªæ–¹å‘çš„ç›¸é‚»æ ¼å­
            {
                int x = i + dx, y = j + dy; 
                // æ²¡è¶…è¿‡è¾¹ç•Œï¼Œå¹¶ä¸”ååºå­—æ¯éƒ½æˆåŠŸåŒ¹é…
                if (0 <= x && x < m && 0 <= y && y < n && dfs(x, y, k + 1))
                {
                    return true;
                }
            }

            board[i][j] = word[k]; // æ¢å¤
            
            return false; // æ²¡æœåˆ°
        };


        // æ¯ä¸ªæ ¼å­éƒ½å¯ä»¥ä½œä¸ºèµ·ç‚¹
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (dfs(i, j, 0))   return true;// æœåˆ°äº†
            }
        }

        return false; // æ²¡æœåˆ°
        
    }
};
~~~



### ACM

~~~C++	
#include <iostream>
#include <vector>
#include <string>
#include <unordered_map>
#include <algorithm>
using namespace std;


// 79 å•è¯æœç´¢

const int DIRS[4][2] = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}};

bool existWord(vector<vector<char>>& board, string word)
{
    unordered_map<char, int> board_cnt;
    for (int i = 0; i < board.size(); i++)
    {
        for (char c : board[i])     board_cnt[c]++;
    }

    unordered_map<char, int> word_cnt;
    for (char c : word)
    {
        word_cnt[c]++;
    }

    for (char c : word)
    {
        if (word_cnt[c] > board_cnt[c]) return false;
    }     

    if (board_cnt[word.back()] < board_cnt[word[0]])    reverse(word.begin(), word.end());


    int m = board.size();
    int n = board[0].size();

    auto dfs = [&](this auto&& dfs, int i, int j, int k)->bool
    {
        if (board[i][j] != word[k]) return false;
        if (k == word.size() - 1)   return true;

        board[i][j] = 0;
        for (auto& [dx, dy] : DIRS)
        {
            int x = i + dx, y = j + dy;
            if (0 <= x && x < m && 0 <= y && y < n && dfs(x, y, k + 1))     return true;
        }

        board[i][j] = word[k];
        
        return false;
    };

    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (dfs(i, j, 0))   return true;
        }
    }

    return false;
}


int main()
{
    vector<vector<char>> board = {
        {'A','B','C','E'},
        {'S','F','C','S'},
        {'A','D','E','E'}};
    
    string word = "ABCCED";
    bool ans = existWord(board, word);
    cout << (ans ? "true" : "false") << endl;

    return 0;
}
~~~





# äºŒåˆ†æŸ¥æ‰¾ âœ…

## 35 [æœç´¢æ’å…¥ä½ç½®](https://leetcode.cn/problems/search-insert-position/?envType=study-plan-v2&envId=top-100-liked)

![image-20250727231303073](pic/image-20250727231303073.png)

æ¯”704ã€äºŒåˆ†æŸ¥æ‰¾å¤šäº†ä¸€ä¸ªè¿”å›æ’å…¥ä½ç½®

~~~C++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        
        int left = 0;
        int right = nums.size() - 1; // [left, right] å·¦é—­å³é—­

        while (left <= right)
        {
            int mid = left + ((right - left) / 2); // é˜²æº¢å‡º

            if      (nums[mid] > target)    right = mid - 1;
            else if (nums[mid] < target)    left = mid + 1;
            else    return mid;
        }

        return right + 1; // è¿”å›æ’å…¥ä½ç½®   
        
        // return left; ä¹Ÿå¯ä»¥

        // äºŒåˆ†æŸ¥æ‰¾é€€å‡ºwhileæ—¶çš„çŠ¶æ€æ˜¯ left > right
        // left  æŒ‡å‘æ’å…¥ä½ç½®
        // right æŒ‡å‘æ¯”targetå°çš„æœ€å¤§å€¼
        // right + 1 ç­‰ä»·ä¸ left  
    }
};
~~~



## 74 [æœç´¢äºŒç»´çŸ©é˜µ](https://leetcode.cn/problems/search-a-2d-matrix/?envType=study-plan-v2&envId=top-100-liked)

![image-20250727233530173](pic/image-20250727233530173.png)

![image-20250727233543858](pic/image-20250727233543858.png)

[çµç¥](https://leetcode.cn/problems/search-a-2d-matrix/solutions/2783931/liang-chong-fang-fa-er-fen-cha-zhao-pai-39d74)

### 1ã€äºŒåˆ†

çŸ©é˜µæ¯ä¸€è¡Œæ‹¼åœ¨ä¸€èµ·ï¼Œæ‹¼æˆä¸€ä¸ªé€’å¢æ•°ç»„ï¼Œå†äºŒåˆ†ã€‚

ä½†æ˜¯ä¸ç”¨çœŸæ‹¼æˆä¸€ä¸ªæ•°ç»„ï¼Œè€Œæ˜¯ç”¨åæ ‡è¿èµ·æ¥

![image-20250728102218323](pic/image-20250728102218323.png)

<img src="pic/image-20250728103240713.png" alt="image-20250728103240713" style="zoom:50%;" />

~~~C++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {

        int m = matrix.size();
        int n = matrix[0].size();

        int left = 0;
        int right = m * n - 1; // ç›¸å½“äºéå†æ‹¼æ¥æˆçš„ a[i] ä» 0 åˆ° m*n 
        while (left <= right)
        {
            int mid = left + ((right - left) / 2);

            int midNum = matrix[mid / n][mid % n];//å–å‡ºa[mid] = matrix[mid/n][mid%n]
            
            if (midNum < target)    left = mid + 1;
            else if (midNum > target)   right = mid - 1;
            else    return true;
        }

        return false;
    }
};
~~~

- æ—¶é—´å¤æ‚åº¦ï¼šO(log(*mn*))ï¼Œå…¶ä¸­ *m* å’Œ *n* åˆ†åˆ«ä¸º *matrix* çš„è¡Œæ•°å’Œåˆ—æ•°ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ã€‚





### 2ã€å³ä¸Šè§’æ’é™¤

è¿™é‡Œä¸»è¦æ˜¯ä¸ºäº†æ¥ 240ã€æœç´¢äºŒç»´çŸ©é˜µIIï¼Œè¿˜æ˜¯æ¨èäºŒåˆ†æ³•

<img src="pic/image-20250728104152041.png" alt="image-20250728104152041" style="zoom: 33%;" />

~~~C++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {

        int m = matrix.size();
        int n = matrix[0].size();

        int i = 0;      // ç¬¬iè¡Œ
        int j = n - 1;  // ç¬¬jåˆ—
        while (i < m && j >= 0)
        {
            
            if      (matrix[i][j] < target)     i++; // è¯´æ˜è¿™ä¸€è¡Œéƒ½å°äºtarget
            else if (matrix[i][j] > target)     j--; // å¾€å‰èµ°ä¸€åˆ—
            else    return true; // matrix[i][j] == target
        }
        
        return false;
    }
};
~~~

- æ—¶é—´å¤æ‚åº¦ï¼šO(*m*+*n*)ï¼Œå…¶ä¸­ *m* å’Œ *n* åˆ†åˆ«ä¸º *matrix* çš„è¡Œæ•°å’Œåˆ—æ•°ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ã€‚



## 34 [åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/?envType=study-plan-v2&envId=top-100-liked)

![image-20250728114911125](pic/image-20250728114911125.png)

![image-20250728114928976](pic/image-20250728114928976.png)

![image-20250728114936668](pic/image-20250728114936668.png)

![image-20250728114942560](pic/image-20250728114942560.png)

~~~C++
class Solution {
public:

    // nums = [5,  7,  7,  8,  8,  10], target = 8
    //                 |            |
    //            leftBorder     rightBorder


    // æ‰¾ç¬¬ä¸€ä¸ªæ¯” target å¤§çš„ä½ç½®
    int getRightBorder(vector<int>& nums, int target)
    {
        int left = 0;
        int right = nums.size() - 1;
        
        // å½“å‰ç¬¬ä¸€ä¸ªå¤§äº target çš„ä½ç½®
        int rightBorder = -2; // -2 è®°å½•rightBorderæ²¡æœ‰è¢«èµ‹å€¼çš„æƒ…å†µ
        while (left <= right)
        {
            int mid = left + ((right - left) / 2);
            if (nums[mid] <= target) // å‘å³ç¼©å°èŒƒå›´
            {
                left = mid + 1;
                rightBorder = left;// æ–°çš„leftå°±æ˜¯ä¸‹ä¸€ä¸ªå¯èƒ½å¤§äºtargetçš„ä½ç½®
            }
            else 
            {
                right = mid - 1; 
            }
        }
        return rightBorder;
    }

    // æ‰¾æœ€åä¸€ä¸ªæ¯” target å°çš„ä½ç½®
    int getLeftBorder(vector<int>& nums, int target)
    {
        int left = 0;
        int right = nums.size() - 1;
        
        // æœ€åä¸€ä¸ªæ¯” target å°çš„ä½ç½®
        int leftBorder = -2; 
        while (left <= right)
        {
            int mid = left + ((right - left) / 2); 
            if (target <= nums[mid]) // å‘å·¦ç¼©å°èŒƒå›´
            {
                right = mid - 1;
                leftBorder = right; // æ–°right å°±æ˜¯ä¸‹ä¸€ä¸ªå¯èƒ½å°äº target çš„ä½ç½®
            }
            else 
            {
                left = mid + 1;
            }
        }
        return leftBorder;
    }


    vector<int> searchRange(vector<int>& nums, int target) {

        int leftBorder = getLeftBorder(nums, target);
        int rightBorder = getRightBorder(nums, target);


        // æƒ…å†µä¸€ï¼štarget åœ¨æ•°ç»„èŒƒå›´çš„å³è¾¹æˆ–è€…å·¦è¾¹ï¼Œä¸å†æ•°ç»„èŒƒå›´ä¸­
        if (leftBorder == -2 || rightBorder== -2)   return {-1, -1};

        
        // æƒ…å†µä¸‰ï¼štarget åœ¨æ•°ç»„èŒƒå›´ä¸­ï¼Œä¸”æ•°ç»„ä¸­å­˜åœ¨target
        if (rightBorder - leftBorder > 1)   return {leftBorder + 1, rightBorder - 1};
        
        
        // æƒ…å†µäºŒï¼štarget åœ¨æ•°ç»„èŒƒå›´ä¸­ï¼Œä¸”æ•°ç»„ä¸­ä¸å­˜åœ¨target
        return {-1, -1};

        
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <vector>
using namespace std;


// 34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®


// nums = [5,  7,  7,  8,  8,  10], target = 8
//                 |            |
//            leftBorder     rightBorder


// æ‰¾ç¬¬ä¸€ä¸ªæ¯” target å¤§çš„ä½ç½® rightBorder
int getRightBorder(vector<int>& nums, int target)
{
    int left = 0;
    int right = nums.size() - 1;
    
    // å½“å‰ç¬¬ä¸€ä¸ªå¤§äº target çš„ä½ç½®
    int rightBorder = -2; // -2 è®°å½•rightBorderæ²¡æœ‰è¢«èµ‹å€¼çš„æƒ…å†µ
    while (left <= right)
    {
        int mid = left + ((right - left) / 2);
        if (nums[mid] <= target) // å‘å³ç¼©å°èŒƒå›´
        {
            left = mid + 1;
            rightBorder = left;// æ–°çš„leftå°±æ˜¯ä¸‹ä¸€ä¸ªå¯èƒ½å¤§äºtargetçš„ä½ç½®
        }
        else 
        {
            right = mid - 1; 
        }
    }
    return rightBorder;
}


// æ‰¾æœ€åä¸€ä¸ªæ¯” target å°çš„ä½ç½® leftBorder
int getLeftBorder(vector<int>& nums, int target)
{
    int left = 0;
    int right = nums.size() - 1;
    
    // æœ€åä¸€ä¸ªæ¯” target å°çš„ä½ç½®
    int leftBorder = -2; 
    while (left <= right)
    {
        int mid = left + ((right - left) / 2); 
        if (target <= nums[mid]) // å‘å·¦ç¼©å°èŒƒå›´
        {
            right = mid - 1;
            leftBorder = right; // æ–°right å°±æ˜¯ä¸‹ä¸€ä¸ªå¯èƒ½å°äº target çš„ä½ç½®
        }
        else 
        {
            left = mid + 1;
        }
    }
    return leftBorder;
}


vector<int> searchRange(vector<int>& nums, int target) 
{
    int leftBorder = getLeftBorder(nums, target);
    int rightBorder = getRightBorder(nums, target);

    // æƒ…å†µä¸€ï¼štarget åœ¨æ•°ç»„èŒƒå›´çš„å³è¾¹æˆ–è€…å·¦è¾¹ï¼Œä¸å†æ•°ç»„èŒƒå›´ä¸­
    if (leftBorder == -2 || rightBorder== -2)   return {-1, -1};
    
    // æƒ…å†µä¸‰ï¼štarget åœ¨æ•°ç»„èŒƒå›´ä¸­ï¼Œä¸”æ•°ç»„ä¸­å­˜åœ¨target
    if (rightBorder - leftBorder > 1)   return {leftBorder + 1, rightBorder - 1};
    
    
    // æƒ…å†µäºŒï¼štarget åœ¨æ•°ç»„èŒƒå›´ä¸­ï¼Œä¸”æ•°ç»„ä¸­ä¸å­˜åœ¨target
    return {-1, -1};
    
}

int main()
{
    vector<int> nums = {5, 7, 7, 8, 8, 10};
    int target = 8;
    vector<int> ans = searchRange(nums, target); // [3, 4]
    for (int val : ans)
    {
        cout << val << " ";
    }
    cout << endl;

    return 0;
}
~~~



## 153 [å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250729145936680](pic/image-20250729145936680.png)

å¯ä»¥å…ˆçœ‹ [162 å³°å€¼](#162 [å¯»æ‰¾å³°å€¼](https://leetcode.cn/problems/find-peak-element/description/))



**ä¸»è¦æ€è·¯ï¼šæ¯”è¾ƒ nums[mid] å’Œæœ€åä¸€ä¸ªæ•°ï¼Œåˆ¤æ–­ mid å’Œ æœ€å°å€¼ çš„ä½ç½®ï¼ŒäºŒåˆ†æ”¶ç¼©**

- nums[mid] > æœ€åä¸€ä¸ªæ•°ï¼š
  - nums ä¸€å®šæ˜¯ä¸¤ä¸ªä¸Šå‡æ®µï¼Œç¬¬ä¸€æ®µ  >  ç¬¬äºŒæ®µ
  - **mid åœ¨ç¬¬ä¸€æ®µï¼Œmin åœ¨ç¬¬äºŒæ®µ**ï¼Œmin ä¸€å®šåœ¨ mid çš„**å³è¾¹**  â€“>  å‘å³æ”¶ç¼©
- nums[mid] <= æœ€åä¸€ä¸ªæ•°ï¼š
  - mid åœ¨ç¬¬äºŒæ®µï¼ˆæˆ–è€… nums åªæœ‰ä¸€æ®µï¼Œä¸€æ ·çš„ï¼‰ï¼Œæˆ–è€…è¯´ **mid å’Œ min åœ¨åŒä¸€æ®µ**
  - **min ä¸€å®šåœ¨mid å·¦ä¾§**ï¼Œæˆ–è€…å°±æ˜¯mid â€“> å‘å·¦æ”¶ç¼©



![image-20250729152923722](pic/image-20250729152923722.png)

~~~C++
class Solution {
public:
    int findMin(vector<int>& nums) {

        int n = nums.size();
        int left = 0;
        int right = n - 1;

        while (left <= right)
        {
            int mid = left + ((right - left) / 2);

            if (nums[mid] > nums[n - 1])    left = mid + 1;// midåœ¨ç¬¬ä¸€æ®µï¼Œminåœ¨ç¬¬äºŒæ®µ
            else    right = mid - 1; // mid å’Œ min åœ¨åŒä¸€æ®µï¼Œä¸” min åœ¨å·¦

        }

        return nums[left]; 
    }
};
~~~



ACM 

~~~C++
#include <iostream>
#include <vector>
using namespace std;

// 153 å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼


int findMin(vector<int>& nums) {

    int n = nums.size();
    int left = 0;
    int right = n - 1;

    while (left <= right)
    {
        int mid = left + ((right - left) / 2);

        if (nums[mid] > nums[n - 1])    left = mid + 1;// midåœ¨ç¬¬ä¸€æ®µï¼Œminåœ¨ç¬¬äºŒæ®µ
        else    right = mid - 1; // mid å’Œ min åœ¨åŒä¸€æ®µï¼Œä¸” min åœ¨å·¦

    }

    return nums[left]; 
}


int main()
{
    vector<int> nums = {3, 4, 5, 1, 2};
    int ans = findMin(nums);
    cout << ans << endl;

    return 0;
}
~~~







## 33 [æœç´¢æ—‹è½¬æ’åºæ•°ç»„](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250729102714988](pic/image-20250729102714988.png)

> å‰æé¢˜ç›®ï¼šå¯ä»¥å…ˆçœ‹ 162 å³°å€¼ï¼Œ153 å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„çš„æœ€å°å€¼

### 1ã€ä¸¤æ¬¡äºŒåˆ†

![image-20250729154124632](pic/image-20250729154124632.png)

~~~C++
class Solution {
public:
    // æ‰¾æ—‹è½¬æ’åºæ•°ç»„çš„æœ€å°å€¼ä¸‹æ ‡ï¼ˆ153ï¼‰
    int findMin(vector<int>& nums) {
        int n = nums.size();
        int left = 0;
        int right = n - 1;
        while (left <= right)
        {
            int mid = left + ((right - left) / 2);
            if (nums[mid] > nums[n - 1])    left = mid + 1;// midåœ¨ç¬¬ä¸€æ®µï¼Œminåœ¨ç¬¬äºŒæ®µ
            else    right = mid - 1; // mid å’Œ min åœ¨åŒä¸€æ®µï¼Œä¸” min åœ¨å·¦
        }
        return left; 
    }

    // [left, right]äºŒåˆ†ï¼Œæ‰¾targetä¸‹æ ‡
    int searchTarget(vector<int>& nums, int target, int left, int right) {
        while (left <= right)
        {
            int mid = left + ((right - left) / 2); 
            if      (nums[mid] > target)    right = mid - 1;
            else if (nums[mid] < target)    left = mid + 1;
            else    return mid;
        }
        return -1; // æ²¡æ‰¾åˆ°è¿”å›-1  
    }

    
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        int ans = 0;
        int left = 0;
        int right = n - 1;

        int min_index = findMin(nums); // æ‰¾åˆ°æœ€å°å€¼ï¼ŒåŒºåˆ†ç¬¬ä¸€æ®µç¬¬äºŒæ®µ

        if (target > nums[n - 1])  // target åœ¨ç¬¬ä¸€æ®µï¼Œ[0, min_index-1], å‘å·¦æ”¶ç¼© 
        { 
            right = min_index - 1;
            ans = searchTarget(nums, target, left, right);         
        }
        else // target <= nums[n - 1] target åœ¨ç¬¬äºŒæ®µï¼Œ[min_index, n-1]ï¼Œå‘å³æ”¶ç¼©  
        {
            left = min_index;
            ans = searchTarget(nums, target, left, right);

            // æ³¨æ„è¿™é‡Œè¦å¸¦ç€minåˆ¤æ–­, targetæœ‰å¯èƒ½å°±æ˜¯min
        }

        return ans;        
    }
};
~~~



### 2ã€ä¸€æ¬¡äºŒåˆ†(æ¨è)

ç›´æ¥åˆ¤æ–­ target å’Œ mid çš„å·¦å³å…³ç³»ï¼Œåˆ†æˆtargetå’Œmidåœ¨ä¸åœ¨åŒä¸€æ®µä¸¤ç§æƒ…å†µ

- ä¸åœ¨åŒä¸€æ®µï¼Œåˆ† mid åœ¨ target å·¦è¿˜æ˜¯å³
- åœ¨åŒä¸€æ®µï¼Œå°±æ˜¯æ™®é€šäºŒåˆ†æŸ¥æ‰¾äº†

~~~C++
class Solution {
public:
    int search(vector<int>& nums, int target) {

        int n = nums.size();
        int end = nums[n - 1];
        int left = 0;
        int right = n - 1;

        while (left <= right)
        {
            int mid = left + (right - left) / 2;

            // target å’Œ mid ä¸åœ¨åŒä¸€æ®µ
            if (target <= end && nums[mid] > end) // targetåœ¨å³åŠéƒ¨åˆ†ï¼Œmidåœ¨å·¦
            {
                left = mid + 1;
            }
            else if (target > end && nums[mid] <= end) // targetåœ¨å·¦åŠéƒ¨åˆ†ï¼Œmidåœ¨å³
            {
                right = mid - 1;
            }
            else // target å’Œ mid åœ¨åŒä¸€æ®µï¼ˆä¹ŸåŒ…æ‹¬äº†åªæœ‰ä¸€æ®µçš„æƒ…å†µï¼‰
            {
                if (target < nums[mid])         right = mid - 1;
                else if (target > nums[mid])    left = mid + 1;
                else    return mid;
            }
        }
        
        return -1;        
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <vector>
using namespace std;

// 33 æœç´¢æ—‹è½¬æ’åºæ•°ç»„


int searchTarget(vector<int>& nums, int target) 
{
    int n = nums.size();
    int end = nums[n - 1];
    int left = 0;
    int right = n - 1;

    while (left <= right)
    {
        int mid = left + (right - left) / 2;

        // target å’Œ mid ä¸åœ¨åŒä¸€æ®µ
        if (target <= end && nums[mid] > end) // targetåœ¨å³åŠéƒ¨åˆ†ï¼Œmidåœ¨å·¦
        {
            left = mid + 1;
        }
        else if (target > end && nums[mid] <= end) // targetåœ¨å·¦åŠéƒ¨åˆ†ï¼Œmidåœ¨å³
        {
            right = mid - 1;
        }
        else // target å’Œ mid åœ¨åŒä¸€æ®µï¼ˆä¹ŸåŒ…æ‹¬äº†åªæœ‰ä¸€æ®µçš„æƒ…å†µï¼‰
        {
            if (target < nums[mid])         right = mid - 1;
            else if (target > nums[mid])    left = mid + 1;
            else    return mid;
        }
    }
    
    return -1;        
}




int main()
{
    vector<int> nums = {4,5,6,7,0,1,2};
    int target = 0;

    int ans = searchTarget(nums, target);
    cout << ans << endl;

    return 0;
}
~~~





## 4 [å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°](https://leetcode.cn/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250729163051465](pic/image-20250729163051465.png)

[èƒŒå§](https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/2950686/tu-jie-xun-xu-jian-jin-cong-shuang-zhi-z-p2gd)

å¥½åƒçœ‹æ‡‚äº†



### 1ã€åŒæŒ‡é’ˆ

**ä¸­ä½æ•° â€”â€” å‡åˆ†æ•°ç»„ï¼Œèƒ½æŠŠä¸€ç»„æ•°å¹³å‡åˆ’åˆ†ä¸ºå¤§å°ç›¸ç­‰çš„ä¸¤éƒ¨åˆ†ã€‚**

å‡è®¾æœ‰**ä¸¤ä¸ªæ–°æ•°ç»„**ï¼Œå°±æ˜¯å‡åˆ†å®Œçš„é‚£ä¸¤ä¸ªæ•°ç»„ï¼Œç°åœ¨åˆ†åˆ«ä»é¢˜ç›®ç»™å®šçš„nums1 å’Œ nums2 ä¸­å–æ•°ï¼ˆä¸‹é¢ç”¨aå’Œbï¼‰ã€‚

æ‰¾ä¸­ä½æ•°ï¼Œè¦ä¿è¯**ç¬¬ä¸€ä¸ªæ–°æ•°ç»„çš„æœ€å¤§å€¼ <  ç¬¬äºŒä¸ªæ–°æ•°ç»„çš„æœ€å°å€¼**ï¼Œæ¥ç¼å¤„å°±æ˜¯è¦æ‰¾çš„ä¸­ä½æ•°ã€‚

å·¦å³éƒ½æ’å…¥ âˆ’âˆ å’Œ âˆ ï¼Œä¿è¯æ— è®º a å’Œ b æ˜¯ä»€ä¹ˆæ ·çš„ï¼Œä¸€å®šå­˜åœ¨ä¸€ä¸ª iï¼Œæ»¡è¶³ a i â‰¤ b j+1  ä¸” a i+1 >b j ã€‚

<img src="pic/image-20250729175844683.png" alt="image-20250729175844683" style="zoom:50%;" />

![image-20250729180032142](pic/image-20250729180032142.png)

![image-20250729180056845](pic/image-20250729180056845.png)

![image-20250729173653971](pic/image-20250729173653971.png)

![image-20250729180241532](pic/image-20250729180241532.png)

~~~C++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {

        if (nums1.size() > nums2.size())    swap(nums1, nums2); // ä¿è¯nums1æ˜¯å°‘çš„é‚£ä¸ª

        // m < n 
        int m = nums1.size(), n = nums2.size(); 

        // å·¦å³æ’ä¸Šè´Ÿæ— ç©·ï¼Œå’Œæ­£æ— ç©·
        nums1.insert(nums1.begin(), INT_MIN);
        nums1.push_back(INT_MAX);
        nums2.insert(nums2.begin(), INT_MIN);
        nums2.push_back(INT_MAX);

        // æšä¸¾ nums1 æœ‰ i ä¸ªæ•°åœ¨ç¬¬ä¸€ç»„
        // é‚£ä¹ˆ nums2 æœ‰ j = (m + n + 1) / 2 - i ä¸ªæ•°åœ¨ç¬¬ä¸€ç»„ 
        int i = 0;
        int j = (m + n + 1) / 2;
        while (true)
        {
            // æ‰¾åˆ°ç¬¬ä¸€ç»„éƒ½å°äºç¬¬äºŒç»„çš„æƒ…å†µ
            if (nums1[i] <= nums2[j + 1] && nums1[i + 1] > nums2[j])// å†™ >= ä¹Ÿå¯ä»¥
            {
                int max1 = max(nums1[i], nums2[j]);         // ç¬¬ä¸€ç»„çš„æœ€å¤§å€¼
                int min2 = min(nums1[i + 1], nums2[j + 1]); // ç¬¬äºŒç»„çš„æœ€å°å€¼

                if ( (m + n) % 2) // å¥‡æ•°ä¸ªï¼Œç¬¬ä¸€ç»„å¤šä¸€ä¸ªï¼Œmax1å°±æ˜¯ä¸­ä½æ•°
                {
                    return max1; 
                }
                else // å¶æ•°ä¸ªï¼Œæ¥ç¼å¤„åŒºå‡å€¼
                {
                    return (max1 + min2) / 2.0;
                }
            }

            // ç»§ç»­æšä¸¾
            i++;
            j--;
        }        
    }
};
~~~





### 2ã€äºŒåˆ†

æ˜å¤©å†çœ‹ï¼Œç¼“ç¼“è„‘å­ï¼Œå¤ªç‚¸è£‚äº†





### ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 4 å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„ä¸­çš„ä¸­ä½æ•°

double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {

    if (nums1.size() > nums2.size())    swap(nums1, nums2); // ä¿è¯nums1æ˜¯å°‘çš„é‚£ä¸ª

    // m < n 
    int m = nums1.size(), n = nums2.size(); 

    // å·¦å³æ’ä¸Šè´Ÿæ— ç©·ï¼Œå’Œæ­£æ— ç©·
    nums1.insert(nums1.begin(), INT_MIN);
    nums1.push_back(INT_MAX);
    nums2.insert(nums2.begin(), INT_MIN);
    nums2.push_back(INT_MAX);

    // æšä¸¾ nums1 æœ‰ i ä¸ªæ•°åœ¨ç¬¬ä¸€ç»„
    // é‚£ä¹ˆ nums2 æœ‰ j = (m + n + 1) / 2 - i ä¸ªæ•°åœ¨ç¬¬ä¸€ç»„ 
    int i = 0;
    int j = (m + n + 1) / 2;
    while (true)
    {
        // æ‰¾åˆ°ç¬¬ä¸€ç»„éƒ½å°äºç¬¬äºŒç»„çš„æƒ…å†µ
        if (nums1[i] <= nums2[j + 1] && nums1[i + 1] > nums2[j])// å†™ >= ä¹Ÿå¯ä»¥
        {
            int max1 = max(nums1[i], nums2[j]);         // ç¬¬ä¸€ç»„çš„æœ€å¤§å€¼
            int min2 = min(nums1[i + 1], nums2[j + 1]); // ç¬¬äºŒç»„çš„æœ€å°å€¼

            if ( (m + n) % 2) // å¥‡æ•°ä¸ªï¼Œç¬¬ä¸€ç»„å¤šä¸€ä¸ªï¼Œmax1å°±æ˜¯ä¸­ä½æ•°
            {
                return max1; 
            }
            else // å¶æ•°ä¸ªï¼Œæ¥ç¼å¤„åŒºå‡å€¼
            {
                return (max1 + min2) / 2.0;
            }
        }

        // ç»§ç»­æšä¸¾
        i++;
        j--;
    }        
}


int main()
{
    vector<int> nums1 = {1, 2};
    vector<int> nums2 = {3, 4};
    double result = findMedianSortedArrays(nums1, nums2);
    cout << result << endl;
}
~~~









## 69 [xçš„å¹³æ–¹æ ¹](https://leetcode.cn/problems/sqrtx/description/)

![image-20250911175903043](./pic/image-20250911175903043.png)

### 1ã€äºŒåˆ†

![image-20250911180546118](./pic/image-20250911180546118.png)

~~~C++
class Solution {
public:
    int mySqrt(int x) {
        
        // åœ¨ä¸­é—´è¿‡ç¨‹è®¡ç®—å¹³æ–¹çš„æ—¶å€™å¯èƒ½å‡ºç°æº¢å‡ºï¼Œæ‰€ä»¥ç”¨long long
        
        // x å¹³æ–¹æ ¹çš„æ•´æ•°éƒ¨åˆ† ans æ˜¯æ»¡è¶³ k^2 â‰¤x çš„æœ€å¤§ k å€¼

        // äºŒåˆ† 0 ~ xï¼Œæ‰¾åˆ°æœ€å¤§çš„ k
        int l = 0, r = x;
        int ans = -1;

        while (l <= r)
        {
            int mid = l + (r - l) / 2;
            if ((long long)mid * mid <= x)
            {
                ans = mid;
                l = mid + 1;
            }
            else 
            {
                r = mid - 1;
            }
        }

        return ans;        
    }
};
~~~



### 2ã€ç‰›é¡¿è¿­ä»£æ³•

åˆ©ç”¨åˆ‡çº¿é€¼è¿‘æ›²çº¿çš„æ–¹ç¨‹çš„è§£   [é¢˜è§£ ä»—å‰‘éª‘å£«](https://leetcode.cn/problems/sqrtx/solutions/1408932/by-zhang-jian-qi-shi-kaxt)

![image-20250911184031634](./pic/image-20250911184031634.png)



~~~C++
class Solution {
public:
    int mySqrt(int x) {

        int a = x;
        long long ans = x;

        while (ans * ans > x) // æ¨å‡ºæ¥çš„ x_n+1 çš„é€’æ¨å…¬å¼ï¼Œé€’æ¨ç›´åˆ°ans*ans<=x
        {
            ans = (ans + a / ans) / 2; 
        }

        return ans;
    }
};
~~~







# æ ˆ âœ…

## 20 [æœ‰æ•ˆçš„æ‹¬å·](https://leetcode.cn/problems/valid-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250725112258499](pic/image-20250725112258499.png)

> **æ³¨æ„çœ‹ç»™çš„ç¤ºä¾‹ï¼Œé¢˜ç›®æè¿°ä¸æ¸…æ¥š**
>
> **å¿…é¡»æ˜¯ â€œ ( [ { } ] )  [ ] â€ è¿™ç§æˆå¯¹çš„é¡ºåºï¼Œä¸èƒ½äº¤å‰æ”¾ä¸åŒç±»å‹çš„æ‹¬å·  â€œ [ ( ] ) â€**

**æ ˆæ¥å­˜å‚¨å­—ç¬¦ä¸²sé‡Œçš„æ‹¬å·ï¼š**

éå†s

- æ ¹æ®sé‡Œçš„å·¦æ‹¬å·ï¼Œå¾€æ ˆé‡Œæ”¾å¯¹åº”çš„å³æ‹¬å·ï¼›

- é‡åˆ°sé‡Œçš„å³æ‹¬å·ï¼Œèƒ½å¯¹åº”ä¸Šæ ˆé¡¶å…ƒç´ ï¼Œå°±å¼¹å‡ºæ ˆé¡¶

<img src="pic/image-20250725110437842.png" alt="image-20250725110437842" style="zoom:33%;" />

ä¸åŒ¹é…çš„æƒ…å†µï¼š

- å·¦æ‹¬å·å¤šä½™ â€”â€” éå†å®Œå­—ç¬¦ä¸²ï¼Œä½†æ˜¯æ ˆä¸ä¸ºç©º
- æ‹¬å·ä¸åŒ¹é… â€”â€” å‘ç°æ ˆé‡Œæ²¡æœ‰è¦åŒ¹é…çš„å­—ç¬¦
- å³æ‹¬å·å¤šä½™ â€”â€” éå†å­—ç¬¦ä¸²åŒ¹é…çš„è¿‡ç¨‹ä¸­ï¼Œæ ˆå·²ç»ä¸ºç©ºäº†

åŒ¹é…çš„è¡¨ç°ï¼š

- **å­—ç¬¦ä¸²éå†å®Œï¼Œæ ˆä¹Ÿæ˜¯ç©ºçš„**



~~~C++
class Solution {
public:
    bool isValid(string s) {

        if (s.size() % 2 != 0)  return false; // å¦‚æœ s çš„é•¿åº¦æ˜¯å¥‡æ•°ï¼Œä¸€å®šä¸åŒ¹é…

        stack<char> st; // æ ¹æ® s çš„å·¦æ‹¬å·ï¼Œæ”¾å…¥ç›¸åº”çš„å³æ‹¬å·
        
        // ä¸‰ç§æƒ…å†µï¼š
        // 1 å·¦æ‹¬å·å¤šä½™ -- séå†å®Œï¼Œæ ˆä¸ä¸ºç©º
        // 2 æ‹¬å·ä¸åŒ¹é… -- séå†è¿‡ç¨‹ä¸­ï¼Œæ ˆé¡¶æ‹¬å·ä¸åŒ¹é…
        // 3 å³æ‹¬å·å¤šä½™ -- séå†è¿‡ç¨‹ä¸­ï¼Œæ ˆå·²ç»ç©º

        for (int i = 0; i < s.size(); i++)
        {
            // æ ¹æ® s é‡Œçš„å·¦æ‹¬å·ï¼Œå¾€æ ˆé‡ŒåŠ å…¥å¯¹åº”çš„å³æ‹¬å·
            if (s[i] == '(')        st.push(')');
            else if (s[i] == '[')   st.push(']');
            else if (s[i] == '{')   st.push('}');

            // ç¬¬3ç§ å’Œ ç¬¬2ç§ æƒ…å†µï¼Œç›´æ¥false ï¼ˆæ³¨æ„ifé‡Œé¡ºåºä¸èƒ½æ¢ï¼‰
            else if (st.empty() || st.top() != s[i])    return false; 

            // st.top() == s[i] éå†åˆ°å¯¹åº”çš„å³æ‹¬å·å°±å¼¹å‡ºæ ˆé¡¶
            else    st.pop();
        }

        // ç¬¬1ç§ æƒ…å†µï¼Œéå†å®Œsï¼Œä½†æ ˆä¸ä¸ºç©ºï¼Œè¿™é‡Œå°±è¿”å›false
        // å¦‚æœä¸ºç©ºï¼Œè¯´æ˜ç¬¦åˆè¦æ±‚ï¼Œè¿”å›çš„æ˜¯true
        return st.empty();
        
    }
};
~~~





ACM 

~~~C++
#include <string>
#include <iostream>
#include <stack>
using namespace std;

// 20 æœ‰æ•ˆçš„æ‹¬å·


bool isValid(string s) 
{
    if (s.size() % 2 != 0)  return false; // å¦‚æœ s çš„é•¿åº¦æ˜¯å¥‡æ•°ï¼Œä¸€å®šä¸åŒ¹é…

    stack<char> st; // æ ¹æ® s çš„å·¦æ‹¬å·ï¼Œæ”¾å…¥ç›¸åº”çš„å³æ‹¬å·
    
    // ä¸‰ç§æƒ…å†µï¼š
    // 1 å·¦æ‹¬å·å¤šä½™ -- séå†å®Œï¼Œæ ˆä¸ä¸ºç©º
    // 2 æ‹¬å·ä¸åŒ¹é… -- séå†è¿‡ç¨‹ä¸­ï¼Œæ ˆé¡¶æ‹¬å·ä¸åŒ¹é…
    // 3 å³æ‹¬å·å¤šä½™ -- séå†è¿‡ç¨‹ä¸­ï¼Œæ ˆå·²ç»ç©º

    for (int i = 0; i < s.size(); i++)
    {
        // æ ¹æ® s é‡Œçš„å·¦æ‹¬å·ï¼Œå¾€æ ˆé‡ŒåŠ å…¥å¯¹åº”çš„å³æ‹¬å·
        if (s[i] == '(')        st.push(')');
        else if (s[i] == '[')   st.push(']');
        else if (s[i] == '{')   st.push('}');

        // ç¬¬3ç§ å’Œ ç¬¬2ç§ æƒ…å†µï¼Œç›´æ¥false ï¼ˆæ³¨æ„ifé‡Œé¡ºåºä¸èƒ½æ¢ï¼‰
        else if (st.empty() || st.top() != s[i])    return false; 

        // st.top() == s[i] éå†åˆ°å¯¹åº”çš„å³æ‹¬å·å°±å¼¹å‡ºæ ˆé¡¶
        else    st.pop();
    }

    // ç¬¬1ç§ æƒ…å†µï¼Œéå†å®Œsï¼Œä½†æ ˆä¸ä¸ºç©ºï¼Œè¿™é‡Œå°±è¿”å›false
    // å¦‚æœä¸ºç©ºï¼Œè¯´æ˜ç¬¦åˆè¦æ±‚ï¼Œè¿”å›çš„æ˜¯true
    return st.empty();
}


int main()
{
    string s = "()[]{(}";
    bool result = isValid(s);
    cout << (result ? "true" : "false") << endl;

    return 0;
}
~~~





## [155 æœ€å°æ ˆ](https://leetcode.cn/problems/min-stack/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250726105802631](pic/image-20250726105802631.png)

![image-20250726110007671](pic/image-20250726110007671.png)



~~~C++
class MinStack {

    stack<pair<int, int>> st;

public:
    // åˆå§‹åŒ–
    MinStack() {
        // æ·»åŠ æ ˆåº•å“¨å…µ INT_MAX
        // è¿™é‡Œçš„ 0 å†™æˆä»»æ„æ•°éƒ½å¯ä»¥ï¼Œåæ­£ç”¨ä¸åˆ°
        st.emplace(0, INT_MAX); 
    }
    
    void push(int val) {
        st.emplace(val, min(getMin(), val)); // <val, å‰ç¼€æœ€å°å€¼>       
    }
    
    void pop() {
        st.pop();
    }
    
    int top() {
        return st.top().first;
    }
    
    // æœ€å°å€¼
    int getMin() {
        return st.top().second;        
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
~~~



æ—¶é—´å¤æ‚åº¦ï¼šæ‰€æœ‰æ“ä½œå‡ä¸º O(1)ã€‚
ç©ºé—´å¤æ‚åº¦ï¼šO(q)ã€‚å…¶ä¸­ q æ˜¯ push è°ƒç”¨çš„æ¬¡æ•°ã€‚æœ€åæƒ…å†µä¸‹ï¼Œåªæœ‰ push æ“ä½œï¼Œéœ€è¦ O(q) çš„ç©ºé—´ä¿å­˜å…ƒç´ ã€‚



ACM

~~~C++
#include <iostream>
#include <stack>

using namespace std;

// 155 æœ€å°æ ˆ

class MinStack 
{

    stack<pair<int, int>> st;

public:
    // åˆå§‹åŒ–
    MinStack() {
        // æ·»åŠ æ ˆåº•å“¨å…µ INT_MAX
        // è¿™é‡Œçš„ 0 å†™æˆä»»æ„æ•°éƒ½å¯ä»¥ï¼Œåæ­£ç”¨ä¸åˆ°
        st.emplace(0, INT_MAX); 
    }
    
    void push(int val) {
        st.emplace(val, min(getMin(), val)); // <val, å‰ç¼€æœ€å°å€¼>       
    }
    
    void pop() {
        st.pop();
    }
    
    int top() {
        return st.top().first; // val
    }
    
    // æœ€å°å€¼
    int getMin() {
        return st.top().second; // å‰ç¼€æœ€å°å€¼  
    }
};


int main()
{
    MinStack mt;
    mt.push(-2);
    mt.push(0);
    mt.push(-3);
    cout << "min: " << mt.getMin() << endl;
    mt.pop();
    cout << "st_top: " << mt.top() << endl;

    return 0;

}
~~~





## [394 å­—ç¬¦ä¸²è§£ç ](https://leetcode.cn/problems/decode-string/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250727104739027](pic/image-20250727104739027.png)

### 1ã€[ä¸¤ä¸ªæ ˆ](https://leetcode.cn/problems/decode-string/solutions/6274/ti-jie-czhan-by-youlookdeliciousc)

**ä¸»è¦æ€è·¯ï¼šä¸¤ä¸ªæ ˆå­˜å·¦æ‹¬å·å‰çš„æ•°å­—ï¼Œå­—ç¬¦ï¼Œé‡åˆ°å³æ‹¬å·çš„æ—¶å€™å–å‡ºæ¥æ‹¼æ¥**

ä¸¾ä¸ªä¾‹å­çœ‹å§	

~~~C++
class Solution {
public:
    string decodeString(string s) {
        
        int num = 0;
        stack<int> numStack;    // å­˜æ•°å­—

        string res = "";
        stack<string> strStack; // å­˜å­—æ¯

        for (int i = 0; i < s.size(); i++)
        {
            // é‡åˆ°æ•°å­—ï¼Œå­˜åœ¨num
            if (s[i] >= '0' && s[i] <= '9') 
            {
                num = num * 10 + s[i] - '0';// è€ƒè™‘æ•°å­—å¯èƒ½ä¸åªæ˜¯ä¸ªä½æ•°ï¼Œæ¯”å¦‚150[a]
            }
            // å­—æ¯ç›´æ¥æ‹¼åˆ°res
            else if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z'))
            {
                res = res + s[i]; 
            }
            // é‡åˆ°'['ï¼Œå°† '[' å‰çš„æ•°å­—æ”¾è¿›numStackï¼Œå­—æ¯å­—ç¬¦æ”¾å…¥strStack
            else if (s[i] == '[') 
            {
                numStack.push(num);
                num = 0;
                strStack.push(res);
                res = "";
            }
            // é‡åˆ° ']' å¼€å§‹å¤„ç†è¿™ä¸€ç»„ [] æ‹¼æ¥
            else 
            {
                int times = numStack.top(); // æ‹¼æ¥å‡ æ¬¡res
                numStack.pop();

                for (int j = 0; j < times; j++)
                {
                    strStack.top() += res; // strStacké¡¶çš„å­—ç¬¦ï¼Œæ‹¼æ¥res
                }

                res = strStack.top(); // è¿™é‡Œreså°±æ˜¯æš‚æ—¶æ‹¼æ¥å®Œçš„è¿™ä¸€ç»„å­—ç¬¦äº†
                strStack.pop();
            }
        }

        return res; 
    }
};
~~~



### 2ã€[é€’å½’](https://leetcode.cn/problems/decode-string/solutions/19447/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd)

å°† `[` å’Œ `]` åˆ†åˆ«ä½œä¸ºé€’å½’çš„å¼€å¯ä¸ç»ˆæ­¢æ¡ä»¶

-  `s[i] == '['` æ—¶ï¼Œè¿›å…¥æ–°ä¸€å±‚é€’å½’ï¼Œresæ‹¼æ¥æ–°å†…å±‚å­ä¸²

-  `s[i] == ']'` æ—¶ï¼Œç»“æŸæœ¬å±‚é€’å½’ï¼Œè¿”å›res
- æ™®é€šå­—ç¬¦ç›´æ¥æ‹¼æ¥res
- éå†å®Œæ¯•åè¿”å› `res`



~~~C++
class Solution {
public:
    // è´Ÿè´£è§£ç ä»å½“å‰ index å¼€å§‹çš„å­å­—ç¬¦ä¸²
    string dfs(const string& s, int& index)
    {
        string res; 	// å½“å‰å±‚è§£ç åçš„å­—ç¬¦ä¸²
        int multi = 0;  // è®°å½•æ•°å­—ï¼Œ[]ä¸­çš„å†…å®¹çš„é‡å¤æ¬¡æ•°

        while (index < s.size())
        {
			// å½“å‰å­—ç¬¦æ˜¯æ•°å­—ï¼Œç´¯è®¡multi
            if (s[index] >= '0' && s[index] <= '9')
            {
                multi = multi * 10 + (s[index] - '0');
            }
            // é‡åˆ° [ å°±è¿›å…¥é€’å½’ï¼Œå¼€å§‹ä¸€ä¸ªæ–°çš„è¢«é‡å¤çš„å­ä¸²
            else if (s[index] == '[') 
            {
                index++; // è·³è¿‡ [
                string tmp = dfs(s, index); // é€’å½’è§£æ '[' ä¹‹åçš„å†…å®¹
                while (multi--) res += tmp; // æ‹¼æ¥è§£æå‡ºçš„å­ä¸²ï¼Œé‡å¤æ‹¼æ¥multiæ¬¡
                multi = 0;
            }
            else if (s[index] == ']') // é‡åˆ° ]ï¼Œè¡¨ç¤ºæœ¬æ¬¡é€’å½’ç»“æŸï¼Œè¿”å›å½“å‰æ‹¼æ¥ç»“æœ
            {
                return res;
            }
            else // s[i] == æ™®é€šå­—ç¬¦
            {
                res += s[index]; // ç›´æ¥åŠ å…¥ç»“æœ
            }

            index++;            
        }

        return res;
    }


    string decodeString(string s) {
        int index = 0;
        return dfs(s, index);
        
    }
};
~~~



ç”¨ lambda

~~~C++
class Solution {
public:
    string decodeString(string s) {

        auto dfs = [&](this auto&& dfs, const string& s, int& index) ->string
        {
            string res;
            int multi = 0;
            while (index < s.size())
            {
                if (s[index] >= '0' && s[index] <= '9')
                {
                    multi = multi * 10 + (s[index] - '0');
                }
                else if (s[index] == '[')
                {
                    index++;
                    string tmp = dfs(s, index); // é€’å½’è§£æ æ–°'['ä¹‹åçš„å†…å®¹
                    while (multi--) res += tmp; // æ‹¼æ¥è§£æå‡ºçš„å­ä¸²
                    multi = 0;
                }
                else if (s[index] == ']')
                {
                    return res;
                }
                else // æ™®é€šå­—ç¬¦ï¼Œç›´æ¥æ‹¼æ¥res
                {
                    res += s[index];
                }

                index++;
            }
            return res;
        };

        int index = 0;
        return dfs(s, index);
    }
};
~~~







### ACM

~~~C++
#include <iostream>
#include <vector>
#include <string>
#include <stack>
using namespace std;

// 394 å­—ç¬¦ä¸²è§£ç 
// è¾“å…¥ï¼šs = "3[a2[c]]"
// è¾“å‡ºï¼š"accaccacc"

string decodeString(string s) {
    
    int num = 0;
    stack<int> nums;    // å­˜æ•°å­—
    string res = "";
    stack<string> strs; // å­˜å­—æ¯

    for (int i = 0; i < s.size(); i++)
    {
        // é‡åˆ°æ•°å­—ï¼Œå­˜åœ¨num
        if (s[i] >= '0' && s[i] <= '9') 
        {
            num = num * 10 + s[i] - '0';// è€ƒè™‘æ•°å­—å¯èƒ½ä¸åªæ˜¯ä¸ªä½æ•°ï¼Œæ¯”å¦‚150[a]
        }
        // å­—æ¯ç›´æ¥æ‹¼åˆ°res
        else if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z'))
        {
            res = res + s[i]; 
        }
        // é‡åˆ°'['ï¼Œå°† '[' å‰çš„æ•°å­—æ”¾è¿›numsæ ˆï¼Œå­—æ¯å­—ç¬¦æ”¾å…¥strsæ ˆ
        else if (s[i] == '[') 
        {
            nums.push(num);
            num = 0;
            strs.push(res);
            res = "";
        }
        // é‡åˆ° ']' å¼€å§‹å¤„ç†è¿™ä¸€ç»„ [] æ‹¼æ¥
        else 
        {
            int times = nums.top(); // æ‹¼æ¥å‡ æ¬¡res
            nums.pop();
            for (int j = 0; j < times; j++)
            {
                strs.top() += res; // strsé¡¶çš„å­—ç¬¦ï¼Œæ‹¼æ¥res
            }
            res = strs.top(); // è¿™é‡Œreså°±æ˜¯æš‚æ—¶æ‹¼æ¥å®Œçš„è¿™ä¸€ç»„å­—ç¬¦äº†
            strs.pop();
        }
    }
    return res; 
}

int main()
{
    string s = "3[a2[c]]";
    string ans = decodeString(s);
    cout << ans << endl;

    return 0;
}
~~~



## [739 æ¯æ—¥æ¸©åº¦](https://leetcode.cn/problems/daily-temperatures/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250727165610930](pic/image-20250727165610930.png)

[çµç¥ å•è°ƒæ ˆ](https://www.bilibili.com/video/BV1VN411J7S7/?vd_source=7369d5f08520f2fc3601caee93963ffa)



### 1ã€ä»å³åˆ°å·¦

æ ˆä¸­è®°å½•ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ çš„ã€Œå€™é€‰é¡¹ã€çš„ä¸‹æ ‡ã€‚

<img src="pic/image-20250727172548794.png" alt="image-20250727172548794" style="zoom:50%;" />

<img src="pic/image-20250727172559655.png" alt="image-20250727172559655" style="zoom:50%;" />

~~~C++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        // temperatures = [73,74,75,71,69,72,76,73]

        int n = temperatures.size();
        vector<int> ans(n);
        stack<int> st; // å­˜çš„æ˜¯ä¸‹æ ‡

        // ä»å·¦åˆ°å³ç®—ï¼Œæ ˆé¡¶åˆ°æ ˆåº•é€’å¢
        for (int i = n - 1; i >= 0; i--)
        {
            int t = temperatures[i];

            // popå‡ºæ ˆé‡Œ å°äºå½“å‰æ¸©åº¦ t çš„å…ƒç´ 
            while (!st.empty() && t >= temperatures[st.top()]) 
            {
                st.pop();
            } 

            // å¦‚æœæ­¤æ—¶ st ä¸ç©ºï¼Œst.top()å°±æ˜¯ç¬¬ä¸€ä¸ªå¤§äº t çš„å…ƒç´ ï¼Œæ”¶é›†ä¸‹æ ‡å·®
            if (!st.empty()) 
            {
                ans[i] = st.top() - i;
            } // else å¦‚æœæ­¤æ—¶ st ç©ºï¼Œè¯´æ˜ t åé¢æ²¡æœ‰å¤§äºå®ƒçš„å…ƒç´ ï¼Œä¿æŒåŸå§‹çš„ 0

            // æ ˆæ”¶é›†å½“å‰ t çš„åæ ‡
            st.push(i);
        }

        return ans;       
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œå…¶ä¸­ n ä¸º temperatures çš„é•¿åº¦ã€‚è™½ç„¶æˆ‘ä»¬å†™äº†ä¸ªäºŒé‡å¾ªç¯ï¼Œä½†ç«™åœ¨æ¯ä¸ªå…ƒç´ çš„è§†è§’çœ‹ï¼Œè¿™ä¸ªå…ƒç´ åœ¨äºŒé‡å¾ªç¯ä¸­æœ€å¤šå…¥æ ˆå‡ºæ ˆå„ä¸€æ¬¡ï¼Œå› æ­¤å¾ªç¯æ¬¡æ•°ä¹‹å’Œæ˜¯ O(n)ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ã€‚
ç©ºé—´å¤æ‚åº¦ï¼šO(min(n,U))ï¼Œå…¶ä¸­ U=max(temperatures)âˆ’min(temperatures)+1ã€‚è¿”å›å€¼ä¸è®¡å…¥ï¼Œä»…è€ƒè™‘æ ˆçš„æœ€å¤§ç©ºé—´æ¶ˆè€—ã€‚



### 2ã€ä»å·¦åˆ°å³

æ ˆä¸­è®°å½•è¿˜æ²¡ç®—å‡ºä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ çš„é‚£äº›æ•°çš„ä¸‹æ ‡ã€‚

<img src="pic/image-20250727173215630.png" alt="image-20250727173215630" style="zoom:50%;" />

~~~C++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        // temperatures = [73,74,75,71,69,72,76,73]

        int n = temperatures.size();
        vector<int> ans(n);
        stack<int> st; // å­˜çš„æ˜¯ä¸‹æ ‡ ï¼ˆæ²¡æ‰¾åˆ°ä¸‹ä¸€ä¸ªæœ€å¤§å€¼çš„æ•°ï¼‰

        // ä»å·¦å¾€å³ï¼Œæ ˆé¡¶åˆ°æ ˆåº•é€’å¢
        for (int i = 0; i < n; i++)
        {
            int t = temperatures[i];

            // å½“å‰ t å¤§äºæ ˆé¡¶ï¼Œé‚£ t å°±æ˜¯æ ˆé¡¶çš„ä¸‹ä¸€ä¸ªæ›´å¤§å€¼
            while (!st.empty() && t > temperatures[st.top()])
            {
                int j = st.top();
                st.pop();
                ans[j] = i - j; // æ³¨æ„è¿™é‡Œæ”¶é›†çš„æ˜¯æ ˆé¡¶é‚£ä¸ªå…ƒç´ å¯¹åº”çš„ ans[j]
            } 
            
            // t å…¥æ ˆ
            st.push(i);
        }

        return ans;       
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ï¼šO(*n*)ï¼Œå…¶ä¸­ *n* ä¸º *temperatures* çš„é•¿åº¦ã€‚è™½ç„¶æˆ‘ä»¬å†™äº†ä¸ªäºŒé‡å¾ªç¯ï¼Œä½†ç«™åœ¨æ¯ä¸ªå…ƒç´ çš„è§†è§’çœ‹ï¼Œè¿™ä¸ªå…ƒç´ åœ¨äºŒé‡å¾ªç¯ä¸­æœ€å¤šå…¥æ ˆå‡ºæ ˆå„ä¸€æ¬¡ï¼Œå› æ­¤å¾ªç¯æ¬¡æ•°**ä¹‹å’Œ**æ˜¯ O(*n*)ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯ O(*n*)ã€‚

ç©ºé—´å¤æ‚åº¦ï¼šO(*n*)ã€‚æ³¨æ„è¿™ç§å†™æ³•æ ˆä¸­å¯ä»¥æœ‰é‡å¤å…ƒç´ ã€‚



### ACM

~~~C++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

// 739 æ¯æ—¥æ¸©åº¦

vector<int> dailyTemperatures(vector<int>& temperatures) 
{
    // temperatures = [73,74,75,71,69,72,76,73]  æ‰¾å¯¹äºç¬¬ i å¤©ï¼Œä¸‹ä¸€ä¸ªæ›´é«˜æ¸©åº¦å‡ºç°åœ¨å‡ å¤©å

    int n = temperatures.size();
    vector<int> ans(n);
    stack<int> st; // å­˜çš„æ˜¯ä¸‹æ ‡ ï¼ˆæ²¡æ‰¾åˆ°ä¸‹ä¸€ä¸ªæœ€å¤§å€¼çš„æ•°ï¼‰

    // ä»å·¦å¾€å³ï¼Œæ ˆé¡¶åˆ°æ ˆåº•é€’å¢
    for (int i = 0; i < n; i++)
    {
        int t = temperatures[i];

        // å½“å‰ t å¤§äºæ ˆé¡¶ï¼Œé‚£ t å°±æ˜¯æ ˆé¡¶çš„ä¸‹ä¸€ä¸ªæ›´å¤§å€¼
        while (!st.empty() && t > temperatures[st.top()])
        {
            int j = st.top();
            st.pop();
            ans[j] = i - j; // æ³¨æ„è¿™é‡Œæ”¶é›†çš„æ˜¯æ ˆé¡¶é‚£ä¸ªå…ƒç´ å¯¹åº”çš„ ans[j]
        } 
        
        // t å…¥æ ˆ
        st.push(i);
    }

    return ans;       
}


int main()
{
    vector<int> temperatures = {73, 74, 75, 71, 69, 72, 76, 73};
    vector<int> ans = dailyTemperatures(temperatures); // 1 1 4 2 1 1 0 0 
    for (int val : ans)
    {
        cout << val << " ";
    }
    cout << endl;

    return 0;
}
~~~







## [84 æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250727175437601](pic/image-20250727175437601.png)

å¤ªä¹±äº†ï¼Œæƒ³ä¸åˆ°ï¼Œä¸¾ä¾‹å­çœ‹å§



![image-20250727184702493](pic/image-20250727184702493.png)

![image-20250727184713757](pic/image-20250727184713757.png)

![image-20250727184749648](pic/image-20250727184749648.png)

![image-20250727184754379](pic/image-20250727184754379.png)

~~~C++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        
        // æ‰¾å½“å‰æŸ±å­å·¦å³ç¬¬ä¸€ä¸ªæ¯”å®ƒå°çš„æŸ±å­ä¸‹æ ‡
        // è®¡ç®—å½“å‰æŸ±å­èƒ½æ‰©å±•çš„å®½åº¦ï¼Œå†è®¡ç®—èƒ½æ‰©å±•çš„é¢ç§¯ï¼Œéå†æ‰¾æœ€å¤§å€¼

        int result = 0;

        stack<int> st; // æ ˆé‡Œå­˜éå†è¿‡çš„å¾…è®¡ç®—é¢ç§¯çš„æŸ±å­
        st.push(0);

        // heights é¦–å°¾éƒ½æ’å…¥0ï¼Œä¸ºäº†ä¸ç©ºæ ˆï¼Œå¦‚æœå½“å‰æŸ±å­åªæœ‰è‡ªå·±ä¸€ä¸ªå®½åº¦çš„è¯ï¼Œä¹Ÿè¦èƒ½èµ°åˆ°è®¡ç®—é¢ç§¯é‚£é‡Œ
        heights.insert(heights.begin(), 0);
        heights.insert(heights.end(), 0);

        for (int i = 1; i < heights.size(); i++)
        {
            // heights[i] > æ ˆé¡¶
            if (heights[i] > heights[st.top()]) 
            {
                st.push(i);
            }
            else if (heights[i] == heights[st.top()])   
            {
                st.pop(); // ä¹Ÿå¯ä»¥ä¸popï¼Œå¤šç®—ä¸€æ¬¡0
                st.push(i);
            }
            else 
            {
                // heights[i] < æ ˆé¡¶ é‡åˆ°æ¯”è‡ªå·±ï¼ˆæ ˆé¡¶ï¼‰å°çš„ï¼Œå°±è¯´æ˜æ ˆé¡¶è¿™ä¸ªå…ƒç´ ä¸èƒ½å‘å³æ‰©å±•äº†
                while (!st.empty() && heights[i] < heights[st.top()])
                {
                    int cur = st.top(); // æ ˆé¡¶ï¼Œä¸‹é¢ç®—å¾—æ˜¯ã€æ ˆé¡¶å…ƒç´ çš„é¢ç§¯ã€‘
                    st.pop();

                    if (!st.empty())
                    {
                        int left = st.top();
                        int right = i;
                        int w = right - left - 1; // å½“å‰æŸ±å­èƒ½æ‰©å±•çš„å®½åº¦
                        int h = heights[cur];     // å½“å‰æŸ±å­çš„é«˜åº¦

                        result = max(result, h * w); // æ›´æ–°ä¸ºæ‰€æœ‰æŸ±å­ä¸­èƒ½æ‰©å±•çš„é¢ç§¯æœ€å¤§å€¼
                    }
                }

                st.push(i);
            }
        }

        return result;
        
    }
};
~~~





# å † âœ…

## 215 [æ•°ç»„ä¸­çš„ç¬¬ K ä¸ªæœ€å¤§å…ƒç´ ](https://leetcode.cn/problems/kth-largest-element-in-an-array/submissions/649625107/?envType=study-plan-v2&envId=top-100-liked)

![image-20250804110511580](pic/image-20250804110511580.png)

![image-20250804110517010](pic/image-20250804110517010.png)

![image-20250804110524721](pic/image-20250804110524721.png)



~~~C++
class Solution {
public:
    // åŸºäºå¿«æ’çš„å¿«é€Ÿé€‰æ‹©
    int quickSelect(vector<int>& nums, int k)
    {        
        // éšæœºé€‰æ‹©åŸºå‡†æ•°å­—
        int p = nums[rand() % nums.size()];

        // å°†å¤§äºç­‰äºå°äºåŸºå‡†çš„å…ƒç´ ï¼Œåˆ†åˆ«æ”¾å…¥ä¸‰ä¸ªæ•°ç»„
        vector<int> big, equal, small;
        for (int a : nums)
        {
            if (a < p)      small.push_back(a);
            else if (a > p) big.push_back(a);
            else            equal.push_back(a);
        }

        // ç¬¬ k å¤§å…ƒç´ åœ¨big ä¸­ï¼ŒæŒ‰é€’å½’åˆ’åˆ†
        if (k <= big.size())    
        {
            return quickSelect(big, k);
        }

        // ç¬¬ k å¤§å…ƒç´ åœ¨ small ä¸­ï¼Œé€’å½’åˆ’åˆ†
        if (k > big.size() + equal.size())
        {
            return quickSelect(small, k - (big.size() + equal.size()));
            // åœ¨smallé‡Œé¢å°±æ˜¯ç¬¬ [k - (big.size() + equal.size())] ä¸ªå¤§çš„å…ƒç´ 
        }

        // ç¬¬ k å¤§å…ƒç´ åœ¨ equal ä¸­ï¼Œæ‰¾åˆ°ï¼Œè¿”å›p
        return p;
    }


    int findKthLargest(vector<int>& nums, int k) {

        return quickSelect(nums, k);        
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 215 æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ 


// åŸºäºå¿«æ’çš„å¿«é€Ÿé€‰æ‹©
int quickSelect(vector<int>& nums, int k)
{        
    // éšæœºé€‰æ‹©åŸºå‡†æ•°å­—
    int p = nums[rand() % nums.size()];

    // å°†å¤§äºç­‰äºå°äºåŸºå‡†çš„å…ƒç´ ï¼Œåˆ†åˆ«æ”¾å…¥ä¸‰ä¸ªæ•°ç»„
    vector<int> big, equal, small;
    for (int a : nums)
    {
        if (a < p)      small.push_back(a);
        else if (a > p) big.push_back(a);
        else            equal.push_back(a);
    }

    // ç¬¬ k å¤§å…ƒç´ åœ¨big ä¸­ï¼ŒæŒ‰é€’å½’åˆ’åˆ†
    if (k <= big.size())    
    {
        return quickSelect(big, k);
    }
    // ç¬¬ k å¤§å…ƒç´ åœ¨ small ä¸­ï¼Œé€’å½’åˆ’åˆ†
    if (k > big.size() + equal.size())
    {
        return quickSelect(small, k - (big.size() + equal.size()));
        // åœ¨smallé‡Œé¢å°±æ˜¯ç¬¬ [k - (big.size() + equal.size())] ä¸ªå¤§çš„å…ƒç´ 
    }

    // ç¬¬ k å¤§å…ƒç´ åœ¨ equal ä¸­ï¼Œæ‰¾åˆ°ï¼Œè¿”å›p
    return p;
}


int main()
{
    vector<int> nums = {3,2,1,5,6,4};
    int k = 2;
    int ans = quickSelect(nums, k);
    cout << ans << endl;

    return 0;
}
~~~







## 347 [å‰ K ä¸ªé«˜é¢‘å…ƒç´ ](https://leetcode.cn/problems/top-k-frequent-elements/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250803222511849](pic/image-20250803222511849.png)



### å°é¡¶å †

![image-20250803225312630](pic/image-20250803225312630.png)

![image-20250803225319322](pic/image-20250803225319322.png)

~~~C++	
class Solution {
public:
    // ä¸‰å—å†…å®¹ï¼š
    // 1 ç»Ÿè®¡å…ƒç´ å‡ºç°çš„é¢‘ç‡  - map
    // 2 å¯¹é¢‘ç‡æ’åº         - ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ˆå°é¡¶å †ï¼‰
    // 3 æ‰¾å‡ºå‰ k ä¸ªé«˜é¢‘å…ƒç´  

    
    // å°é¡¶å †ï¼šä»¿å‡½æ•°æ”¹å˜ priority_queue æ’åº
    class mycomparison{
    public:
        bool operator() (const pair<int, int>& lhs, const pair<int, int>& rhs)
        {
            return lhs.second > rhs.second; // æ¬¡åºï¼Œè¾ƒå°çš„åœ¨top
        }
    };


    vector<int> topKFrequent(vector<int>& nums, int k) {

        // 1 ç»Ÿè®¡å…ƒç´ å‡ºç°é¢‘ç‡ <nums[i], å‡ºç°æ¬¡æ•°>
        unordered_map<int, int> cnt_map;
        for (int val : nums)
        {
            cnt_map[val]++;
        }

        // 2 å¯¹å‡ºç°æ¬¡æ•°æ’åºï¼šå°é¡¶å † å¤§å°ä¸ºk
        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;

        for (unordered_map<int, int>::iterator it = cnt_map.begin(); it != cnt_map.end(); it++)
        {
            pri_que.push(*it);
            // å¦‚æœå †é‡Œçš„å…ƒç´ è¶…è¿‡äº†kï¼Œå¼¹å‡ºæœ€å°å…ƒç´ ï¼Œå§‹ç»ˆä¿æŒå †é‡Œæ˜¯å‰kä¸ªæœ€å¤§æ¬¡æ•°
            if (pri_que.size() > k) pri_que.pop(); 
        }

        // 3 æ‰¾å‡ºå‰ k ä¸ªé«˜é¢‘å…ƒç´ ï¼Œå°±æ˜¯ç•™åœ¨pri_queä¸­çš„kä¸ª
        vector<int> result(k);
        for (int i = k - 1; i >= 0; i--) // å°é¡¶å †å…ˆå¼¹å‡ºçš„æ˜¯æœ€å°çš„ï¼Œæ‰€ä»¥å€’ç€æ”¾å…¥result
        {
            result[i] = pri_que.top().first; // å–å…ƒç´ 
            pri_que.pop();
        }


        return result;    
        
    }
};
~~~



### æ¡¶æ’åº

![image-20250803231056312](pic/image-20250803231056312.png)

![image-20250803233402555](pic/image-20250803233402555.png)

~~~C++	
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 1 ç»Ÿè®¡æ¯ä¸ªå…ƒç´ çš„å‡ºç°æ¬¡æ•° map
        unordered_map<int, int> cnt;
        int max_cnt = 0;
        for (int x : nums)
        {
            cnt[x]++;
            max_cnt = max(max_cnt, cnt[x]); // è®°å½•æœ€å¤§æ¬¡æ•°
        }
        
        // 2 æŠŠå‡ºç°æ¬¡æ•°ç›¸åŒçš„å…ƒç´ ï¼Œæ”¾è¿›ä¸€ä¸ªæ¡¶é‡Œ
        vector<vector<int>> buckets(max_cnt + 1); 
        for (auto& [x, c] : cnt)
        {
            buckets[c].push_back(x); // å‡ºç°æ¬¡æ•°ä¸º c çš„å…ƒç´ é›†åˆ

            // è¿™é‡Œç”¨äºŒç»´æ•°ç»„buckets æ˜¯ä¸ºäº†æ¯”å¦‚ï¼šnums = [1,2] k = 2 è¿™ç§
        }


        // 3 å€’åºéå†bucketsï¼ŒæŠŠå‡ºç°æ¬¡æ•°å‰kçš„å…ƒç´ åŠ å…¥ç­”æ¡ˆ
        vector<int> ans;
        for (int i = max_cnt; i >= 0 && ans.size() < k; i--)
        {
            ans.insert(ans.end(), buckets[i].begin(), buckets[i].end());
        }

        return ans;
    }
};
~~~

![image-20250803233434960](pic/image-20250803233434960.png)

è¿™é‡Œ `buckets` éœ€è¦ç”¨äºŒç»´æ•°ç»„ï¼Œæ”¶é›†**æ¬¡æ•°ç›¸åŒçš„å…ƒç´ é›†åˆ**ï¼Œæ¯”å¦‚ `nums = [1, 2]`  ï¼Œ`k = 2` è¿™ç§æƒ…å†µï¼š

![image-20250803234139410](pic/image-20250803234139410.png)





## 295 [æ•°æ®æµä¸­çš„ä¸­ä½æ•°](https://leetcode.cn/problems/find-median-from-data-stream/?envType=study-plan-v2&envId=top-100-liked)

@ ä¸­ä½æ•° @ å°é¡¶å †

åˆ é™¤æ“ä½œå¯ä»¥çœ‹ 480 æ»‘åŠ¨çª—å£ä¸­ä½æ•°

![image-20250804144902822](pic/image-20250804144902822.png)

![image-20250804144853926](pic/image-20250804144853926.png)

![image-20250804145420002](pic/image-20250804145420002.png)

![image-20250804145425012](pic/image-20250804145425012.png)

![image-20250804145431394](pic/image-20250804145431394.png)

~~~C++
class MedianFinder {
    priority_queue<int> left; // å¤§é¡¶å †ï¼ˆé»˜è®¤ï¼‰ï¼Œå­˜è¾ƒå°çš„ä¸€åŠ
    priority_queue<int, vector<int>, greater<int>> right; // å°é¡¶å †ï¼Œå­˜è¾ƒå¤§çš„ä¸€åŠ
    
public:
    MedianFinder() {
        
    }
    
    void addNum(int num) {

        if (left.size() == right.size()) // ä¸¤è¾¹æ•°é‡ç›¸ç­‰ï¼Œç›´æ¥åŠ å…¥å³è¾¹
        {
            right.push(num);
            left.push(right.top()); // å³è¾¹å¼¹å‡ºæ¥æœ€å°çš„ä¸€ä¸ªï¼ŒåŠ å…¥left
            right.pop();
        }
        else // å·¦è¾¹æ•°é‡å¤šï¼Œç›´æ¥åŠ å…¥å·¦è¾¹ï¼Œå·¦è¾¹å¼¹å‡ºæ¥å†ç»™å³è¾¹
        {
            left.push(num);
            right.push(left.top()); // å·¦è¾¹å¼¹å‡ºæ¥æœ€å¤§çš„ä¸€ä¸ªï¼ŒåŠ å…¥right
            left.pop();
        }        
    }
    
    double findMedian() {
        if (left.size() > right.size()) return left.top();
        else                            return (left.top() + right.top()) / 2.0;

    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
~~~



ACM

~~~C++
#include <vector>
#include <queue>
#include <iostream>
using namespace std;

// 295 æ•°æ®æµçš„ä¸­ä½æ•°


class MedianFinder {
    priority_queue<int> left; // å¤§é¡¶å †ï¼ˆé»˜è®¤ï¼‰ï¼Œå­˜è¾ƒå°çš„ä¸€åŠ
    priority_queue<int, vector<int>, greater<int>> right; // å°é¡¶å †ï¼Œå­˜è¾ƒå¤§çš„ä¸€åŠ
    
public:
    MedianFinder() {}
    
    void addNum(int num) {

        if (left.size() == right.size()) // ä¸¤è¾¹æ•°é‡ç›¸ç­‰ï¼Œç›´æ¥åŠ å…¥å³è¾¹
        {
            right.push(num);
            left.push(right.top()); // å³è¾¹å¼¹å‡ºæ¥æœ€å°çš„ä¸€ä¸ªï¼ŒåŠ å…¥left
            right.pop();
        }
        else // å·¦è¾¹æ•°é‡å¤šï¼Œç›´æ¥åŠ å…¥å·¦è¾¹ï¼Œå·¦è¾¹å¼¹å‡ºæ¥å†ç»™å³è¾¹
        {
            left.push(num);
            right.push(left.top()); // å·¦è¾¹å¼¹å‡ºæ¥æœ€å¤§çš„ä¸€ä¸ªï¼ŒåŠ å…¥right
            left.pop();
        }        
    }
    
    double findMedian() {
        if (left.size() > right.size()) return left.top();
        else                            return (left.top() + right.top()) / 2.0;

    }
};


int main()
{
    MedianFinder mymid;
    mymid.addNum(1);
    mymid.addNum(2);
    cout << mymid.findMedian() << endl;
    mymid.addNum(3);
    cout << mymid.findMedian() << endl;

    return 0;
}
~~~















# è´ªå¿ƒ âœ…

## 121 [ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250724104534791](pic/image-20250724104534791.png)

### è´ªå¿ƒ

![image-20250724105610766](pic/image-20250724105610766.png)

~~~C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {

        // prices[i] è‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼
        int low = prices[0];
        int result = 0;
        for (int i = 0; i < prices.size(); i++)
        {
            low = min(low, prices[i]); // å–æœ€å·¦æœ€å°ä»·æ ¼
            result = max(result, prices[i] - low); // ç›´æ¥å–æœ€å¤§å·®
        }

        return result;
    }
};
~~~



ACM 

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 121 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº


int maxProfit(vector<int>& prices)  // prices[i] è‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼
{ 
    int result = 0;
    int low = prices[0];
    
    for (int i = 0; i < prices.size(); i++)
    {
        low = min(low, prices[i]); // å–æœ€å·¦æœ€å°ä»·æ ¼
        result = max(result, prices[i] - low); // ç›´æ¥å–æœ€å¤§å·®
    }
    return result;
    
}


int main()
{
    vector<int> prices = {7, 1, 5, 3, 6, 4};
    int result = maxProfit(prices);
    cout << result << endl;

    return 0;
}
~~~



### åŠ¨è§„

![image-20250821220151456](./pic/image-20250821220151456.png)

![image-20250821220158195](./pic/image-20250821220158195.png)

![image-20250821220210050](./pic/image-20250821220210050.png)

![image-20250821220221734](./pic/image-20250821220221734.png)

![image-20250821220226735](./pic/image-20250821220226735.png)

![image-20250821220237410](./pic/image-20250821220237410.png)

~~~C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {

        int len = prices.size();

        // dp[i][0] - ç¬¬iå¤©æŒæœ‰è‚¡ç¥¨æ‰€å¾—æœ€å¤šç°é‡‘   
        // dp[i][1] - ç¬¬iå¤©ä¸æŒæœ‰è‚¡ç¥¨æ‰€å¾—æœ€å¤šç°é‡‘
        vector<vector<int>> dp(len, vector<int>(2, 0));

        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for (int i = 1; i < prices.size(); i++)
        {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }

        return dp[len - 1][1]; // ä¸€å®šæ˜¯æœ€åä¸æŒæœ‰ï¼Œé’±å¤š   
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ï¼šO(n)

ç©ºé—´å¤æ‚åº¦ï¼šO(n)



**ä¼˜åŒ–ç©ºé—´å¤æ‚åº¦**

![image-20250821220409600](./pic/image-20250821220409600.png)









## [55 è·³è·ƒæ¸¸æˆ](https://leetcode.cn/problems/jump-game/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250724143937308](pic/image-20250724143937308.png)

![image-20250724144024745](pic/image-20250724144024745.png)

![image-20250724144038419](pic/image-20250724144038419.png)

~~~C++
class Solution {
public:
    bool canJump(vector<int>& nums) {

        // è½¬æ¢ä¸ºè·³è·ƒèŒƒå›´èƒ½å¦è¦†ç›–åˆ°ç»ˆç‚¹
        
        if (nums.size() == 1)   return true;

        int cover = 0; // æœ€å³è¾¹ç•Œ
        for (int i = 0; i <= cover; i++)  // æ³¨æ„æ˜¯åœ¨coveré‡Œå¾€åå–
        {
            cover = max(i + nums[i], cover); // æ›´æ–°æœ€å¤§è¦†ç›–èŒƒå›´ï¼ˆæœ€å¤§å³è¾¹ç•Œï¼‰
            if (cover >= nums.size() - 1) // è¦†ç›–åˆ°ç»ˆç‚¹äº†ï¼Œè¿”å›true
            {
                return true; 
            }  
        }

        return false;       
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 55 è·³è·ƒæ¸¸æˆ

bool canJump(vector<int>& nums)
{
    if (nums.size() == 1) return true;

    int cover = 0;
    for (int i = 0; i <= cover; i++)
    {
        cover = max(cover, i + nums[i]); // æ›´æ–°æœ€å¤§è¦†ç›–èŒƒå›´
        if (cover >= nums.size() - 1)   return true;
    }

    return false;
}



int main()
{
    vector<int> nums = {2, 3, 1, 1, 4};
    bool ans = canJump(nums);
    cout << (ans ? "true" : "false") << endl;

    return 0;
}
~~~





## 45 è·³è·ƒæ¸¸æˆII

![image-20250724145332038](pic/image-20250724145332038.png)

åœ¨ 55 çš„åŸºç¡€ä¸Šæ±‚æœ€å°è·³è·ƒæ¬¡æ•°

é¢˜ç›®ä¿è¯å¯ä»¥è·³åˆ°æœ€åï¼Œä¹Ÿå°±æ˜¯ä»¥æœ€å°çš„æ­¥æ•°ï¼Œå¢åŠ è¦†ç›–èŒƒå›´ï¼Œç›´åˆ°ç»ˆç‚¹ã€‚

![image-20250724145732868](pic/image-20250724145732868.png)

<img src="pic/image-20250724145830910.png" alt="image-20250724145830910" style="zoom:33%;" />

è¦†ç›–èŒƒå›´å·²ç»èƒ½åˆ°ç»ˆç‚¹äº†ï¼Œæœ€å¤šä¸¤æ­¥è‚¯å®šèƒ½è·³åˆ°ç»ˆç‚¹ï¼Œ**ä¸ç”¨æ±‚å…·ä½“æ€ä¹ˆè·³**ã€‚

ç§»åŠ¨ä¸‹æ ‡è¾¾åˆ°äº†å½“å‰è¦†ç›–çš„æœ€è¿œè·ç¦»ä¸‹æ ‡æ—¶ï¼Œ**å¦‚æœæ²¡è¦†ç›–ç»ˆç‚¹ï¼Œæ­¥æ•°å°±è¦åŠ ä¸€**ï¼Œæ¥å¢åŠ è¦†ç›–è·ç¦»ï¼Œå†èµ°ä¸‹ä¸€ä¸ªçš„æœ€å¤§è¦†ç›–èŒƒå›´ã€‚

æ‰€ä»¥å°±æ˜¯æ±‚**æ›´æ–°äº†å‡ æ¬¡è¦†ç›–èŒƒå›´**ã€‚

~~~C++
class Solution {
public:
    int jump(vector<int>& nums) {

        // æ±‚æ›´æ–°å‡ æ¬¡è¦†ç›–èŒƒå›´

        if (nums.size() == 1)   return 0;

        int ans = 0; // è®°å½•è·³è·ƒæ¬¡æ•°ï¼ˆæ›´æ–°å‡ æ¬¡è¦†ç›–èŒƒå›´ï¼‰

        int curDistance = 0;  // å½“å‰æœ€è¿œè¦†ç›–çš„ä¸‹æ ‡
        int nextDistance = 0; // ä¸‹ä¸€æ­¥æœ€è¿œè¦†ç›–çš„ä¸‹æ ‡

        for (int i = 0; i < nums.size(); i++)
        {
            nextDistance = max(nextDistance, i + nums[i]);

            // i å·²ç»èµ°åˆ°äº†å½“å‰èƒ½èµ°çš„æœ€è¿œä½ç½®ï¼Œå¿…é¡»è¦å†èµ°ä¸€æ­¥äº†
            if (i == curDistance) 
            {
                ans++; // è·³è·ƒæ¬¡æ•° + 1 (æ›´æ–°è¦†ç›–èŒƒå›´æ¬¡æ•° + 1)
                curDistance = nextDistance; // æ›´æ–°å½“å‰è¦†ç›–

                // æ›´æ–°å®Œcurå·²ç»èƒ½è¦†ç›–äº†ï¼Œè¿™æ¬¡çš„æ­¥æ•°ä¹ŸåŠ ä¸Šäº†ï¼Œä¸ç”¨å†è·³ä¸‹ä¸€æ¬¡ï¼Œç›´æ¥ç»“æŸ
                if (curDistance >= nums.size() - 1) break; 
            }
        }

        return ans;        
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 45 è·³è·ƒæ¸¸æˆ II (æœ€å°è·³è·ƒæ¬¡æ•°)

int jumpCount(vector<int>& nums)
{
    if (nums.size() == 1)   return 0;

    int ans = 0;
    int curDistance = 0;
    int nextDistance = 0;

    for (int i = 0; i < nums.size(); i++)
    {
        nextDistance = max(nextDistance, i + nums[i]);

        if (i == curDistance)
        {
            ans++;
            curDistance = nextDistance;

            if (curDistance >= nums.size() - 1) break;
        }
    }

    return ans;
}



int main()
{
    vector<int> nums = {2, 3, 1, 1, 4};
    int ans = jumpCount(nums);
    cout << ans << endl;

    return 0;
}
~~~





## [763 åˆ’åˆ†å­—æ¯åŒºé—´](https://leetcode.cn/problems/partition-labels/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250724152147317](pic/image-20250724152147317.png)

**æ‰¾æ¯ä¸ªå­—æ¯çš„æœ€è¿œå‡ºç°çš„ä¸‹æ ‡ï¼Œåˆ†å‰²**

![image-20250724152234956](pic/image-20250724152234956.png)



![image-20250724154041841](pic/image-20250724154041841.png)

~~~C++
class Solution {
public:
    vector<int> partitionLabels(string s) {

        // ç»Ÿè®¡æ¯ä¸ªå­—æ¯çš„ä¸‹æ ‡

        // hash[i] - æ¯ä¸ªå­—æ¯æœ€åå‡ºç°çš„ä½ç½®
        int hash[27] = {0};
        for (int i = 0; i < s.size(); i++) // éå†sï¼Œi æ˜¯ s ä¸­çš„ä¸‹æ ‡
        {
            hash[s[i] - 'a'] = i; // å­˜çš„å†…å®¹æ˜¯ s ä¸­çš„ä¸‹æ ‡
        }

        //  ç›´æ¥ç”¨ASCIIç , 
        //  hash[s[0] - 'a'] = hash['a' - 'a'] = hash[0] æœ€åæ›´æ–°ä¸º 8ï¼Œå³aæœ€è¿œä¸‹æ ‡æ˜¯8 

        //  hash[0] = 8 --- a  
        //  hash[1] = 5 --- b
        //  hash[2] = 7 --- c
        //  hash[3] = 14 -- d
        //  ...
        
        //          a, b, c, d,  e,  f,  g,  h,  i,  j,  k,  l,  m, n, o, ...
        //  hash = {8, 5, 7, 14, 15, 11, 13, 19, 22, 23, 20, 21, 0, 0, 0, ...}

        vector<int> result;
        int left = 0;
        int right = 0;
        for (int i = 0; i < s.size(); i++) // éå†çš„è¿˜æ˜¯ s
        {
            right = max(right, hash[s[i] - 'a']); // å§‹ç»ˆæ˜¯iä¹‹å‰å­—æ¯æœ€è¿œè¾¹ç•Œä¸­çš„æœ€å¤§å€¼

            if (i == right) // i æ­£å¥½èµ°åˆ°äº† i ä¹‹å‰æ‰€æœ‰å­—æ¯ä¸­çš„æœ€è¿œä¸‹æ ‡
            {
                result.push_back(right - left + 1); // æ”¶é›†è¯¥è·ç¦»
                left = i + 1; // æ›´æ–°leftï¼Œå¼€å§‹ä¸‹ä¸€ç»„
            }
        }

        return result;

    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
#include <string>
using namespace std;


vector<int> partitionLabels(string s) {
    // ç»Ÿè®¡æ¯ä¸ªå­—æ¯çš„ä¸‹æ ‡
    // hash[i] - æ¯ä¸ªå­—æ¯æœ€åå‡ºç°çš„ä½ç½®
    int hash[27] = {0};
    for (int i = 0; i < s.size(); i++) // éå†sï¼Œi æ˜¯ s ä¸­çš„ä¸‹æ ‡
    {
        hash[s[i] - 'a'] = i; // å­˜çš„å†…å®¹æ˜¯ s ä¸­çš„ä¸‹æ ‡
    }
    //  ç›´æ¥ç”¨ASCIIç , 
    //  hash[s[0] - 'a'] = hash['a' - 'a'] = hash[0] æœ€åæ›´æ–°ä¸º 8ï¼Œå³aæœ€è¿œä¸‹æ ‡æ˜¯8 
    //  hash[0] = 8 --- a  
    //  hash[1] = 5 --- b
    //  hash[2] = 7 --- c
    //  hash[3] = 14 -- d
    //  ...
    
    //          a, b, c, d,  e,  f,  g,  h,  i,  j,  k,  l,  m, n, o, ...
    //  hash = {8, 5, 7, 14, 15, 11, 13, 19, 22, 23, 20, 21, 0, 0, 0, ...}


    vector<int> result;

    int left = 0;
    int right = 0;
    for (int i = 0; i < s.size(); i++) // éå†çš„è¿˜æ˜¯ s
    {
        right = max(right, hash[s[i] - 'a']); // å§‹ç»ˆæ˜¯iä¹‹å‰å­—æ¯æœ€è¿œè¾¹ç•Œä¸­çš„æœ€å¤§å€¼

        if (i == right) // i æ­£å¥½èµ°åˆ°äº† i ä¹‹å‰æ‰€æœ‰å­—æ¯ä¸­çš„æœ€è¿œä¸‹æ ‡
        {
            result.push_back(right - left + 1); // æ”¶é›†è¯¥è·ç¦»
            left = i + 1; // æ›´æ–°leftï¼Œå¼€å§‹ä¸‹ä¸€ç»„
        }
    }
 

    return result;
}


int main()
{
    string s = "ababcbacadefegdehijhklij";
    vector<int> result = partitionLabels(s);

    for (int val : result)
    {
        cout << val << " "; // 9 7 8
    }
    cout << endl;

    return 0;
}
~~~









# åŠ¨æ€è§„åˆ’ âœ…

@ èƒŒåŒ…   @ æ‰“å®¶åŠ«èˆ   @ è‚¡ç¥¨  @ å­åºåˆ—å­æ•°ç»„ 

## 70 [çˆ¬æ¥¼æ¢¯](https://leetcode.cn/problems/climbing-stairs/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250805105907383](pic/image-20250805105907383.png)



![image-20250805112253766](pic/image-20250805112253766.png)

<img src="pic/image-20250805105956681.png" alt="image-20250805105956681" style="zoom:50%;" />



![image-20250805112405157](pic/image-20250805112405157.png)

~~~C++
class Solution {
public:
    int climbStairs(int n) {
        
        if (n <= 1) return n;
        
        vector<int> dp(n + 1); // dp[i] çˆ¬åˆ°ç¬¬iä¸ªå°é˜¶ï¼Œæœ‰å¤šå°‘ç§æ–¹æ³•

        dp[1] = 1;
        dp[2] = 2;

        for (int i = 3; i <= n; i++)
        {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
        
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ O(n)



ä¼˜åŒ–ï¼šdp[3]

~~~C++
class Solution {
public:
    int climbStairs(int n) {
        
        if (n <= 1) return n;
        
        int dp[3]; // åªç»´æŠ¤3ä¸ª

        dp[1] = 1;
        dp[2] = 2;

        for (int i = 3; i <= n; i++)
        {
            int sum = dp[1] + dp[2];
            dp[1] = dp[2];
            dp[2] = sum;
        }

        return dp[2];
        
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ O(n) ï¼š è®¡ç®— f(n) éœ€å¾ªç¯ n æ¬¡ï¼Œæ¯è½®å¾ªç¯å†…è®¡ç®—æ“ä½œä½¿ç”¨ O(1) ã€‚
ç©ºé—´å¤æ‚åº¦ O(1) ï¼š å‡ ä¸ªæ ‡å¿—å˜é‡ä½¿ç”¨å¸¸æ•°å¤§å°çš„é¢å¤–ç©ºé—´ã€‚



ACM

~~~C++
#include <iostream>
#include <vector>
using namespace std;


// 70 çˆ¬æ¥¼æ¢¯

int climbStairs(int n) {
    
    if (n <= 1) return n;
    
    vector<int> dp(n + 1); // dp[i] çˆ¬åˆ°ç¬¬iä¸ªå°é˜¶ï¼Œæœ‰å¤šå°‘ç§æ–¹æ³•

    dp[1] = 1;
    dp[2] = 2;

    for (int i = 3; i <= n; i++)
    {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
    
}

int main()
{
    int n = 3;
    int ans = climbStairs(n);
    cout << ans << endl;

    return 0;
}
~~~



## 118 [æ¨è¾‰ä¸‰è§’](https://leetcode.cn/problems/pascals-triangle/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250805171443075](pic/image-20250805171443075.png)

![image-20250805171551496](pic/image-20250805171551496.png)

![image-20250805171710790](pic/image-20250805171710790.png)

~~~C++
class Solution {
public:
    vector<vector<int>> generate(int numRows) {    
        // [1]
        // [1, 1]
        // [1, 2, 1]
        // [1, 3, 3, 1]
        // [1, 4, 6, 4, 1]

        vector<vector<int>> c(numRows);
        for (int i = 0; i < numRows; i++)
        {
            c[i].resize(i + 1, 1); // ç¬¬iè¡Œæœ‰i+1ä¸ªæ•°ï¼Œæ¯ä¸€è¡Œèµ·å§‹éƒ½æ˜¯1
            for (int j = 1; j < i; j++) 
            {
                // å·¦ä¸Šæ–¹çš„æ•° + å³ä¸Šæ–¹çš„æ•°
                c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
            }
        }

        return c;        
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 118 æ¨è¾‰ä¸‰è§’

// [1]
// [1, 1]
// [1, 2, 1]
// [1, 3, 3, 1]
// [1, 4, 6, 4, 1]

vector<vector<int>> generate(int numRows)
{
    vector<vector<int>> c(numRows);
    
    for (int i = 0; i < numRows; i++)
    {
        c[i].resize(i + 1, 1);

        for (int j = 1; j < i; j++)
        {
            c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
        }
    }

    return c;
}


int main()
{
    int numRows = 5;
    vector<vector<int>> ans = generate(numRows);
    for (int i = 0; i < ans.size(); i++)
    {
        for (int val : ans[i])  cout << val << " ";
        cout << endl;
    }
    
    return 0;
}
~~~





## 198 [æ‰“å®¶åŠ«èˆ](https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250805173413637](pic/image-20250805173413637.png)

![image-20250805174048718](pic/image-20250805174048718.png)

<img src="pic/image-20250805174206969.png" alt="image-20250805174206969" style="zoom: 33%;" />

~~~C++
class Solution {
public:
    int rob(vector<int>& nums) {

        if (nums.size() == 0)   return 0;
        if (nums.size() == 1)   return nums[0];

        // dp[i]: è€ƒè™‘ä¸‹æ ‡iï¼ˆåŒ…æ‹¬iï¼‰ä»¥å†…çš„æˆ¿å±‹ï¼Œæœ€å¤šå¯ä»¥å·çªƒçš„é‡‘é¢ä¸ºdp[i]
        vector<int> dp(nums.size());

        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);

        for (int i = 2; i < nums.size(); i++)
        {
            // å†³å®šdp[i]çš„å› ç´  -- ç¬¬ié—´å·è¿˜æ˜¯ä¸å·
            dp[i] = max(dp[i - 2] + nums[i], // å·ç¬¬ié—´
                        dp[i - 1]); // ä¸å·ç¬¬ié—´
        }

        return dp[nums.size() - 1];        
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 198 æ‰“å®¶åŠ«èˆ

int rob(vector<int>& nums)
{
    if (nums.size() == 0)   return 0;
    if (nums.size() == 1)   return nums[0];

    // dp[i]: è€ƒè™‘ä¸‹æ ‡iï¼ˆåŒ…æ‹¬iï¼‰ä»¥å†…çš„æˆ¿å±‹ï¼Œæœ€å¤šå¯ä»¥å·çªƒçš„é‡‘é¢ä¸ºdp[i]
    vector<int> dp(nums.size());

    dp[0] = nums[0];
    dp[1] = max(nums[0], nums[1]);

    for (int i = 2; i < nums.size(); i++)
    {
        // å†³å®šdp[i]çš„å› ç´  -- ç¬¬ié—´å·è¿˜æ˜¯ä¸å·
        dp[i] = max(dp[i - 2] + nums[i], // å·ç¬¬ié—´
                    dp[i - 1]); // ä¸å·ç¬¬ié—´
    }

    return dp[nums.size() - 1];        
}


int main()
{
    vector<int> nums = {1, 2, 3, 1};
    int ans = rob(nums);
    cout << ans << endl;

    return 0;
}
~~~







## 279 [å®Œå…¨å¹³æ–¹æ•°](https://leetcode.cn/problems/perfect-squares/description/?envType=study-plan-v2&envId=top-100-liked)

@å®Œå…¨èƒŒåŒ…

![image-20250807104244859](pic/image-20250807104244859.png)

![image-20250807104702282](pic/image-20250807104702282.png)

![image-20250807104710144](pic/image-20250807104710144.png)

![image-20250807111337944](pic/image-20250807111337944.png)

~~~C++
class Solution {
public:
    int numSquares(int n) {

        // dp[j] å’Œä¸ºjçš„å®Œå…¨å¹³æ–¹æ•°çš„æœ€å°‘æ•°é‡ä¸ºdp[j]
        vector<uint64_t>  dp(n + 1, INT_MAX);

        dp[0] = 0;

        for (int i = 0; i * i <= n; i++) // å…ˆç‰©å“ï¼ˆå®Œå…¨å¹³æ–¹æ•° 1,4,9,...ï¼‰
        {
            for (int j = i * i; j <= n; j++) // åèƒŒåŒ…
            {
                dp[j] = min(dp[j], dp[j - i * i] + 1); 
            }
        }

        return dp[n];        
    }
};
~~~



`uint64_t` æ˜¯ C++ æ ‡å‡†åº“ä¸­å®šä¹‰çš„ **æ— ç¬¦å· 64 ä½æ•´æ•°ç±»å‹**ï¼Œå®šä¹‰åœ¨å¤´æ–‡ä»¶ `<cstdint>` æˆ– `<stdint.h>` ä¸­ã€‚å…¶å–å€¼èŒƒå›´ä¸ºï¼š

~~~C++
0 ~ 2^64 - 1 ï¼ˆå³ 0 ~ 18,446,744,073,709,551,615ï¼‰
~~~

ä¸ºä»€ä¹ˆ `dp` è¦ä½¿ç”¨ `uint64_t`ï¼Ÿ**é˜²æ­¢æ•´å‹æº¢å‡º**ã€‚

~~~C++
vector<uint64_t>  dp(n + 1, INT_MAX);
~~~

 `dp` æ•°ç»„åˆå§‹åŒ–æ—¶ï¼Œæ¯ä¸ªå…ƒç´ éƒ½è¢«è®¾ä¸º `INT_MAX`ï¼Œè€Œ `INT_MAX` æ˜¯ä¸€ä¸ª `int` ç±»å‹çš„æœ€å¤§å€¼ï¼Œå³ï¼š

~~~C++
INT_MAX = 2,147,483,647
~~~

åç»­è¿™è¡Œä»£ç å¯èƒ½å¯¼è‡´æº¢å‡º:

~~~C++
dp[j] = min(dp[j], dp[j - i * i] + 1);
~~~

è¿™é‡Œ `dp[j - i * i]` çš„åˆå§‹å€¼å¯èƒ½æ˜¯ `INT_MAX`ï¼Œå¦‚æœä½ å†åŠ ä¸Š `1`ï¼Œå°±å¯èƒ½å‘ç”Ÿæº¢å‡ºï¼š

~~~C++
INT_MAX + 1 ==> æº¢å‡ºä¸ºè´Ÿæ•°ï¼ˆint ç±»å‹ï¼‰
~~~

å¦‚æœ `dp` æ•°ç»„æ˜¯ `int` ç±»å‹ï¼Œ`dp[j - i*i] + 1` è¿™ä¸€æ­¥å¯èƒ½å˜æˆè´Ÿå€¼ï¼Œä»è€Œä½¿ `dp[j]` å¾—åˆ°é”™è¯¯çš„æœ€å°å€¼ï¼ˆå˜æˆè´Ÿæ•°çš„ç»“æœå‚ä¸ `min()` æ¯”è¾ƒï¼‰ï¼Œå¯¼è‡´æœ€ç»ˆç­”æ¡ˆé”™è¯¯ã€‚

è€Œä½¿ç”¨ `uint64_t`ï¼ˆæ›´å¤§èŒƒå›´çš„æ— ç¬¦å·æ•´å‹ï¼‰èƒ½æœ‰æ•ˆé¿å…è¿™ä¸ªæº¢å‡ºé—®é¢˜ã€‚



å¦‚æœç›´æ¥ç”¨`int`ç±»å‹ï¼Œéœ€è¦åŠ åˆ¤æ–­ï¼š

~~~C++
vector<int> dp(n + 1, INT_MAX);
// .......
if (dp[j - i * i] != INT_MAX)
    dp[j] = min(dp[j], dp[j - i * i] + 1);
~~~

ä½¿ç”¨ `uint64_t` å°±ç›¸å½“äºè§„é¿äº†è¿™ä¸ªåˆ¤æ–­é€»è¾‘ï¼Œç¨‹åºæ›´ç®€æ´ï¼Œ**ä»¥ç©ºé—´æ¢æ—¶é—´/é€»è¾‘å¤æ‚åº¦**ã€‚



ACM 

~~~C++
#include <iostream>
#include <vector>
using namespace std;

// 279 å®Œå…¨å¹³æ–¹æ•°


int numSquares(int n) {
    // dp[j] å’Œä¸ºjçš„å®Œå…¨å¹³æ–¹æ•°çš„æœ€å°‘æ•°é‡ä¸ºdp[j]
    vector<uint64_t>  dp(n + 1, INT_MAX);
    dp[0] = 0;

    for (int i = 0; i * i <= n; i++) // å…ˆç‰©å“ï¼ˆå®Œå…¨å¹³æ–¹æ•° 1,4,9,...ï¼‰
    {
        for (int j = i * i; j <= n; j++) // åèƒŒåŒ…
        {
            dp[j] = min(dp[j], dp[j - i * i] + 1); 
        }
    }

    return dp[n];        
}

int main()
{
    int n = 13;
    int ans = numSquares(n);
    cout << ans << endl;

}
~~~





## 322 é›¶é’±å…‘æ¢ 

@ å®Œå…¨èƒŒåŒ…

![image-20250807165942305](pic/image-20250807165942305.png)

**ç‰©å“â€”â€”ç¡¬å¸ï¼›èƒŒåŒ…é‡é‡â€”â€”æ€»é‡‘é¢ï¼›å®Œå…¨èƒŒåŒ…â€”â€”ç¡¬å¸æ— é™**

![image-20250807170201412](pic/image-20250807170201412.png)

![image-20250807170450636](pic/image-20250807170450636.png)

![image-20250818183330608](./pic/image-20250818183330608.png)



~~~C++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {

        // dp[j] å‡‘è¶³æ€»é¢ä¸º jï¼Œæ‰€éœ€æœ€å°‘ç¡¬å¸ä¸ªæ•°ä¸º dp[j]
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;

        // å…ˆç‰©å“ï¼ŒåèƒŒåŒ…ï¼ˆå¯è°ƒæ¢ï¼‰
        for (int i = 0; i < coins.size(); i++)
        {
            for (int j = coins[i]; j <= amount; j++) // å®Œå…¨èƒŒåŒ…ï¼Œæ­£åº
            {
                if (dp[j - coins[i]] != INT_MAX)// å¦‚æœdp[j - coins[i]æ˜¯åˆå§‹å€¼ï¼Œè·³è¿‡
                {
                    dp[j] = min(dp[j], dp[j - coins[i]] + 1);
                }
            }
        }

        if (dp[amount] == INT_MAX)  return -1; // æ²¡æœ‰ç»„åˆ

        return dp[amount];
        
    }
};
~~~



## 139 å•è¯æ‹†åˆ†

@å®Œå…¨èƒŒåŒ…

![image-20250819201626880](./pic/image-20250819201626880.png)

![image-20250819204556082](./pic/image-20250819204556082.png)

![image-20250819204607334](./pic/image-20250819204607334.png)

![image-20250819204618384](./pic/image-20250819204618384.png)


~~~C++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {

        // å­—å…¸wordDict è½¬ä¸ºset
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());

        // dp[j] - å­—ç¬¦ä¸²é•¿åº¦ä¸ºj ( sçš„[0, j-1]éƒ¨åˆ† )ï¼Œdp[j]ä¸ºtrue
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true; // æ— æ„ä¹‰ï¼Œçº¯ä¸ºäº†é€’æ¨


        // æ’åˆ—(ç»„æˆsçš„å­—ç¬¦ä¸²æ˜¯æœ‰é¡ºåºçš„) - å…ˆèƒŒåŒ…ï¼Œåç‰©å“
        for (int j = 1; j <= s.size(); j++)
        {
            for (int i = 0; i < j; i++)
            {
                string word = s.substr(i, j - i); // æˆªå–s[i, j-1] 

                // [i, j-1]åœ¨å­—å…¸é‡Œï¼Œä¸”dp[i]ï¼Œä¹Ÿå°±æ˜¯[0, i-1]éƒ¨åˆ†æ˜¯true => [0, j-1] true
                if (wordSet.find(word) != wordSet.end() && dp[i])   dp[j] = true;
            }
        }

        return dp[s.size()];      
    }
};
~~~





## 300 [æœ€é•¿é€’å¢å­åºåˆ—](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

@ å­åºåˆ— dp

![image-20250824204332038](./pic/image-20250824204332038.png)

![](./pic/image-20250824211810584.png)

![image-20250824211912319](./pic/image-20250824211912319.png)



~~~C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {

        if (nums.size() <= 1)   return nums.size();

        // dp[i] - ä»¥nums[i]ç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦
        vector<int> dp(nums.size(), 1);

        int result = 0;
        for (int i = 1; i < nums.size(); i++) // ä»¥nums[i]ç»“å°¾
        {
            for (int j = 0; j < i; j++) // j ä» 0 åˆ° i-1
            {
                if(nums[i] > nums[j])   dp[i] = max(dp[i], dp[j] + 1);
            }

            if (dp[i] > result) result = dp[i]; // å–dpæœ€å¤§å€¼
                                                // æ³¨æ„æœ€å¤§å€¼ä¸ä¸€å®šæ˜¯dp[æœ€åä¸€ä¸ª]
        }

        return result;
    }
};
~~~





## 152 [ä¹˜ç§¯æœ€å¤§å­æ•°ç»„](https://leetcode.cn/problems/maximum-product-subarray/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250827001334450](./pic/image-20250827001334450.png)

ä¾æ—§æ˜¯çµç¥

![image-20250827001327763](./pic/image-20250827001327763.png)

~~~C++
class Solution {
public:
    int maxProduct(vector<int>& nums) {

        int n = nums.size();

        // ä»¥nums[i]ç»“å°¾çš„å­æ•°ç»„çš„æœ€å¤§ä¹˜ç§¯ï¼Œæœ€å°ä¹˜ç§¯
        vector<int> f_max(n), f_min(n);

        f_max[0] = nums[0];
        f_min[0] = nums[0];

        for (int i = 1; i < n; i++)
        {
            int x = nums[i];
            // ã€xå•ç‹¬ã€‘  ã€ä»¥nums[i-1]ç»“å°¾çš„æœ€å¤§ä¹˜ç§¯ * xã€‘  ã€æœ€å°ä¹˜ç§¯ * xã€‘
            f_max[i] = max({x, f_max[i - 1] * x, f_min[i - 1] * x});
            f_min[i] = min({x, f_max[i - 1] * x, f_min[i - 1] * x});
        }

        return ranges::max(f_max); // ranges é‡Œçš„maxå‡½æ•°ï¼Œç›´æ¥å–å®¹å™¨æœ€å¤§å€¼
        
    }
};
~~~

- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œå…¶ä¸­ n æ˜¯ nums çš„é•¿åº¦ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šO(n)ã€‚



**ç©ºé—´ä¼˜åŒ–ï¼ˆçœ‹çœ‹ï¼‰**

![image-20250827001616821](./pic/image-20250827001616821.png)

~~~C++
class Solution {
public:
    int maxProduct(vector<int>& nums) {

        int ans = INT_MIN; // æ³¨æ„å¯èƒ½æœ‰è´Ÿæ•°

        int f_max = 1, f_min = 1; // åªç”¨ä¸¤ä¸ªå˜é‡ï¼Œæ»šåŠ¨è®¡ç®—
        for (int x : nums)
        {
            int mx = f_max; // è®°ä¸€ä¸‹åŸæ¥çš„f_maxï¼Œè¦ä¸ç„¶ä¸‹ä¸€æ­¥å°±è¢«èµ‹å€¼æ–°çš„æ•°äº†
            f_max = max({f_max * x, f_min * x, x});
            f_min = min({mx * x, f_min * x, x});
            
            ans = max(ans, f_max); // æ›´æ–°æœ€å¤§ä¹˜ç§¯
        }

        return ans;
    }
};
~~~

- æ—¶é—´å¤æ‚åº¦ï¼šO(*n*)ï¼Œå…¶ä¸­ *n* æ˜¯ *nums* çš„é•¿åº¦ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ã€‚



## 416 [åˆ†å‰²ç­‰å’Œå­é›†](https://leetcode.cn/problems/partition-equal-subset-sum/?envType=study-plan-v2&envId=top-100-liked)

@ 01èƒŒåŒ…

![image-20250806104850992](pic/image-20250806104850992.png)

![image-20250806105231010](pic/image-20250806105231010.png)

![image-20250806105443328](pic/image-20250806105443328.png)

![image-20250806105512513](pic/image-20250806105512513.png)

![image-20250806105515615](pic/image-20250806105515615.png)

![image-20250806105541083](pic/image-20250806105541083.png)

![image-20250806105550288](pic/image-20250806105550288.png)

![image-20250806105616587](pic/image-20250806105616587.png)



**æ³¨æ„ï¼šç‰©å“çš„é‡é‡å’Œä»·å€¼éƒ½æ˜¯ã€å…ƒç´ æ•°å€¼ã€‘**

![image-20250806110918772](pic/image-20250806110918772.png)

~~~C++
class Solution {
public:
    bool canPartition(vector<int>& nums) {

        int sum = 0;

        // æ³¨æ„ï¼šç‰©å“çš„é‡é‡å’Œä»·å€¼éƒ½æ˜¯ã€å…ƒç´ æ•°å€¼ã€‘

        // èƒŒåŒ…çš„ä½“ç§¯ä¸º sum/2  -- å¯¹åº”ç‰©å“çš„é‡é‡æ˜¯ å…ƒç´ æ•°å€¼
        // ç‰©å“çš„ä»·å€¼ä¹Ÿæ˜¯ å…ƒç´ æ•°å€¼

        // dp[j] èƒŒåŒ…å®¹é‡(èƒ½è£…çš„æ€»é‡é‡)æ˜¯jï¼Œæ”¾è¿›ç‰©å“åèƒŒåŒ…çš„æœ€å¤§é‡é‡ä¸ºdp[j]
        vector<int> dp(10001, 0);

        for (int i = 0; i < nums.size(); i++)
        {
            sum += nums[i];
        }
        if (sum % 2 == 1)   return false;
        int target = sum / 2; // æ‰¾dp[target] == target

        // é€’æ¨å¡«è¡¥dp
        for (int i = 0; i < nums.size(); i++) // å…ˆç‰©å“
        {
            for (int j = target; j >= nums[i]; j--) // åèƒŒåŒ…ï¼Œä»å¤§åˆ°å°
            {
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }

        // sum/2ä½“ç§¯çš„èƒŒåŒ…ï¼Œæ­£å¥½è£…äº†sum/2é‡é‡
        if (dp[target] == target)   return true; 
        
        return false;
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 416 åˆ†å‰²ç­‰å’Œå­é›†ï¼ˆ01èƒŒåŒ…ï¼‰


bool canPartition(vector<int>& nums) {
    int sum = 0;
    // æ³¨æ„ï¼šç‰©å“çš„é‡é‡å’Œä»·å€¼éƒ½æ˜¯ã€å…ƒç´ æ•°å€¼ã€‘

    // èƒŒåŒ…çš„ä½“ç§¯ä¸º sum/2  -- å¯¹åº”ç‰©å“çš„é‡é‡æ˜¯ å…ƒç´ æ•°å€¼
    // ç‰©å“çš„ä»·å€¼ä¹Ÿæ˜¯ å…ƒç´ æ•°å€¼

    // dp[j] èƒŒåŒ…å®¹é‡(èƒ½è£…çš„æ€»é‡é‡)æ˜¯jï¼Œæ”¾è¿›ç‰©å“åèƒŒåŒ…çš„æœ€å¤§é‡é‡ä¸ºdp[j]
    vector<int> dp(10001, 0);

    for (int i = 0; i < nums.size(); i++)
    {
        sum += nums[i];
    }
    if (sum % 2 == 1)   return false;
    int target = sum / 2; // æ‰¾dp[target] == target


    // é€’æ¨å¡«è¡¥dp
    for (int i = 0; i < nums.size(); i++) // å…ˆç‰©å“
    {
        for (int j = target; j >= nums[i]; j--) // åèƒŒåŒ…ï¼Œä»å¤§åˆ°å°
        {
            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
        }
    }

    // sum/2ä½“ç§¯çš„èƒŒåŒ…ï¼Œæ­£å¥½è£…äº†sum/2é‡é‡
    if (dp[target] == target)   return true; 
    
    return false;
}

int main()
{
    vector<int> nums = {1, 5, 11, 5};
    bool ans = canPartition(nums);
    cout << (ans ? "true" : "false") << endl;

    return 0;
}
~~~





## 32 [æœ€é•¿æœ‰æ•ˆæ‹¬å·](https://leetcode.cn/problems/longest-valid-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250827102722400](./pic/image-20250827102722400.png)

### åŠ¨è§„

[åŸé¢˜è§£](https://leetcode.cn/problems/longest-valid-parentheses/solutions/206995/dong-tai-gui-hua-si-lu-xiang-jie-c-by-zhanganan042)  å¤§ç¥ ã€‚ã€‚ã€‚

![image-20250827110131685](./pic/image-20250827110131685.png)

![image-20250827113230386](./pic/image-20250827113230386.png)

![image-20250827113048629](./pic/image-20250827113048629.png)

![image-20250827113305760](./pic/image-20250827113305760.png)

![image-20250827113314497](./pic/image-20250827113314497.png)



~~~C++
class Solution {
public:
    int longestValidParentheses(string s) {

        // dp[i] - ä»¥s[i]ç»“å°¾çš„æœ€é•¿æœ‰æ•ˆæ‹¬å·çš„é•¿åº¦
        vector<int> dp(s.size(), 0);

        int maxLength = 0;
        for (int i = 1; i < s.size(); i++)
        {
            // ä»¥'('ç»“å°¾ï¼Œç»„ä¸æˆæœ‰æ•ˆæ‹¬å· (å¯ä»¥ä¸ç‰¹æ„å†™å‡ºæ¥)
            if (s[i] == '(')  dp[i] = 0; 

            // ä»¥')'ç»“å°¾ï¼Œè€ƒè™‘å‰ä¸€ä¸ªæ‹¬å· s[i-1]
            else if (s[i] == ')') 
            {
                if (s[i - 1] == '(') // æœ€åä¸¤ä¸ªå°±èƒ½ç»„æˆä¸€å¯¹æ‹¬å· ____ ()
                {
                    if (i - 2 >= 0) dp[i] = dp[i - 2] + 2; // _____ ()
                    else            dp[i] = 2;             // ()
                }
                else // s[i - 1ã€‘ == ')'   ____ )) å¾€å‰æ‰¾å’Œiä½ç½®çš„')'å¯¹åº”çš„
                {
                    // ä»¥s[i-1]ç»“å°¾çš„å¿…é¡»æ˜¯æœ‰æ•ˆæ‹¬å·å¯¹ï¼Œ___(__))  æ‰èƒ½å†å¾€å‰æ‰¾å’Œiå¯¹åº”çš„
                    if (dp[i - 1] > 0)   
                    {
                        // å’Œ i çš„')'å¯¹åº”çš„ä½ç½®s[i - dp[i-1] - 1] å¿…é¡»æ˜¯'('   ___((_))
                        if ((i - dp[i-1]-1) >= 0 && s[i - dp[i-1] - 1] == '(')
                        {
                            if (i - dp[i - 1] - 2 >= 0) // æ–°ç‰‡æ®µå‰é¢è¿˜æœ‰(______)((_))
                            {
                                dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2];
                            }
                            else // æ–°ç‰‡æ®µå‰é¢æ²¡æœ‰äº† ((_))
                            {
                                dp[i] = dp[i - 1] + 2;
                            } 
                        }
                    }
                }
            }

            maxLength = max(maxLength, dp[i]); // å–æœ€å¤§é•¿åº¦
        }

        return maxLength;  
    }
};
~~~



### æ ˆ

> å‚è€ƒ ï¼š [æ—å°é¹¿](https://leetcode.cn/u/lin-shen-shi-jian-lu-k/)     [æˆ‘è¦å‡ºå»ä¹±è¯´](https://leetcode.cn/u/wo-yao-chu-qu-luan-shuo/)

å¯ä»¥ä¸¾ä¾‹å­çœ‹ä¸€ä¸‹

![image-20250827162537472](./pic/image-20250827162537472.png)

![image-20250827161019054](./pic/image-20250827161019054.png)

![image-20250827162355548](./pic/image-20250827162355548.png)







# å¤šç»´åŠ¨æ€è§„åˆ’ âœ…

## 62 [ä¸åŒè·¯å¾„](https://leetcode.cn/problems/unique-paths/description/)

![image-20250808105457283](pic/image-20250808105457283.png)

![image-20250808105641427](pic/image-20250808105641427.png)

![image-20250808105658157](pic/image-20250808105658157.png)

~~~C++
class Solution {
public:
    int uniquePaths(int m, int n) {

        // dp[i][j]: ä»(0,0)åˆ°(i,j)ä¸€å…±æœ‰dp[i][j]æ¡è·¯å¾„
        vector<vector<int>> dp(m, vector<int>(n, 0));

        // åˆå§‹åŒ–  ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—éœ€è¦åˆå§‹åŒ–ï¼Œéƒ½åªæœ‰ä¸€æ¡è·¯å¾„
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
        
        // é€’æ¨
        for (int i = 1; i < m; i++)
        {
            for (int j = 1; j < n; j++)
            {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; // ä¸¤ä¸ªæ–¹å‘çš„è·¯å¾„æ•°ç›¸åŠ 
            }
        }

        return dp[m - 1][n - 1];
    }
};
~~~



ACM

~~~C++
#include <iostream>
#include <vector>
using namespace std;


int uniquePaths(int m, int n) 
{
    // dp[i][j]: ä»(0,0)åˆ°(i,j)ä¸€å…±æœ‰dp[i][j]æ¡è·¯å¾„
    vector<vector<int>> dp(m, vector<int>(n, 0));

    // åˆå§‹åŒ–  ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—éœ€è¦åˆå§‹åŒ–ï¼Œéƒ½åªæœ‰ä¸€æ¡è·¯å¾„
    for (int i = 0; i < m; i++) dp[i][0] = 1;
    for (int j = 0; j < n; j++) dp[0][j] = 1;
    
    // é€’æ¨
    for (int i = 1; i < m; i++)
    {
        for (int j = 1; j < n; j++)
        {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; // ä¸¤ä¸ªæ–¹å‘çš„è·¯å¾„æ•°ç›¸åŠ 
        }
    }

    return dp[m - 1][n - 1];
}


int main()
{
    int m = 3, n = 7;
    int ans = uniquePaths(m, n);
    cout << ans << endl;
    
    return 0;
}
~~~





## 64 [æœ€å°è·¯å¾„å’Œ](https://leetcode.cn/problems/minimum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked)

@é€’å½’  @ åŠ¨è§„

![image-20250827175235751](./pic/image-20250827175235751.png)

![image-20250827175006970](./pic/image-20250827175006970.png)

![image-20250827175017970](./pic/image-20250827175017970.png)

![image-20250827175025965](./pic/image-20250827175025965.png)

![image-20250827175032010](./pic/image-20250827175032010.png)

![image-20250827175105067](./pic/image-20250827175105067.png)



### é€’å½’ï¼ˆæ¨èï¼‰

![image-20250827175119100](./pic/image-20250827175119100.png)

![image-20250827175124359](./pic/image-20250827175124359.png)

~~~C++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {

        int m = grid.size();
        int n = grid[0].size();

        // è®°å½•å½“å‰dfsæ˜¯ä¸æ˜¯è°ƒç”¨è¿‡ï¼Œåˆå§‹ -1 è¡¨ç¤ºæœªè°ƒç”¨
        vector<vector<int>> memo(m, vector<int>(n, -1)); 

        // dfs(i, j) å·¦ä¸Šè§’(0,0) â€”â€”> å½“å‰ç‚¹(i,j)çš„æœ€å°ä»·å€¼
        auto dfs = [&](this auto&& dfs, int i, int j) -> int {
            if (i < 0 || j < 0)     return INT_MAX;   
            if (i == 0 && j == 0)   return grid[i][j];  

            // int& res = memo[i][j];
            if (memo[i][j] != -1)  return memo[i][j]; // ä¹‹å‰è®¡ç®—è¿‡ï¼Œç›´æ¥è¿”å›ç»“æœ

            return memo[i][j] = min(dfs(i, j - 1), dfs(i - 1, j)) + grid[i][j]; // æœªè®¡ç®—è¿‡
        };

        return dfs(grid.size() - 1, grid[0].size() - 1);  
    }
};
~~~



### åŠ¨è§„

![image-20250827175404374](./pic/image-20250827175404374.png)

![image-20250827175409508](./pic/image-20250827175409508.png)



~~~C++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {

        int m = grid.size();
        int n = grid[0].size();

        // dp[i+1][j+1] - ä»å·¦ä¸Šè§’åˆ°(i,j)çš„æœ€å°å’Œ
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX));

        // +1 ç›¸å½“äº dp åœ¨åŸgridèŒƒå›´ä¸Šæœ€å·¦å’Œæœ€ä¸ŠåŠ äº†ä¸€å±‚ï¼ŒæŠŠè¶Šç•Œçš„æ— ç©·æƒ…å†µç›´æ¥åŠ è¿›æ¥äº†
        // ä½†æ˜¯ +1ï¼Œåªæ˜¯åœ¨dpä¸ŠåŠ çš„ï¼Œä¸å½±å“åŸgridï¼ŒåŠ çš„è¿˜æ˜¯éå†åˆ°çš„åŸ(i,j)ä½ç½®çš„å€¼

        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (i == 0 && j == 0)   dp[1][1] = grid[i][j];
                else 
                {
                    dp[i + 1][j + 1] = min(dp[i+1][j], dp[i][j+1]) + grid[i][j];
                }
            }
        }

        return dp[m][n];
    }
};
~~~



æŠŠ `dp[0][1]`æˆ–è€…  `dp[1][0]` åˆå§‹åŒ–æˆ0ï¼Œè¿™æ · `dp[1][1]` å¯ä»¥ç”¨é€’æ¨å¼è®¡ç®—äº†ï¼Œæ— éœ€ç‰¹åˆ¤ã€‚

åªèƒ½åˆå§‹åŒ–ä¸€ä¸ªï¼Œå› ä¸ºè¦å– minï¼Œå–`0 + grid[0][0] = dp[1][1]`

**æœ€ç»ˆç‰ˆ**

~~~C++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {

        int m = grid.size();
        int n = grid[0].size();

        // dp[i+1][j+1] - ä»å·¦ä¸Šè§’åˆ°(i,j)çš„æœ€å°å’Œ
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX));
        dp[0][1] = 0;

        // +1 ç›¸å½“äº dp åœ¨åŸgridèŒƒå›´ä¸Šæœ€å·¦å’Œæœ€ä¸ŠåŠ äº†ä¸€å±‚ï¼ŒæŠŠè¶Šç•Œçš„æ— ç©·æƒ…å†µç›´æ¥åŠ è¿›æ¥äº†
        // ä½†æ˜¯ +1ï¼Œåªæ˜¯åœ¨dpä¸ŠåŠ çš„ï¼Œä¸å½±å“åŸgridï¼ŒåŠ çš„è¿˜æ˜¯éå†åˆ°çš„åŸ(i,j)ä½ç½®çš„å€¼

        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                dp[i + 1][j + 1] = min(dp[i+1][j], dp[i][j+1]) + grid[i][j];
            }
        }

        return dp[m][n];
    }
};
~~~





## 5 [æœ€é•¿å›æ–‡å­ä¸²](https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250829113653761](./pic/image-20250829113653761.png)

### åŠ¨æ€è§„åˆ’

> 647 å›æ–‡å­ä¸²æ˜¯æ±‚ä¸ªæ•°ï¼Œ5 æ˜¯æ±‚æœ€é•¿é•¿åº¦

`dp[i][j]` â€”ã€i, jã€‘èŒƒå›´çš„sæ˜¯å¦ä¸ºå›æ–‡å­ä¸² +  è®°å½•æœ€é•¿å›æ–‡å­ä¸²èŒƒå›´ 

~~~C++
class Solution {
public:
    string longestPalindrome(string s) {

        // dp[i][j] - èŒƒå›´[i, j]çš„så­ä¸²æ˜¯å¦æ˜¯å›æ–‡å­ä¸²
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));

        int maxLength = 0; // è®°å½•æœ€é•¿å›æ–‡å­ä¸²é•¿åº¦
        int left = 0;
        int right = 0;

        for (int i = s.size(); i >= 0; i--)
        {
            for (int j = i; j < s.size(); j++)
            {
                if (s[i] == s[j])
                {
                    if (j - i <= 1)             dp[i][j] = true; // 'a' æˆ– 'aa'
                    else if (dp[i + 1][j - 1])  dp[i][j] = true; // 'a _ _ _ a'
                }


                if (dp[i][j] && j - i + 1 > maxLength) // æ›´æ–°æœ€é•¿é•¿åº¦
                {
                    maxLength = j - i + 1;
                    left = i;
                    right = j;
                }
            }
        }

        return s.substr(left, maxLength); // æˆªå–å­ä¸²        
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ï¼š$O(N^2)$ 

ç©ºé—´å¤æ‚åº¦ï¼š$O(N^2)$ 



### åŒæŒ‡é’ˆ

ä»¥ s çš„æ¯ä¸ªå­—ç¬¦ä¸ºä¸­å¿ƒï¼Œå‘ä¸¤è¾¹è¿›è¡Œæ‰©å±• extend()ï¼Œå¾—åˆ°æœ€é•¿å›æ–‡èŒƒå›´

ä½†æ˜¯è¦æ³¨æ„åœ¨éå†ä¸­å¿ƒç‚¹çš„ä¸¤ç§æƒ…å†µï¼šä¸€ä¸ªå…ƒç´ å¯ä»¥ä½œä¸ºä¸­å¿ƒç‚¹ï¼Œä¸¤ä¸ªå…ƒç´ ä¹Ÿå¯ä»¥ä½œä¸ºä¸­å¿ƒç‚¹ã€‚

æ¯”å¦‚ ï¼š`___b a b___`  `___b a a b___`

~~~C++
class Solution {
public:

    int left = 0;
    int right = 0;
    int maxLength = 0;

    // å›æ–‡æ‰©å±•ï¼šä»ç»™å®šçš„ä¸­å¿ƒ [i, j] å‘ä¸¤è¾¹æ‰©å±•ï¼Œç›´åˆ°é‡åˆ°ä¸åŒçš„å­—ç¬¦ä¸ºæ­¢ï¼Œè®°å½•æœ€é•¿æ‰©å±•é•¿åº¦
    void extend(const string& s, int i, int j, int n)
    {
        while (i >= 0 && j < n && s[i] == s[j])
        {
            if (j - i + 1 > maxLength)
            {
                left = i;
                right = j;
                maxLength = j - i + 1;
            }

            i--;
            j++; // å‘ä¸¤è¾¹æ‰©å±•
        }
    }


    string longestPalindrome(string s) {
        
        int result = 0;

        // å°†sçš„æ¯ä¸ªå­—ç¬¦ï¼Œä½œä¸ºå›æ–‡ä¸­å¿ƒï¼Œå‘ä¸¤è¾¹æ‰©å±•ï¼Œè®°å½•æ¯ä¸ªs[i]èƒ½æ‰©å±•çš„é•¿åº¦
        for (int i = 0; i < s.size(); i++)
        {
            // æ³¨æ„ä¸­å¿ƒç‚¹çš„ä¸¤ç§æƒ…å†µ
            extend(s, i, i, s.size());     // ä»¥ i ä¸ºä¸­å¿ƒ          '__ b a b __'
            extend(s, i, i + 1, s.size()); // ä»¥ i å’Œ i + 1 ä¸ºä¸­å¿ƒ '__ b a a b __'
        }

        return s.substr(left, maxLength);        
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ï¼š$O(N^2)$ 

ç©ºé—´å¤æ‚åº¦ï¼šO(1)





## 1143 [æœ€é•¿å…¬å…±å­åºåˆ—](https://leetcode.cn/problems/longest-common-subsequence/description/?envType=study-plan-v2&envId=top-100-liked)

@ dp æœ€å·¦æœ€ä¸Šæ‰©å……

![image-20250829180433869](./pic/image-20250829180433869.png)

**dp æœ€å·¦å’Œæœ€ä¸Šæ‰©å……ï¼Œé¿å…å•ç‹¬å¤„ç†é¦–è¡Œé¦–åˆ—ï¼Œå’Œ 718 ç±»ä¼¼**

![image-20250829205843184](./pic/image-20250829205843184.png)

![image-20250829205849035](./pic/image-20250829205849035.png)

![image-20250829205855349](./pic/image-20250829205855349.png)

![image-20250829205900609](./pic/image-20250829205900609.png)

![image-20250829205907143](./pic/image-20250829205907143.png)

~~~C++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {

        // dp[i][j] - text1çš„[0, i-1]èŒƒå›´ å’Œ text2çš„[0, j-1]èŒƒå›´ çš„æœ€é•¿å…¬å…±å­åºåˆ—
        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));

        for (int i = 1; i <= text1.size(); i++)
        {
            for (int j = 1; j <= text2.size(); j++)
            {
                if (text1[i - 1] == text2[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else // text1[i] != text2[j]
                {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[text1.size()][text2.size()];
    }
};
~~~



å¦‚æœå®šä¹‰dpæ•°ç»„ï¼š

`dp[i][j] ` è¡¨ç¤º **text1[0, i] å’Œ text2[0, j]** èŒƒå›´çš„æœ€é•¿å…¬å…±å­åºåˆ—ï¼Œ**dpå¤§å°ä¸ºï¼ˆtext1.size(), test2.size()ï¼‰**

**å¦‚æœä¸åˆå§‹åŒ–ï¼Œéœ€è¦å•ç‹¬å¤„ç†é¦–è¡Œé¦–åˆ—**

![image-20250829180255751](./pic/image-20250829180255751.png)

**å¯¹ç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—åˆå§‹åŒ–**

![image-20250829180344020](./pic/image-20250829180344020.png)

![image-20250829180357791](./pic/image-20250829180357791.png)





## 72 [ç¼–è¾‘è·ç¦»](https://leetcode.cn/problems/edit-distance/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250830195946489](./pic/image-20250830195946489.png)

![image-20250830203024915](./pic/image-20250830203024915.png)

![image-20250830202916922](./pic/image-20250830202916922.png)

![image-20250830203112530](./pic/image-20250830203112530.png)



~~~C++
class Solution {
public:
    int minDistance(string word1, string word2) {

        // word1 = "horse", word2 = "ros"

        // dp[i][j] - ä»¥word1[i-1]ç»“å°¾ï¼Œå’Œä»¥word2[j-1]ç»“å°¾çš„éƒ¨åˆ†ï¼Œæœ€è¿‘ç¼–è¾‘è·ç¦»ä¸ºdp[i][j]
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));

        // åˆå§‹åŒ–
        for (int i = 0; i <= word1.size(); i++)  dp[i][0] = i; // word1 å’Œ ç©ºword2
        for (int j = 0; j <= word2.size(); j++)  dp[0][j] = j; // ç©ºword1 å’Œ word1


        for (int i = 1; i <= word1.size(); i++)
        {
            for (int j = 1; j <= word2.size(); j++)
            {
                // ç›¸åŒï¼Œä¸éœ€è¦æ“ä½œï¼Œå»¶ç»­ä¸Šä¸€ä¸ªç»“æœ 
                if (word1[i - 1] == word2[j - 1])  
                {
                    dp[i][j] = dp[i - 1][j - 1]; 
                }
                else // word1[i - 1] != word2[j - 1]  å›ºå®šå¯¹ word1 å¢ åˆ  æ”¹
                {
                    dp[i][j] = min({dp[i - 1][j] + 1,  // word1åˆ ä¸€ä¸ª
                                    dp[i][j - 1] + 1,  // word2åˆ ä¸€ä¸ª <==> word1å¢åŠ 
                                    dp[i - 1][j - 1] + 1}); // æ›¿æ¢word1[i-1]
                }
            }
        }

        return dp[word1.size()][word2.size()];
    }
};
~~~

















# å›¾è®º âœ…

## 200 [å²›å±¿æ•°é‡](https://leetcode.cn/problems/number-of-islands/description/)

![image-20250825232030133](./pic/image-20250825232030133.png)

<img src="./pic/image-20250825233129525.png" alt="image-20250825233129525" style="zoom:50%;" />

æœ¬é¢˜æ€è·¯ï¼š**é‡åˆ°ä¸€ä¸ªæ²¡æœ‰éå†è¿‡çš„é™†åœ°ï¼Œè®¡æ•°å™¨å°±åŠ ä¸€**ï¼Œç„¶åæŠŠ**è¯¥èŠ‚ç‚¹é™†åœ°æ‰€èƒ½éå†åˆ°çš„é™†åœ°éƒ½æ ‡è®°**ä¸Šã€‚

åœ¨é‡åˆ°æ ‡è®°è¿‡çš„é™†åœ°èŠ‚ç‚¹å’Œæµ·æ´‹èŠ‚ç‚¹çš„æ—¶å€™ç›´æ¥è·³è¿‡ã€‚ è¿™æ ·**è®¡æ•°å™¨å°±æ˜¯æœ€ç»ˆå²›å±¿çš„æ•°é‡**ã€‚



### æ·±æœdfs

**`result` ä½œä¸ºå²›å±¿è®¡æ•°å™¨ã€‚éå†`grid`æ¯ä¸ªèŠ‚ç‚¹ï¼šæ¯ä¸ªæœªæ ‡è®°æ–°é™†åœ°éƒ½æ˜¯æ–°å²›å±¿èµ·ç‚¹**

- é‡åˆ°æ–°çš„æœªæ ‡è®°é™†åœ°ï¼Œå…ˆæ ‡è®°`visited`ï¼Œç„¶åè®¡æ•°`result + 1`ï¼Œè¡¨ç¤ºé‡åˆ°äº†æ–°å²›å±¿çš„èµ·å§‹ç‚¹

- dfs ä¸»è¦ç”¨æ¥æ ‡è®°è¿™å—æ–°å²›å±¿èƒ½è¿æ¥ä¸Šçš„æ‰€æœ‰é™†åœ° `visited[][]`ï¼Œèµ°å®Œè¿™ä¸€å±‚dfsï¼Œä¹Ÿå°±æ ‡è®°å®Œäº†è¿™å—å²›å±¿

- è¿™æ ·åœ¨ä¸‹ä¸€è½®ï¼Œå†é‡åˆ°æ–°çš„æœªæ ‡è®°é™†åœ°ï¼Œåˆå¯ä»¥ä½œä¸ºæ–°å²›å±¿çš„èµ·å§‹ï¼Œ`result + 1`

~~~C++
class Solution {
public:
    int dir[4][2] = {0,1, 1,0, -1,0, 0,-1}; // å››ä¸ªæ–¹å‘

    void dfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y)
    {
        // {x, y} å½“å‰èŠ‚ç‚¹çš„åæ ‡ï¼Œç¬¬xè¡Œï¼Œç¬¬yåˆ—
        
        // éå†å½“å‰èŠ‚ç‚¹{x, y}çš„å››ä¸ªæ–¹å‘
        for (int i = 0; i < 4; i++)
        {
            int nextx = x + dir[i][0];
            int nexty = y + dir[i][1];

            if (nextx < 0 || nextx >= grid.size() ||
                nexty < 0 || nexty >= grid[0].size())
            {
                continue; // è¶…å‡ºç•Œé™ï¼Œç›´æ¥è·³è¿‡
            }

            // æ˜¯é™†åœ°ä¸”æ²¡è¢«è®¿é—®è¿‡
            if (!visited[nextx][nexty] && grid[nextx][nexty] == '1') 
            {
                visited[nextx][nexty] = true;
                dfs(grid, visited, nextx, nexty); // é€’å½’
            }

        }
    }

    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size();   // nè¡Œ
        int m = grid[0].size();// måˆ—

        vector<vector<bool>> visited(n, vector<bool>(m, false)); // æ ‡è®°æ˜¯å¦è®¿é—®è¿‡

        int result = 0;
        // resultè®°å½•é‡åˆ°çš„ç¬¦åˆçš„æ–°å²›å±¿çš„ä¸ªæ•°ï¼Œdfsç”¨æ¥æ ‡è®°è¿™å—å²›å±¿èƒ½è¿æ¥ä¸Šçš„æ‰€æœ‰é™†åœ°
        
        // éå†gridæ¯ä¸ªèŠ‚ç‚¹ï¼Œæ¯ä¸ªæœªæ ‡è®°é™†åœ°éƒ½æ˜¯æ–°å²›å±¿èµ·å§‹ç‚¹
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (!visited[i][j] && grid[i][j] == '1')
                {
                    visited[i][j] = true;
                    result++; // é‡åˆ°æ–°å²›å±¿èµ·å§‹ç‚¹[i, j]ï¼Œå²›å±¿æ•°é‡+1

                    dfs(grid, visited, i, j); // å°†ä¸ [i, j] è¿æ¥ä¸Šçš„é™†åœ°éƒ½æ ‡è®°ä¸Š
                }
            }
        }

        return result;
    }
    
};
~~~

ä¸Šé¢çš„ç»ˆæ­¢æ¡ä»¶å°±å†™åœ¨äº† è°ƒç”¨dfsçš„åœ°æ–¹ï¼Œå¦‚æœé‡åˆ°ä¸åˆæ³•çš„æ–¹å‘ï¼Œç›´æ¥ä¸ä¼šå»è°ƒç”¨dfsã€‚

ä¹Ÿå¯ä»¥æ˜ç¡®åœ¨dfså¼€å¤´å†™ä¸Šç»ˆæ­¢æ¡ä»¶

~~~C++
void dfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y)
{
    // ç»ˆæ­¢ï¼šèŠ‚ç‚¹è®¿é—®è¿‡ï¼Œæˆ–è€…æ˜¯æµ·æ°´
    if (visited[x][y] || grid[x][y] == '0') return; 

    visited[x][y] = true; // æ ‡è®°     

    for (int i = 0; i < 4; i++)
    {
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];

        if (nextx < 0 || nextx >= grid.size() ||
            nexty < 0 || nexty >= grid[0].size())
        {
            continue; 
        }

        dfs(grid, visited, nextx, nexty); // åˆ¤æ–­æ¡ä»¶æ”¾åˆ°å‰é¢å»äº†ï¼Œè¿™é‡Œç›´æ¥é€’å½’
    }
}
~~~

ç‰ˆæœ¬ä¸€ä¸­ è°ƒç”¨dfs çš„æ¡ä»¶ï¼Œæ”¾åœ¨äº† ç‰ˆæœ¬äºŒ çš„ ç»ˆæ­¢æ¡ä»¶ä½ç½®ä¸Šã€‚

ç‰ˆæœ¬ä¸€çš„å†™æ³•æ˜¯ ï¼šä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦èƒ½åˆæ³•å·²ç»åˆ¤æ–­å®Œäº†ï¼Œåªè¦è°ƒç”¨dfså°±æ˜¯å¯ä»¥åˆæ³•çš„èŠ‚ç‚¹ã€‚

ç‰ˆæœ¬äºŒçš„å†™æ³•æ˜¯ï¼šä¸ç®¡èŠ‚ç‚¹æ˜¯å¦åˆæ³•ï¼Œä¸Šæ¥å°±dfsï¼Œç„¶ååœ¨ç»ˆæ­¢æ¡ä»¶çš„åœ°æ–¹è¿›è¡Œåˆ¤æ–­ï¼Œä¸åˆæ³•å†returnã€‚

ç†è®ºä¸Šæ¥è®²ï¼Œç‰ˆæœ¬ä¸€çš„æ•ˆç‡æ›´é«˜ä¸€äº›ï¼Œå› ä¸ºé¿å…äº† æ²¡æœ‰æ„ä¹‰çš„é€’å½’è°ƒç”¨ï¼Œåœ¨è°ƒç”¨dfsä¹‹å‰ï¼Œå°±åšåˆæ³•æ€§åˆ¤æ–­ã€‚ ä½†ä»å†™æ³•æ¥è¯´ï¼Œå¯èƒ½ç‰ˆæœ¬äºŒ æ›´åˆ©äºç†è§£ä¸€äº›ã€‚ï¼ˆä¸è¿‡å…¶å®éƒ½å·®ä¸å¤ªå¤šï¼‰







**ACMï¼ˆkama 99ï¼‰**

![image-20250825233041504](./pic/image-20250825233041504.png)

~~~C++
#include <iostream>
#include <vector>
using namespace std;

int dir[4][2] = {0, 1, 0, -1, 1, 0, -1, 0};
void dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y)
{
    for (int i = 0; i < 4; i++)
    {
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        if (nextx < 0 || nextx >= grid.size() ||
            nexty < 0 || nexty >= grid[0].size())
        {
            continue;
        }

        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1)
        {
            visited[nextx][nexty] = true;
            dfs(grid, visited, nextx, nexty);
        }
    }
}




int main()
{
    int n = 0, m = 0; // nè¡Œ  måˆ—
    cin >> n >> m;

    vector<vector<int>> grid(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin >> grid[i][j];
        }
    }

    vector<vector<bool>> visited(n, vector<bool>(m, false));
    int result = 0;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if (!visited[i][j] && grid[i][j] == 1)
            {
                visited[i][j] = true;
                result++;
                dfs(grid, visited, i, j);
            }
        }
    }

    cout << result << endl;


    return 0;
}
~~~





### å¹¿æœbfs

**dfs æ¢æˆ bfsï¼Œqueueå­˜æ”¾èµ°è¿‡çš„èŠ‚ç‚¹åæ ‡**

- é‡åˆ°æ–°çš„æœªæ ‡è®°é™†åœ°ï¼Œå°±æ˜¯æ–°çš„å²›å±¿ï¼Œç›´æ¥è®¡æ•°`result + 1`

- è¿›å…¥ bfs æ ‡è®°è¿™å—æ–°å²›å±¿èƒ½è¿æ¥ä¸Šçš„æ‰€æœ‰é™†åœ° `visited[][]`
  - å–å‡ºqueä¸­èŠ‚ç‚¹ï¼Œæ ‡è®°4ä¸ªæ–¹å‘ï¼Œç¬¦åˆçš„é™†åœ°èŠ‚ç‚¹**åŠ å…¥é˜Ÿåˆ—ï¼Œä»£è¡¨èµ°è¿‡ï¼Œéœ€è¦æ ‡è®°**ï¼ˆè€Œä¸æ˜¯ä»é˜Ÿåˆ—æ‹¿å‡ºæ¥çš„æ—¶å€™å†å»æ ‡è®°èµ°è¿‡ï¼‰ï¼Œå¾ªç¯è¿™ä¸ªè¿‡ç¨‹ï¼Œç›´åˆ°queä¸­æ²¡æœ‰èŠ‚ç‚¹ï¼ˆå½“å‰è¿™å—å²›å±¿æ ‡è®°å®Œæˆï¼‰
- å†éå†é‡åˆ°æ–°çš„æœªæ ‡è®°é™†åœ°ï¼Œå† `result + 1`ï¼Œå†bfsæ ‡è®°è¿™å—æ–°å²›å±¿



~~~C++
class Solution {
public:
    int dir[4][2] = {0,1, 1,0, -1,0, 0,-1}; // å››ä¸ªæ–¹å‘

    void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y)
    {
        queue<pair<int, int>> que; // å­˜æ”¾å·²ç»èµ°è¿‡çš„åæ ‡ {x, y}
        que.push({x, y});

        visited[x][y] = true; // åªè¦åŠ å…¥é˜Ÿåˆ—ï¼Œå°±æ ‡è®°

        while (!que.empty())
        {
            pair<int, int> cur = que.front();
            que.pop();

            int curx = cur.first;
            int cury = cur.second;

            // å¤„ç†curçš„4ä¸ªæ–¹å‘
            for (int i = 0; i < 4; i++)
            {
                int nextx = curx + dir[i][0];
                int nexty = cury + dir[i][1];
                if (nextx < 0 || nextx >= grid.size() ||
                    nexty < 0 || nexty >= grid[0].size())
                {
                    continue;
                }

                if (!visited[nextx][nexty] && grid[nextx][nexty] == '1')
                {
                    que.push({nextx, nexty});     // åŠ å…¥é˜Ÿåˆ—
                    visited[nextx][nexty] = true; // æ ‡è®°
                }
            }
        }
    }

    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size();   // nè¡Œ
        int m = grid[0].size();// måˆ—

        vector<vector<bool>> visited(n, vector<bool>(m, false)); // æ ‡è®°æ˜¯å¦è®¿é—®è¿‡

        int result = 0; // resultè®°å½•é‡åˆ°çš„ç¬¦åˆçš„æ–°å²›å±¿çš„ä¸ªæ•°
        
        // æ¢æˆ bfs æ¥æ ‡è®°è¿™å—å²›å±¿èƒ½è¿æ¥ä¸Šçš„æ‰€æœ‰é™†åœ°
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (!visited[i][j] && grid[i][j] == '1')
                {
                    result++; // é‡åˆ°æ–°å²›å±¿èµ·å§‹ç‚¹[i, j]ï¼Œå²›å±¿æ•°é‡+1
                    bfs(grid, visited, i, j); // å°†ä¸ [i, j] è¿æ¥ä¸Šçš„é™†åœ°éƒ½æ ‡è®°ä¸Š
                }
            }
        }

        return result;       
    }
};
~~~



**æ³¨æ„ï¼šæ ‡è®°çš„æ—¶æœº**

å¦‚æœä»é˜Ÿåˆ—æ‹¿å‡ºèŠ‚ç‚¹ï¼Œå†å»æ ‡è®°è¿™ä¸ªèŠ‚ç‚¹èµ°è¿‡ï¼Œå°±ä¼šå‘ç”Ÿä¸‹å›¾æ‰€ç¤ºçš„ç»“æœï¼Œä¼šå¯¼è‡´å¾ˆå¤šèŠ‚ç‚¹é‡å¤åŠ å…¥é˜Ÿåˆ—ã€‚

![image-20250826160550820](./pic/image-20250826160550820.png)



ACM

~~~C++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int dir[4][2] = {0, 1, 0, -1, 1, 0, -1, 0};

void bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y)
{
    queue<pair<int, int>> que;
    que.push({x, y});
    visited[x][y] = true;

    while (!que.empty())
    {
        pair<int, int> cur = que.front();
        que.pop();

        int curx = cur.first;
        int cury = cur.second;

        for (int i = 0; i < 4; i++)
        {
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1];
            if (nextx < 0 || nextx >= grid.size() || 
                nexty < 0 || nexty >= grid[0].size())
            {
                continue;
            }

            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1)
            {
                que.push({nextx, nexty});
                visited[nextx][nexty] = true;
            }

        }
    }
}




int main()
{
    int n = 0, m = 0; // nè¡Œ  måˆ—
    cin >> n >> m;

    vector<vector<int>> grid(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin >> grid[i][j];
        }
    }

    vector<vector<bool>> visited(n, vector<bool>(m, false));
    int result = 0;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if (!visited[i][j] && grid[i][j] == 1)
            {
                result++;
                bfs(grid, visited, i, j);
            }
        }
    }

    cout << result << endl;

    return 0;
}
~~~







## 994 [è…çƒ‚çš„æ©˜å­](https://leetcode.cn/problems/rotting-oranges/description/?envType=study-plan-v2&envId=top-100-liked)

@ bfs

![image-20250829153837263](./pic/image-20250829153837263.png)

![image-20250829154739226](./pic/image-20250829154739226.png)



**æ³¨æ„ï¼š**

`while (fresh && !que.empty()) ` é‡Œï¼Œè¦è®°å½•æ¯å±‚queçš„å¤§å°ï¼Œè¦æŠŠå½“å‰queä¸­çš„ã€æ‰€æœ‰çš„è…çƒ‚æ©˜å­ã€‘çš„å››ä¸ªæ–¹å‘éƒ½æ±¡æŸ“äº†ï¼Œæ‰ç®—è¿™å±‚ç»“æŸï¼›

å¦‚æœä¸åŠ è¿™ä¸ª `int sz = que.size();  for (int k = 0; k < sz; k++) {}` ï¼Œè¿™æ ·å¤„ç†çš„åªæ˜¯ä¸€ä¸ªè…çƒ‚æ©˜å­

~~~C++
class Solution {
public:
    // bfs

    int dir[4][2] = {0, 1, 0, -1, 1, 0, -1, 0};
    
    int orangesRotting(vector<vector<int>>& grid) {

        int m = grid.size();
        int n = grid[0].size();

        int ans = 0; 	// å…¨éƒ¨è…çƒ‚çš„åˆ†é’Ÿæ•°
        int fresh = 0; 	// æ–°é²œæ©˜å­ä¸ªæ•°
        
        queue<pair<int, int>> que; // å­˜æ”¾å·²ç»è…çƒ‚çš„æ©˜å­åæ ‡
        
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (grid[i][j] == 1)        fresh++; // æ”¶é›†åˆå§‹çš„æ–°é²œæ©˜å­ä¸ªæ•°
                else if (grid[i][j] == 2)   que.push({i, j}); //ä¸€å¼€å§‹å°±è…çƒ‚çš„æ©˜å­
            }
        }


        while (fresh && !que.empty()) 
        {
            ans++; // ç»è¿‡ä¸€åˆ†é’Ÿ
            
            // è¿™ä¸€åˆ†é’Ÿè…çƒ‚ï¼Œè¦å»æ±¡æŸ“å½“å‰queä¸­ã€æ‰€æœ‰çš„è…çƒ‚æ©˜å­ã€‘çš„å‘¨å›´å››ä¸ªæ–¹å‘ ï¼ï¼ï¼

            int sz = que.size(); // å½“å‰å±‚çš„è…çƒ‚æ©˜å­æ•°é‡ï¼Œæ¯ä¸ªéƒ½è¦å»æ±¡æŸ“4ä¸ªæ–¹å‘ ï¼ï¼ï¼
            for (int k = 0; k < sz; k++) 
            {
                auto [curx, cury] = que.front(); // å–å‡ºè…çƒ‚æ©˜å­ cur
                que.pop();

                for (int i = 0; i < 4; i++) // å»æ±¡æŸ“ cur çš„å››ä¸ªæ–¹å‘ä¸Šçš„æ–°é²œæ©˜å­
                {
                    int nextx = curx + dir[i][0];
                    int nexty = cury + dir[i][1];

                    // è¶Šç•Œï¼Œè·³è¿‡
                    if (nextx < 0 || nextx >= m || nexty < 0 || nexty >= n) continue;

                    // é‡åˆ°æ–°é²œæ©˜å­
                    if (grid[nextx][nexty] == 1) 
                    {
                        fresh--;                  // æ–°é²œæ©˜å­è®¡æ•°-1
                        grid[nextx][nexty] = 2;   // å˜æˆè…çƒ‚æ©˜å­ï¼Œé¿å…é‡å¤å¤„ç†
                        que.push({nextx, nexty}); // åŠ å…¥è…çƒ‚é˜Ÿåˆ—
                    }
                }
            
            }
        }


        // å¦‚æœæœ€å fresh = 0 æ‰è¯´æ˜æ²¡æœ‰æ–°é²œæ©˜å­äº†
        return fresh ? -1 : ans;
    }
};
~~~



## 207 [è¯¾ç¨‹è¡¨](https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250829215719156](./pic/image-20250829215719156.png)

æ¯é—¨è¯¾ç¨‹ç›¸å½“äºæ˜¯èŠ‚ç‚¹ï¼Œä¾èµ–å…³ç³»æ˜¯è¾¹ï¼ŒäºŒè€…æ„æˆäº†ä¸€ä¸ªæœ‰å‘å›¾ã€‚

æœ¬é¢˜è½¬åŒ–ä¸º**åˆ¤æ–­æœ‰å‘å›¾ä¸­æ˜¯å¦å­˜åœ¨ç¯**ã€‚

ä¸¾ä¾‹å­çœ‹å§



### 1ã€æ‹“æ‰‘æ’åº ï¼ˆæ¨èï¼‰

æ€è·¯æ›´æ¸…æ™°

![image-20250829233127663](./pic/image-20250829233127663.png)



canLearn æ”¶é›†è‡ªç”±è¯¾ç¨‹

æ¨¡æ‹Ÿå­¦ä¹ è¿‡ç¨‹ï¼Œä»è‡ªç”±è¯¾ç¨‹å¼€å§‹å­¦ä¹ ï¼Œä¸æ–­å‡å°‘å…¶ä»–è¯¾ç¨‹çš„å…ˆä¿®å¸¦æ¥çš„å…¥åº¦ï¼Œç›´åˆ°å˜æˆè‡ªç”±è¯¾ç¨‹

æœ€åæ¯”è¾ƒ å·²å­¦è¯¾ç¨‹æ•° == æ‰€æœ‰è¯¾ç¨‹æ•°ï¼Ÿç›¸ç­‰åˆ™èƒ½å®Œæˆå­¦ä¹ ä»»åŠ¡

~~~C++
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {

        int n = prerequisites.size();

        if (n == 0) return true; // æ²¡æœ‰ä¾èµ–å…³ç³»ï¼Œç›´æ¥è¿”å›true

        vector<int> indegree(numCourses);          // æ¯ä¸ªèŠ‚ç‚¹çš„å…¥åº¦
        vector<vector<int>> adjacency(numCourses); // é‚»æ¥çŸ©é˜µï¼šå…ˆä¿®è¯¾ç¨‹-->åç»­è¯¾ç¨‹é›†åˆ

        // ç»Ÿè®¡æ‰€æœ‰èŠ‚ç‚¹çš„å…¥åº¦ï¼Œæ„å»ºé‚»æ¥çŸ©é˜µ
        for (int i = 0; i < n; i++)
        {
            indegree[prerequisites[i][0]]++; 
            adjacency[prerequisites[i][1]].push_back(prerequisites[i][0]);
        }

        
        // canLearn æ”¶é›†å…¥åº¦ä¸º 0 çš„èŠ‚ç‚¹ï¼ˆå…¥åº¦ = 0è¡¨ç¤ºè¿™é—¨è¯¾ç°åœ¨æ˜¯è‡ªç”±è¯¾ç¨‹ï¼Œä¸å—å…ˆä¿®é™åˆ¶ï¼‰
        queue<int> canLearn; 
        for (int i = 0; i < numCourses; i++)
        {
            if (indegree[i] == 0)   canLearn.push(i);
        }


        // æ¨¡æ‹Ÿå­¦ä¹ è¿‡ç¨‹ï¼Œä»è‡ªç”±è¯¾ç¨‹å¼€å§‹å­¦ä¹ ï¼š
        // ä»canLearnä¸­å–å‡ºè¯¾ç¨‹ A å­¦ä¹ ï¼Œå¹¶å‡å°‘ä»¥Aä½œä¸ºå…ˆåºçš„å…¶ä»–è¯¾ç¨‹çš„å…¥åº¦
        // å½“ä¸€é—¨è¯¾çš„å…¥åº¦å‡å°‘ä¸º0ï¼Œé‚£ä¹ˆå®ƒä¹Ÿå¯ä»¥åŠ å…¥canLearn

        int learned_count = 0; // è®°å½•å·²å­¦çš„è¯¾ç¨‹æ•°
        while (!canLearn.empty())
        {
            int learned = canLearn.front(); // å–å‡ºå¯å­¦ä¹ è¯¾ç¨‹
            canLearn.pop();
            learned_count++;

            // è¿™é—¨è¯¾å­¦å®Œäº†ï¼Œé‚£ä¹ˆä»¥è¿™é—¨è¯¾ä¸ºå…ˆä¿®çš„å…¶ä»–è¯¾ç¨‹èŠ‚ç‚¹ï¼Œå¯ä»¥å‡å°‘ä¸€ä¸ªå…¥åº¦
            for (int i = 0; i < adjacency[learned].size(); i++)
            {
                indegree[adjacency[learned][i]]--;

                // æœ‰åç»­è¯¾ç¨‹çš„å…¥åº¦å‡ä¸ºé›¶äº†ï¼Œåˆ™å…¶å˜ä¸ºäº†è‡ªç”±è¯¾ç¨‹ï¼ŒåŠ å…¥canLearn
                if (indegree[adjacency[learned][i]] == 0)
                {
                    canLearn.push(adjacency[learned][i]);
                }
            }

        }

        // æœ€åï¼Œå¦‚æœå·²å­¦çš„è¯¾ç¨‹æ•° = è¯¾ç¨‹æ€»æ•°ï¼Œè¯´æ˜å­¦ä¹ å®Œæˆ
        return learned_count == numCourses;        
    }
};
~~~





### 2ã€æ ‡è®° + dfs

![image-20250829224719809](./pic/image-20250829224719809.png)

![image-20250829224906239](./pic/image-20250829224906239.png)

![image-20250829224912204](./pic/image-20250829224912204.png)

~~~C++
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {

        // æ ¹æ®prerequisitesåˆ›å»ºæœ‰å‘å›¾gridï¼Œpre[a, b] æ–¹å‘æ˜¯ b-->a
        vector<vector<int>> grid(numCourses);
        for (auto& p : prerequisites)
        {
            grid[p[1]].push_back(p[0]); // p[1]-->p[0]  p[1]æ˜¯gridåæ ‡
        }

        // colors è®°å½•èŠ‚ç‚¹çŠ¶æ€ï¼š
        // 0 - æœªè®¿é—®
        // 1 - èŠ‚ç‚¹çš„é‚»å±…æ­£åœ¨è®¿é—®
        // 2 - èŠ‚ç‚¹çš„æ‰€æœ‰é‚»å±…è®¿é—®å®Œ
        vector<int> colors(numCourses); 
        
        // dfsè¿”å›trueï¼Œè¡¨ç¤ºåœ¨èŠ‚ç‚¹ x çš„å…³ç³»é‡Œï¼Œæ‰¾åˆ°äº†ç¯
        auto dfs = [&](this auto&& dfs, int x)->bool {

            colors[x] = 1; // èŠ‚ç‚¹ x çš„é‚»å±…æ­£åœ¨è®¿é—®

            // éå† x çš„é‚»å±…ï¼Œä¹Ÿå°±æ˜¯grid[x]é‡Œå­˜çš„æ•°ç»„å…ƒç´ 
            for (int y : grid[x]) 
            {
                if (colors[y] == 1 || // ä½œä¸ºxé‚»å±…ä¹‹å‰ï¼Œyå·²ç»æ­£åœ¨å¤„ç†è‡ªå·±çš„å…³ç³»ï¼Œæ’é“¾æ¡äº†
                    colors[y] == 0 && dfs(y)) // yæœªè®¿é—®ï¼Œé€’å½’è¿›å…¥dfs(y)
                {
                    return true;
                }
            }

            colors[x] = 2; // xåŠxçš„é‚»å±…è®¿é—®å®Œæ¯•
            
            return false; // æœªæ‰¾åˆ°ç¯
        };


        // éå†èŠ‚ç‚¹ï¼Œæ¯ä¸ªiéƒ½èµ°ä¸€édfsï¼Œiçš„æ‰€æœ‰å…³ç³»é‡Œå­˜ä¸å­˜åœ¨ç¯
        for (int i = 0; i < numCourses; i++)
        {
            if (colors[i] == 0 && dfs(i))   return false ;
        }

        return true;     // é¢˜ç›®ä¸­æ— ç¯æ˜¯è¿”å›true   
    }
};
~~~







## 208 [å®ç°Trie ï¼ˆå‰ç¼€æ ‘ï¼‰](https://leetcode.cn/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250830111846192](./pic/image-20250830111846192.png)

é¢˜è§£æ¥è‡ª [@è´Ÿé›ªæ˜çƒ›](https://leetcode.cn/problems/implement-trie-prefix-tree/solutions/721050/fu-xue-ming-zhu-cong-er-cha-shu-shuo-qi-628gs)  [@è·¯æ¼«æ¼«æˆ‘ä¸ç•](https://leetcode.cn/problems/implement-trie-prefix-tree/solutions/98390/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt)



![image-20250830175329709](./pic/image-20250830175329709.png)

![image-20250830175603172](./pic/image-20250830175603172.png)



![image-20250830175450601](./pic/image-20250830175450601.png)

![image-20250830175458503](./pic/image-20250830175458503.png)



![image-20250830175405944](./pic/image-20250830175405944.png)



~~~C++
class TrieNode
{
public:
    vector<TrieNode*> children;
    bool isWord;

    TrieNode() : isWord(false), children(26, nullptr) {}

    ~TrieNode() {
        for (auto& c : children)    delete c;
    }
};



class Trie {
private:
    TrieNode* root;

public:
    Trie() {
        root = new TrieNode();
    }
    ~Trie() {
        delete root;  // ä¼šé€’å½’é‡Šæ”¾æ•´æ£µæ ‘
    }
    
    void insert(string word) {
        TrieNode* cur = root; // ä»æ ¹èŠ‚ç‚¹å¼€å§‹åŒ¹é…wordçš„æ¯ä¸ªå­—ç¬¦
        for (char c : word)
        {
            if (cur->children[c - 'a'] == nullptr) // ä¸åœ¨æ ‘ä¸Šï¼Œæ’å…¥
            {
                cur->children[c - 'a'] = new TrieNode;
            } 
            cur = cur->children[c - 'a'];
        }

        cur->isWord = true; // ç»“å°¾
    }


    
    bool search(string word) {

        TrieNode* cur = root; // ä»æ ¹èŠ‚ç‚¹å¼€å§‹åŒ¹é…wordçš„æ¯ä¸ªå­—ç¬¦
        for (char c : word)
        {
            if (cur->children[c - 'a'] == nullptr) // wordæŸä¸ªå­—ç¬¦ä¸åœ¨æ ‘ä¸Š
            {
                return false;
            }  
            cur = cur->children[c - 'a'];
        }

        return cur->isWord; // curèµ°åˆ°ç»“å°¾ï¼Œæ‰ç®—æ•´ä¸ªwordåŒ¹é…    
    }
    


    bool startsWith(string prefix) { // ç±»ä¼¼serch(word)ï¼Œcuræœ€åå¯ä»¥ä¸æ˜¯ç»“å°¾
        TrieNode* cur = root;
        for (char c : prefix)
        {
            if (cur->children[c - 'a'] == nullptr)  return false;
            cur = cur->children[c - 'a'];
        }

        return true;        
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
~~~



èµ„æºé‡Šæ”¾é—®é¢˜ï¼Œæ”¹ç”¨æ™ºèƒ½æŒ‡é’ˆ

~~~C++
class TrieNode
{
public:
    vector<unique_ptr<TrieNode>> children;
    bool isWord;

    TrieNode() : isWord(false), children(26) {}
    // ä¸éœ€è¦æ‰‹å†™ææ„å‡½æ•°ï¼Œunique_ptr ä¼šè‡ªåŠ¨é€’å½’é‡Šæ”¾
};


class Trie {
private:
    unique_ptr<TrieNode> root;

public:
    Trie() {
        root = make_unique<TrieNode>();
    }
    
    void insert(string word) {
        TrieNode* cur = root.get(); // å–è£¸æŒ‡é’ˆæ“ä½œ
        for (char c : word)
        {
            if (!cur->children[c - 'a']) // ä¸åœ¨æ ‘ä¸Šï¼Œæ’å…¥
            {
                cur->children[c - 'a'] = make_unique<TrieNode>();
            }
            cur = cur->children[c - 'a'].get();
        }

        cur->isWord = true;
    }

    bool search(string word) {
        TrieNode* cur = root.get();
        for (char c : word)
        {
            if (!cur->children[c - 'a']) // ä¸å­˜åœ¨
            {
                return false;
            }  
            cur = cur->children[c - 'a'].get();
        }

        return cur->isWord;  
    }
    
    bool startsWith(string prefix) {
        TrieNode* cur = root.get();
        for (char c : prefix)
        {
            if (!cur->children[c - 'a']) return false;
            cur = cur->children[c - 'a'].get();
        }

        return true;        
    }
};
~~~









# æŠ€å·§ âœ…

## 136 åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—

![image-20250808155940561](./pic/image-20250808155940561.png)

![image-20250808155925812](./pic/image-20250808155925812.png)

![image-20250808155947166](./pic/image-20250808155947166.png)

å¼‚æˆ–è¿ç®—æ»¡è¶³**äº¤æ¢å¾‹** aâŠ•b=bâŠ•a ï¼Œå³ä»¥ä¸Šè¿ç®—ç»“æœä¸ nums çš„å…ƒç´ é¡ºåºæ— å…³ã€‚

~~~C++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        
        // å¼‚æˆ– æ¶ˆé™¤ç›¸åŒçš„æ•°å­—

        int ans = 0;
        for (int val : nums)
        {
            ans ^= val; // éå†nums æ‰§è¡Œå¼‚æˆ–ï¼Œæœ€åç•™ä¸‹çš„å°±æ˜¯å‡ºç°ä¸€æ¬¡çš„æ•°å­—
        }

        return ans;
    }
};
~~~



ACM 

~~~C++
#include <vector>
#include <iostream>

using namespace std;

// 136 åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—

int singleNumber(vector<int>& nums) {
    
    // å¼‚æˆ– æ¶ˆé™¤ç›¸åŒçš„æ•°å­—

    int ans = 0;
    for (int val : nums)
    {
        ans ^= val; // éå†nums æ‰§è¡Œå¼‚æˆ–ï¼Œæœ€åç•™ä¸‹çš„å°±æ˜¯å‡ºç°ä¸€æ¬¡çš„æ•°å­—
    }

    return ans;
}

int main()
{
    vector<int> nums = {2, 2, 3, 3, 4};
    int ans = singleNumber(nums);
    cout << ans << endl;
    
    return 0;
}
~~~





## 169 [å¤šæ•°å…ƒç´ ](https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250809093934885](./pic/image-20250809093934885.png)



### 1ã€å“ˆå¸Œè¡¨

~~~C++
class Solution {
public:
    int majorityElement(vector<int>& nums) {


        unordered_map<int, int> counts;// å­˜å‚¨æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°
        
        int majority = 0; // å‡ºç°æœ€å¤šçš„å…ƒç´ 
        int cnt = 0;      // å‡ºç°æœ€å¤šçš„æ¬¡æ•°

        for (int num : nums)
        {
            counts[num]++; // è®¡æ•°
            if (counts[num] > cnt)
            {
                majority = num;
                cnt = counts[num];
            }
        }

        return majority;        
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ï¼šO(n)

ç©ºé—´å¤æ‚åº¦ï¼šO(n)



### 2ã€æ’åº

![image-20250809094939242](./pic/image-20250809094939242.png)

~~~C++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        
        // æ’åº
        sort(nums.begin(), nums.end());
        return nums[nums.size() / 2]; // ä¸‹æ ‡[n/2]å¤„æ˜¯ä¼—æ•°
    }
};
~~~

æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)ã€‚

ç©ºé—´å¤æ‚åº¦ï¼šO(logn)ã€‚å¦‚æœä½¿ç”¨è¯­è¨€è‡ªå¸¦çš„æ’åºç®—æ³•ï¼Œéœ€è¦ä½¿ç”¨ O(logn) çš„æ ˆç©ºé—´ã€‚å¦‚æœè‡ªå·±ç¼–å†™å †æ’åºï¼Œåˆ™åªéœ€è¦ä½¿ç”¨ O(1) çš„é¢å¤–ç©ºé—´ã€‚



### 3ã€æ‘©å°”æŠ•ç¥¨

è®°ä½ç»“è®ºå°±å¥½

![image-20250809161651460](./pic/image-20250809161651460.png)

![image-20250809161635757](./pic/image-20250809161635757.png)

![image-20250809163640100](./pic/image-20250809163640100.png)



~~~C++
class Solution {
public:
    int majorityElement(vector<int>& nums) {

        // æ‘©å°”æŠ•ç¥¨ï¼ˆç›´æ¥è®°ä½æ–¹æ³•ï¼‰

        int candidate = 0; // å€™é€‰ä¼—æ•°
        int votes = 0; // æŠ•ç¥¨

        for (int num : nums)
        {
            if (votes == 0) candidate = num; // æ¯å½“votes=0ï¼Œæ›´æ–°å€™é€‰ä¼—æ•°
            votes += (num == candidate ? 1 : -1); // num = candidate æŠ•ç¥¨+1ï¼Œå¦åˆ™-1
        }

        return candidate;    
    }
};
~~~



### ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 169 å¤šæ•°å…ƒç´ 

int majorityElement(vector<int>& nums) {

    // æ‘©å°”æŠ•ç¥¨

    int candidate = 0; // å€™é€‰ä¼—æ•°
    int votes = 0; // æŠ•ç¥¨

    for (int num : nums)
    {
        if (votes == 0) candidate = num; // æ¯å½“votes=0ï¼Œæ›´æ–°å€™é€‰ä¼—æ•°
        votes += (num == candidate ? 1 : -1); // num = candidate æŠ•ç¥¨+1ï¼Œå¦åˆ™-1
    }

    return candidate;
}


int main()
{
    vector<int> nums = {2,2,1,1,1,2,2};
    int ans = majorityElement(nums);

    cout << ans << endl;

    return 0;
}
~~~





## 75 [é¢œè‰²åˆ†ç±»](https://leetcode.cn/problems/sort-colors/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250809231326771](./pic/image-20250809231326771.png)

![image-20250809231522678](./pic/image-20250809231522678.png)

![image-20250809231806307](./pic/image-20250809231806307.png)

![image-20250809231815853](./pic/image-20250809231815853.png)

å¤æ‚åº¦åˆ†æ

- æ—¶é—´å¤æ‚åº¦ï¼šO(*n*)ï¼Œå…¶ä¸­ *n* æ˜¯ *nums* çš„é•¿åº¦ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ã€‚



![image-20250809235538404](./pic/image-20250809235538404.png)

**æ¨¡æ‹Ÿå‘ nums æœ‰åºçš„ [0, i-1] èŒƒå›´ï¼Œæ’å…¥nums[i]ï¼Œç„¶åå˜æˆæœ‰åºçš„ [0, i] èŒƒå›´**ï¼Œå‘åéå†ï¼Œç›´åˆ°numsæœ€åã€‚

**ä¸‰ä¸ªä½ç½®ï¼š**

- p0 ï¼šç»´æŠ¤ 0 çš„ä¸ªæ•°ï¼Œè¡¨ç¤ºä¸‹ä¸€ä¸ªè¦æ’å…¥0 çš„ä½ç½®
- p1ï¼šç»´æŠ¤ 1 çš„ä¸ªæ•°ï¼Œè¡¨ç¤ºä¸‹ä¸€ä¸ªè¦æ’å…¥1çš„ä½ç½®
- i ï¼š éå†ä¸‹æ ‡ï¼Œæ’å…¥nums[i]åçš„æœ‰åºèŒƒå›´å°±æ˜¯ [0, i]ï¼Œä¹Ÿå°±æ˜¯ç›®å‰æœ‰åºæ•°ç»„çš„æœ€åä¸€ä¸ªä½ç½®ï¼Œè¡¨ç¤ºè¦æ”¹æˆ2çš„ä½ç½®

**1ã€æ’å…¥å€¼ï¼Œç›´æ¥æ”¹æœ€åä¸€ä¸ªå€¼ä¸º2**â€”â€”  `nums[i] = 2`

> å› ä¸º 2 ä½ç½®å‰æ˜¯åŒ…æ‹¬0 å’Œ 1 å’Œ 2 çš„ï¼Œæ‰€ä»¥æ’0æ’1æ’2éƒ½è¦åŠ¨è¿™ä¸ªä½ç½®

- å¦‚æœæ’å…¥çš„æ˜¯2ï¼Œé‚£æ­£å¥½ 2 åº”è¯¥æ”¾åœ¨æœ€å
- å¦‚æœæ’å…¥çš„ä¸æ˜¯2ï¼Œä¸‹é¢çš„ `if 0 or 1` ä¼šè¦†ç›–å‰é¢åº”è¯¥æ˜¯ 0 or 1çš„ä½ç½®ï¼Œä¹Ÿç›¸å½“äºæŠŠ2æŒªåˆ°äº†æœ€å

**2ã€å¦‚æœæ’å…¥çš„æ˜¯ 0 æˆ– 1 â€”â€” ä¿®æ”¹ p1 ä½ç½®ä¸º1ï¼Œå¹¶åç§» p1**  `nums[p1++] = 1`

> å› ä¸º p1 ä½ç½®å‰æ˜¯åŒ…æ‹¬0 å’Œ 1 çš„ï¼Œæ‰€ä»¥æ’0æ’1éƒ½è¦åŠ¨è¿™ä¸ªä½ç½®

- å¦‚æœæ’çš„æ˜¯1ï¼Œæ”¹å®Œè¿™ä¸ªä½ç½®ï¼Œç»“æŸ
- å¦‚æœæ’çš„æ˜¯0ï¼Œä¸‹é¢çš„`if 0` ä¼šè¦†ç›–å‰é¢åº”è¯¥æ˜¯ 0 çš„ä½ç½®ï¼Œä¹Ÿç›¸å½“äºæŠŠ 1 åç§»äº†

**3ã€å¦‚æœæ’å…¥çš„æ˜¯0 â€”â€” ä¿®æ”¹ p0 ä½ç½®ä¸º0ï¼Œå¹¶åç§» p0** `nums[p0++] = 0`

- ç›´æ¥æ”¹ p0 ä½ç½®ï¼Œéœ€è¦åç§»çš„ 1 å’Œ 2 éƒ½åœ¨ä¸Šé¢å¤„ç†äº†



~~~C++
class Solution {
public:
    void sortColors(vector<int>& nums) {

        int p0 = 0; // ç»´æŠ¤0çš„ä¸ªæ•°ï¼ˆä¸‹æ ‡ï¼‰
        int p1 = 0; // ç»´æŠ¤1çš„ä¸ªæ•°ï¼ˆä¸‹æ ‡ï¼‰

        
        for (int i = 0; i < nums.size(); i++)
        {
            int x = nums[i]; // ä¸æ–­å‘numsçš„[0, i-1] ä¸­æ’å…¥å½“å‰ nums[i]

            nums[i] = 2;                // ç›´æ¥æœ€åä¸€ä¸ªä½ç½®æ”¹ä¸º2ï¼Œ2å§‹ç»ˆåœ¨æœ€å
            if (x <= 1) nums[p1++] = 1; // æ’å…¥çš„æ˜¯ 0 æˆ– 1 
            if (x == 0) nums[p0++] = 0; // æ’å…¥çš„æ˜¯ 0
        }
        
    }
};
~~~



ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 75 é¢œè‰²åˆ†ç±»

void sortColors(vector<int>& nums) {

    int p0 = 0; // ç»´æŠ¤0çš„ä¸ªæ•°ï¼ˆä¸‹æ ‡ï¼‰
    int p1 = 0; // ç»´æŠ¤1çš„ä¸ªæ•°ï¼ˆä¸‹æ ‡ï¼‰

    
    for (int i = 0; i < nums.size(); i++)
    {
        int x = nums[i]; // ä¸æ–­å‘numsçš„[0, i-1] ä¸­æ’å…¥å½“å‰ nums[i]

        nums[i] = 2;                // ç›´æ¥æœ€åä¸€ä¸ªä½ç½®æ”¹ä¸º2ï¼Œ2å§‹ç»ˆåœ¨æœ€å
        if (x <= 1) nums[p1++] = 1; // æ’å…¥çš„æ˜¯ 0 æˆ– 1 
        if (x == 0) nums[p0++] = 0; // æ’å…¥çš„æ˜¯ 0
    }
    
}


int main()
{
    vector<int> nums = {2, 0, 2, 1, 1, 0};
    sortColors(nums);
    for (int val : nums)
    {
        cout << val << " ";
    }
    cout << endl;

    return 0;
}

~~~



## 31 [ä¸‹ä¸€ä¸ªæ’åˆ—](https://leetcode.cn/problems/next-permutation/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250810212702731](./pic/image-20250810212702731.png)

åƒåœ¾é¢˜ç›®æè¿°

è¯„è®ºåŒºç»™çš„ç¤ºä¾‹ï¼š[1, 2, 3] æ’åˆ—ç»„åˆï¼Œä»å°åˆ°å¤§

[1, 2, 3] 123
[1, 3, 2] 132
[2, 1, 3] 213
[2, 3, 1] 231
[3, 1, 2] 312
[3, 2, 1] 321

[1,2,3]ä¸‹ä¸€ä¸ªå°±æ˜¯[1, 3, 2]
[2, 3, 1]çš„ä¸‹ä¸€ä¸ªå°±æ˜¯[3, 1, 2]
[3, 2, 1]çš„ä¸‹ä¸€ä¸ªæ˜¯[1, 2, 3] å›åˆ°èµ·ç‚¹

![image-20250810213112725](./pic/image-20250810213112725.png)![image-20250810220059066](./pic/image-20250810220059066.png)![image-20250810213956893](./pic/image-20250810213956893.png)

![image-20250810214306326](./pic/image-20250810214306326.png)



~~~C++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {

        int n = nums.size();

        // [1, 3, 5, 4, 2] æ’åˆ—ç»„åˆé‡Œé¢çš„æ•°å­—ï¼Œæ‰¾ä¸‹ä¸€ä¸ªæ¯”13542å¤§çš„ç»„åˆ

        // 1. ä»å³å‘å·¦æ‰¾åˆ°ç¬¬ä¸€ä¸ªå°äºå³ä¾§ç›¸é‚»æ•°å­—çš„æ•° nums[i] (3)
        int i = n - 2;
        while (i >=0 && nums[i] >= nums[i + 1]) i--;


        // æ‰¾åˆ°ï¼Œè¿›å…¥ç¬¬2æ­¥ï¼›å¦åˆ™(i < 0)è·³è¿‡ç¬¬2æ­¥ï¼Œè¯´æ˜ç°åœ¨æ’åˆ—é€’å‡ï¼Œæ˜¯æœ€å¤§æ•°        
        if (i >= 0) 
        {
            // 2. ä»å³å‘å·¦ï¼Œæ‰¾åˆ° i å³ä¾§ç¬¬ä¸€ä¸ªå¤§äº nums[i](3) çš„æ•° nums[j](4)ï¼Œäº¤æ¢
            int j = n - 1;
            while (j > i && nums[i] >= nums[j])  j--;
  
            swap(nums[i], nums[j]); // [1, 4, 5, 3, 2]
        }


        // 3 åè½¬ æ–°nums[i] åé¢çš„æ•° -  [1, 4, 2, 3, 5]
        reverse(nums.begin() + i + 1, nums.end());
        
    }
};
~~~

å¤æ‚åº¦åˆ†æ

- æ—¶é—´å¤æ‚åº¦ï¼šO(*n*)ï¼Œå…¶ä¸­ *n* æ˜¯ *nums* çš„é•¿åº¦ã€‚æœ€åæƒ…å†µä¸‹éœ€è¦éå†æ•´ä¸ª *nums* æ•°ç»„ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ã€‚





ACM

~~~C++
#include <vector>
#include <iostream>
using namespace std;

// 31 ä¸‹ä¸€ä¸ªæ’åˆ—


void nextPermutation(vector<int>& nums) {

    int n = nums.size();

    // [1, 3, 5, 4, 2] æ’åˆ—ç»„åˆé‡Œé¢çš„æ•°å­—ï¼Œæ‰¾ä¸‹ä¸€ä¸ªæ¯”13542å¤§çš„ç»„åˆ

    // 1. ä»å³å‘å·¦æ‰¾åˆ°ç¬¬ä¸€ä¸ªå°äºå³ä¾§ç›¸é‚»æ•°å­—çš„æ•° nums[i] (3)
    int i = n - 2;
    while (i >=0 && nums[i] >= nums[i + 1]) i--;


    // æ‰¾åˆ°ï¼Œè¿›å…¥ç¬¬2æ­¥ï¼›å¦åˆ™(i < 0)è·³è¿‡ç¬¬2æ­¥ï¼Œè¯´æ˜ç°åœ¨æ’åˆ—é€’å‡ï¼Œæ˜¯æœ€å¤§æ•°        
    if (i >= 0) 
    {
        // 2. ä»å³å‘å·¦ï¼Œæ‰¾åˆ° i å³ä¾§ç¬¬ä¸€ä¸ªå¤§äº nums[i](3) çš„æ•° nums[j](4)ï¼Œäº¤æ¢
        int j = n - 1;
        while (j > i && nums[i] >= nums[j])  j--;

        swap(nums[i], nums[j]); // [1, 4, 5, 3, 2]
    }


    // 3 åè½¬ æ–°nums[i] åé¢çš„æ•° -  [1, 4, 2, 3, 5]
    reverse(nums.begin() + i + 1, nums.end());
    
}


int main()
{
    vector<int> nums = {1, 2, 3};
    nextPermutation(nums);
    for (int val : nums)    cout << val << " ";
    cout << endl;

    return 0;
}
~~~





## 287 [å¯»æ‰¾é‡å¤æ•°](https://leetcode.cn/problems/find-the-duplicate-number/description/?envType=study-plan-v2&envId=top-100-liked)

![image-20250810225618176](./pic/image-20250810225618176.png)



è‡ªå·±å†™çš„ï¼Œä½†æ˜¯ä¸è®©ä¿®æ”¹åŸæ•°ç»„ï¼Œä¸èƒ½æ’åºï¼Œç®—äº†

äºŒåˆ†æ¯”è¾ƒçœŸæ­£çš„ä¸­é—´å€¼ï¼Œå’Œå®é™…çš„ä¸­é—´å€¼ï¼Œä¸¾ä¸ªä¾‹å­çœ‹

æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)

ç©ºé—´å¤æ‚åº¦ï¼šO(1)

~~~C++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
    
        sort(nums.begin(), nums.end());

        // [1, 2, 2, 3, 4] å¯¹åº”çš„æ²¡æœ‰é‡å¤çš„æ•°ç»„ï¼š
        // [1, 2, 3, 4, 5]
        
        // æ¯”è¾ƒä¸­é—´å€¼ï¼ŒäºŒåˆ†

        int left = 0;
        int right = nums.size() - 1; // åæ ‡

        while (left <= right)
        {
            int midnum = ((left + 1) + (right + 1)) / 2; // çœŸæ­£çš„ä¸­é—´å€¼[3] 
            int midIndex = left + ((right - left) / 2); 
            
            if (nums[midIndex] >= midnum) // å¾€å³æ‰¾ 
            {
                left = midIndex + 1;
            }
            else // å¾€å·¦æ‰¾ [2] < [3]
            {
                right = midIndex - 1;
            }
        }

        return nums[right];
        
    }
};
~~~



### 1ã€äºŒåˆ†

![image-20250811105312019](./pic/image-20250811105312019.png)



~~~C++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        // [1, 3, 4, 2, 2]

        // æ•°å€¼èŒƒå›´ minï¼Œmax æ˜¯ 1 åˆ° n  [1,4]
        int min = 1; 
        int max = nums.size(); 

        while (min < max)
        {
            int mid = (min + max) / 2; // æ•°å€¼çš„ä¸­é—´å€¼ (1 + 4)/2 = 2

            // ç»Ÿè®¡[1,n/2]èŒƒå›´çš„æ•°å­—ä¸ªæ•° [1,2]
            int cnt = 0; 
            for (int v : nums)
            {
                if (v >= min && v <= mid)    cnt++; 
            }

            // ä¸ªæ•°è¶…è¿‡èŒƒå›´åº”æœ‰çš„é•¿åº¦ï¼Œå³å­˜åœ¨é‡å¤æ•° ï¼ˆ[1,2]åº”è¯¥åªæœ‰ä¸¤ä¸ªæ•°ï¼Œä½†numsä¸­æœ‰3ä¸ªï¼‰
            if (cnt > mid - min + 1)    max = mid;
            else                        min = mid + 1;
        }
        
        return min; // æœ€åminåœåœ¨ç›®æ ‡æ•°å­—ä¸Š
    }
};
~~~

